// This file has been generated by Py++.

#include "boost/python.hpp"
#include "__call_policies.pypp.hpp"
#include "__convenience.pypp.hpp"
#include "wrap_osgManipulator.h"
#include "wrap_referenced.h"
#include "MotionCommand.pypp.hpp"

namespace bp = boost::python;

struct MotionCommand_wrapper : osgManipulator::MotionCommand, bp::wrapper< osgManipulator::MotionCommand > {

    virtual void accept( ::osgManipulator::Constraint const & constraint ) {
        namespace bpl = boost::python;
        if( bpl::override func_accept = this->get_override( "accept" ) ){
            bpl::object py_result = bpl::call<bpl::object>( func_accept.ptr(), constraint );
        }
        else{
            osgManipulator::MotionCommand::accept( boost::ref(constraint) );
        }
    }
    
    static void default_accept_cca4ad22050aa9c07ecd4911ed1fd170( ::osgManipulator::MotionCommand & inst, ::osgManipulator::Constraint & constraint ){
        if( dynamic_cast< MotionCommand_wrapper * >( boost::addressof( inst ) ) ){
            inst.::osgManipulator::MotionCommand::accept(constraint);
        }
        else{
            inst.accept(constraint);
        }
    }

    virtual void accept( ::osgManipulator::DraggerCallback & callback ) {
        if( bp::override func_accept = this->get_override( "accept" ) )
            func_accept( boost::ref(callback) );
        else{
            this->osgManipulator::MotionCommand::accept( boost::ref(callback) );
        }
    }
    
    void default_accept( ::osgManipulator::DraggerCallback & callback ) {
        osgManipulator::MotionCommand::accept( boost::ref(callback) );
    }

    virtual ::osgManipulator::MotionCommand * createCommandInverse(  ){
        bp::override func_createCommandInverse = this->get_override( "createCommandInverse" );
        return func_createCommandInverse(  );
    }

    virtual ::osg::Matrix getMotionMatrix(  ) const {
        bp::override func_getMotionMatrix = this->get_override( "getMotionMatrix" );
        return func_getMotionMatrix(  );
    }

};

void register_MotionCommand_class(){

    { //::osgManipulator::MotionCommand
        typedef bp::class_< MotionCommand_wrapper, bp::bases< ::osg::Referenced >, osg::ref_ptr< MotionCommand_wrapper >, boost::noncopyable > MotionCommand_exposer_t;
        MotionCommand_exposer_t MotionCommand_exposer = MotionCommand_exposer_t( "MotionCommand", "\n Base class for motion commands that are generated by draggers.\n", bp::no_init );
        bp::scope MotionCommand_scope( MotionCommand_exposer );
        bp::enum_< osgManipulator::MotionCommand::Stage>("Stage")
            .value("NONE", osgManipulator::MotionCommand::NONE)
            .value("START", osgManipulator::MotionCommand::START)
            .value("MOVE", osgManipulator::MotionCommand::MOVE)
            .value("FINISH", osgManipulator::MotionCommand::FINISH)
            .export_values()
            ;
        { //::osgManipulator::MotionCommand::accept
        
            typedef void ( *default_accept_function_type )( ::osgManipulator::MotionCommand &,::osgManipulator::Constraint & );
            
            MotionCommand_exposer.def( 
                "accept"
                , default_accept_function_type( &MotionCommand_wrapper::default_accept_cca4ad22050aa9c07ecd4911ed1fd170 )
                , ( bp::arg("inst"), bp::arg("constraint") ) );
        
        }
        { //::osgManipulator::MotionCommand::accept
        
            typedef void ( ::osgManipulator::MotionCommand::*accept_function_type )( ::osgManipulator::DraggerCallback & ) ;
            typedef void ( MotionCommand_wrapper::*default_accept_function_type )( ::osgManipulator::DraggerCallback & ) ;
            
            MotionCommand_exposer.def( 
                "accept"
                , accept_function_type(&::osgManipulator::MotionCommand::accept)
                , default_accept_function_type(&MotionCommand_wrapper::default_accept)
                , ( bp::arg("callback") ) );
        
        }
        { //::osgManipulator::MotionCommand::createCommandInverse
        
            typedef ::osgManipulator::MotionCommand * ( ::osgManipulator::MotionCommand::*createCommandInverse_function_type )(  ) ;
            
            MotionCommand_exposer.def( 
                "createCommandInverse"
                , bp::pure_virtual( createCommandInverse_function_type(&::osgManipulator::MotionCommand::createCommandInverse) )
                , bp::return_internal_reference< >()
                , "\n create a MotionCommand that is the inverse of this command, and if applied will undo this commands changes.\n" );
        
        }
        { //::osgManipulator::MotionCommand::getLocalToWorld
        
            typedef ::osg::Matrix const & ( ::osgManipulator::MotionCommand::*getLocalToWorld_function_type )(  ) const;
            
            MotionCommand_exposer.def( 
                "getLocalToWorld"
                , getLocalToWorld_function_type( &::osgManipulator::MotionCommand::getLocalToWorld )
                , bp::return_internal_reference< >()
                , " Gets the matrix for transforming the commands local coordinate\n system to the world/object coordinate system." );
        
        }
        { //::osgManipulator::MotionCommand::getMotionMatrix
        
            typedef ::osg::Matrix ( ::osgManipulator::MotionCommand::*getMotionMatrix_function_type )(  ) const;
            
            MotionCommand_exposer.def( 
                "getMotionMatrix"
                , bp::pure_virtual( getMotionMatrix_function_type(&::osgManipulator::MotionCommand::getMotionMatrix) )
                , "\n Gets the matrix for transforming the object being dragged. This matrix is in the\n commands coordinate systems.\n" );
        
        }
        { //::osgManipulator::MotionCommand::getStage
        
            typedef ::osgManipulator::MotionCommand::Stage ( ::osgManipulator::MotionCommand::*getStage_function_type )(  ) const;
            
            MotionCommand_exposer.def( 
                "getStage"
                , getStage_function_type( &::osgManipulator::MotionCommand::getStage ) );
        
        }
        { //::osgManipulator::MotionCommand::getWorldToLocal
        
            typedef ::osg::Matrix const & ( ::osgManipulator::MotionCommand::*getWorldToLocal_function_type )(  ) const;
            
            MotionCommand_exposer.def( 
                "getWorldToLocal"
                , getWorldToLocal_function_type( &::osgManipulator::MotionCommand::getWorldToLocal )
                , bp::return_internal_reference< >()
                , " Gets the matrix for transforming the commands world/object\n coordinate system to the commands local coordinate system." );
        
        }
        { //::osgManipulator::MotionCommand::setLocalToWorldAndWorldToLocal
        
            typedef void ( ::osgManipulator::MotionCommand::*setLocalToWorldAndWorldToLocal_function_type )( ::osg::Matrix const &,::osg::Matrix const & ) ;
            
            MotionCommand_exposer.def( 
                "setLocalToWorldAndWorldToLocal"
                , setLocalToWorldAndWorldToLocal_function_type( &::osgManipulator::MotionCommand::setLocalToWorldAndWorldToLocal )
                , ( bp::arg("localToWorld"), bp::arg("worldToLocal") )
                , " Sets the matrix for transforming the commands local coordinate\n system to the world/object coordinate system." );
        
        }
        { //::osgManipulator::MotionCommand::setStage
        
            typedef void ( ::osgManipulator::MotionCommand::*setStage_function_type )( ::osgManipulator::MotionCommand::Stage const ) ;
            
            MotionCommand_exposer.def( 
                "setStage"
                , setStage_function_type( &::osgManipulator::MotionCommand::setStage )
                , ( bp::arg("s") ) );
        
        }
    }

}
