// This file has been generated by Py++.

#include "boost/python.hpp"
#include "indexing_suite/container_suite.hpp"
#include "indexing_suite/deque.hpp"
#include "wrap_osgDB.h"
#include "FilePathList.pypp.hpp"

namespace bp = boost::python;

void register_FilePathList_class(){

    { //::std::deque< std::string >
        typedef bp::class_< std::deque< std::string > > FilePathList_exposer_t;
        FilePathList_exposer_t FilePathList_exposer = FilePathList_exposer_t( "FilePathList", "\n   A standard container using fixed-size memory allocation and\n  constant-time manipulation of elements at either end.\n\n  fngroup sequences\n\n  Tparam: _Tp  Type of element.\n  Tparam: _Alloc  Allocator type, defaults to allocator<_Tp>.\n\n  Meets the requirements of a <a href=tables.html#65>container</a>, a\n  <a href=tables.html#66>reversible container</a>, and a\n  <a href=tables.html#67>sequence</a>, including the\n  <a href=tables.html#68>optional sequence requirements</a>.\n\n  In previous HP/SGI versions of deque, there was an extra template\n  parameter so users could control the node size.  This extension turned\n  out to violate the C++ standard (it can be detected using template\n  template parameters), and it was removed.\n\n  Heres how a deque<Tp> manages memory.  Each deque has 4 members:\n\n  - Tp**        _M_map\n  - size_t      _M_map_size\n  - iterator    _M_start, _M_finish\n\n  map_size is at least 8.  %map is an array of map_size\n  pointers-to-@a nodes.  (The name %map has nothing to do with the\n  std::map class, and @b nodes should not be confused with\n  std::lists usage of @a node.)\n\n  A @a node has no specific type name as such, but it is referred\n  to as @a node in this file.  It is a simple array-of-Tp.  If Tp\n  is very large, there will be one Tp element per node (i.e., an\n  @a array of one).  For non-huge Tps, node size is inversely\n  related to Tp size: the larger the Tp, the fewer Tps will fit\n  in a node.  The goal here is to keep the total size of a node\n  relatively small and constant over different Tps, to improve\n  allocator efficiency.\n\n  Not every pointer in the %map array will point to a node.  If\n  the initial number of elements in the deque is small, the\n  /middle/ %map pointers will be valid, and the ones at the edges\n  will be unused.  This same situation will arise as the %map\n  grows: available %map pointers, if any, will be on the ends.  As\n  new nodes are created, only a subset of the %maps pointers need\n  to be copied @a outward.\n\n  Class invariants:\n - For any nonsingular iterator i:\n    - i.node points to a member of the %map array.  (Yes, you read that\n      correctly:  i.node does not actually point to a node.)  The member of\n      the %map array is what actually points to the node.\n    - i.first == *(i.node)    (This points to the node (first Tp element).)\n    - i.last  == i.first + node_size\n    - i.cur is a pointer in the range [i.first, i.last).  NOTE:\n      the implication of this is that i.cur is always a dereferenceable\n      pointer, even if i is a past-the-end iterator.\n - Start and Finish are always nonsingular iterators.  NOTE: this\n means that an empty deque must have one node, a deque with <N\n elements (where N is the node buffer size) must have one node, a\n deque with N through (2N-1) elements must have two nodes, etc.\n - For every node other than start.node and finish.node, every\n element in the node is an initialized object.  If start.node ==\n finish.node, then [start.cur, finish.cur) are initialized\n objects, and the elements outside that range are uninitialized\n storage.  Otherwise, [start.cur, start.last) and [finish.first,\n finish.cur) are initialized objects, and [start.first, start.cur)\n and [finish.cur, finish.last) are uninitialized storage.\n - [%map, %map + map_size) is a valid, non-empty range.\n - [start.node, finish.node] is a valid range contained within\n   [%map, %map + map_size).\n - A pointer in the range [%map, %map + map_size) points to an allocated\n   node if and only if the pointer is in the range\n   [start.node, finish.node].\n\n  Heres the magic:  nothing in deque is @b aware of the discontiguous\n  storage!\n\n  The memory setup and layout occurs in the parent, _Base, and the iterator\n  class is entirely responsible for @a leaping from one node to the next.\n  All the implementation routines for deque itself work only through the\n  start and finish iterators.  This keeps the routines simple and sane,\n  and we can use other standard algorithms as well.\n" );
        bp::scope FilePathList_scope( FilePathList_exposer );
        FilePathList_exposer.def( bp::indexing::deque_suite< std::deque< std::string > >() );
    }

}
