// This file has been generated by Py++.

#include "boost/python.hpp"
#include "__call_policies.pypp.hpp"
#include "__convenience.pypp.hpp"
#include "wrap_osgGA.h"
#include "wrap_referenced.h"
#include "CameraManipulator.pypp.hpp"

namespace bp = boost::python;

struct CameraManipulator_wrapper : osgGA::CameraManipulator, bp::wrapper< osgGA::CameraManipulator > {

    struct CoordinateFrameCallback_wrapper : osgGA::CameraManipulator::CoordinateFrameCallback, bp::wrapper< osgGA::CameraManipulator::CoordinateFrameCallback > {
    
        CoordinateFrameCallback_wrapper()
        : osgGA::CameraManipulator::CoordinateFrameCallback()
          , bp::wrapper< osgGA::CameraManipulator::CoordinateFrameCallback >(){
            // null constructor
            
        }
    
        virtual ::osg::CoordinateFrame getCoordinateFrame( ::osg::Vec3d const & position ) const {
            bp::override func_getCoordinateFrame = this->get_override( "getCoordinateFrame" );
            return func_getCoordinateFrame( boost::ref(position) );
        }
    
    };

    virtual char const * className(  ) const  {
        if( bp::override func_className = this->get_override( "className" ) )
            return func_className(  );
        else{
            return this->osgGA::CameraManipulator::className(  );
        }
    }
    
    char const * default_className(  ) const  {
        return osgGA::CameraManipulator::className( );
    }

    virtual void computeHomePosition( ::osg::Camera const * camera=0l, bool useBoundingBox=false ) {
        if( bp::override func_computeHomePosition = this->get_override( "computeHomePosition" ) )
            func_computeHomePosition( boost::python::ptr(camera), useBoundingBox );
        else{
            this->osgGA::CameraManipulator::computeHomePosition( boost::python::ptr(camera), useBoundingBox );
        }
    }
    
    void default_computeHomePosition( ::osg::Camera const * camera=0l, bool useBoundingBox=false ) {
        osgGA::CameraManipulator::computeHomePosition( boost::python::ptr(camera), useBoundingBox );
    }

    virtual ::osgUtil::SceneView::FusionDistanceMode getFusionDistanceMode(  ) const  {
        if( bp::override func_getFusionDistanceMode = this->get_override( "getFusionDistanceMode" ) )
            return func_getFusionDistanceMode(  );
        else{
            return this->osgGA::CameraManipulator::getFusionDistanceMode(  );
        }
    }
    
    ::osgUtil::SceneView::FusionDistanceMode default_getFusionDistanceMode(  ) const  {
        return osgGA::CameraManipulator::getFusionDistanceMode( );
    }

    virtual float getFusionDistanceValue(  ) const  {
        if( bp::override func_getFusionDistanceValue = this->get_override( "getFusionDistanceValue" ) )
            return func_getFusionDistanceValue(  );
        else{
            return this->osgGA::CameraManipulator::getFusionDistanceValue(  );
        }
    }
    
    float default_getFusionDistanceValue(  ) const  {
        return osgGA::CameraManipulator::getFusionDistanceValue( );
    }

    virtual void getHomePosition( ::osg::Vec3d & eye, ::osg::Vec3d & center, ::osg::Vec3d & up ) const  {
        if( bp::override func_getHomePosition = this->get_override( "getHomePosition" ) )
            func_getHomePosition( boost::ref(eye), boost::ref(center), boost::ref(up) );
        else{
            this->osgGA::CameraManipulator::getHomePosition( boost::ref(eye), boost::ref(center), boost::ref(up) );
        }
    }
    
    void default_getHomePosition( ::osg::Vec3d & eye, ::osg::Vec3d & center, ::osg::Vec3d & up ) const  {
        osgGA::CameraManipulator::getHomePosition( boost::ref(eye), boost::ref(center), boost::ref(up) );
    }

    virtual ::osg::Matrixd getInverseMatrix(  ) const {
        bp::override func_getInverseMatrix = this->get_override( "getInverseMatrix" );
        return func_getInverseMatrix(  );
    }

    virtual ::osg::Matrixd getMatrix(  ) const {
        bp::override func_getMatrix = this->get_override( "getMatrix" );
        return func_getMatrix(  );
    }

    virtual ::osg::Node const * getNode(  ) const  {
        if( bp::override func_getNode = this->get_override( "getNode" ) )
            return func_getNode(  );
        else{
            return this->osgGA::CameraManipulator::getNode(  );
        }
    }
    
    ::osg::Node const * default_getNode(  ) const  {
        return osgGA::CameraManipulator::getNode( );
    }

    virtual ::osg::Node * getNode(  ) {
        if( bp::override func_getNode = this->get_override( "getNode" ) )
            return func_getNode(  );
        else{
            return this->osgGA::CameraManipulator::getNode(  );
        }
    }
    
    ::osg::Node * default_getNode(  ) {
        return osgGA::CameraManipulator::getNode( );
    }

    virtual bool handle( ::osgGA::GUIEventAdapter const & ea, ::osgGA::GUIActionAdapter & us ) {
        namespace bpl = boost::python;
        if( bpl::override func_handle = this->get_override( "handle" ) ){
            bpl::object py_result = bpl::call<bpl::object>( func_handle.ptr(), ea, us );
            return bpl::extract< bool >( pyplus_conv::get_out_argument( py_result, 0 ) );
        }
        else{
            return osgGA::CameraManipulator::handle( boost::ref(ea), boost::ref(us) );
        }
    }
    
    static boost::python::object default_handle( ::osgGA::CameraManipulator & inst, ::osgGA::GUIEventAdapter & ea, ::osgGA::GUIActionAdapter & us ){
        bool result;
        if( dynamic_cast< CameraManipulator_wrapper * >( boost::addressof( inst ) ) ){
            result = inst.::osgGA::CameraManipulator::handle(ea, us);
        }
        else{
            result = inst.handle(ea, us);
        }
        return bp::object( result );
    }

    virtual void home( ::osgGA::GUIEventAdapter const & arg0, ::osgGA::GUIActionAdapter & arg1 ) {
        namespace bpl = boost::python;
        if( bpl::override func_home = this->get_override( "home" ) ){
            bpl::object py_result = bpl::call<bpl::object>( func_home.ptr(), arg0, arg1 );
        }
        else{
            osgGA::CameraManipulator::home( boost::ref(arg0), boost::ref(arg1) );
        }
    }
    
    static void default_home_9715462911072744dcf4ae663764b018( ::osgGA::CameraManipulator & inst, ::osgGA::GUIEventAdapter & arg0, ::osgGA::GUIActionAdapter & arg1 ){
        if( dynamic_cast< CameraManipulator_wrapper * >( boost::addressof( inst ) ) ){
            inst.::osgGA::CameraManipulator::home(arg0, arg1);
        }
        else{
            inst.home(arg0, arg1);
        }
    }

    virtual void home( double arg0 ) {
        namespace bpl = boost::python;
        if( bpl::override func_home = this->get_override( "home" ) ){
            bpl::object py_result = bpl::call<bpl::object>( func_home.ptr(), arg0 );
        }
        else{
            osgGA::CameraManipulator::home( arg0 );
        }
    }
    
    static void default_home_60d9f789ca14c44af8e13acc6b7f8b5f( ::osgGA::CameraManipulator & inst, double arg0 ){
        if( dynamic_cast< CameraManipulator_wrapper * >( boost::addressof( inst ) ) ){
            inst.::osgGA::CameraManipulator::home(arg0);
        }
        else{
            inst.home(arg0);
        }
    }

    virtual void init( ::osgGA::GUIEventAdapter const & arg0, ::osgGA::GUIActionAdapter & arg1 ) {
        namespace bpl = boost::python;
        if( bpl::override func_init = this->get_override( "init" ) ){
            bpl::object py_result = bpl::call<bpl::object>( func_init.ptr(), arg0, arg1 );
        }
        else{
            osgGA::CameraManipulator::init( boost::ref(arg0), boost::ref(arg1) );
        }
    }
    
    static void default_init( ::osgGA::CameraManipulator & inst, ::osgGA::GUIEventAdapter & arg0, ::osgGA::GUIActionAdapter & arg1 ){
        if( dynamic_cast< CameraManipulator_wrapper * >( boost::addressof( inst ) ) ){
            inst.::osgGA::CameraManipulator::init(arg0, arg1);
        }
        else{
            inst.init(arg0, arg1);
        }
    }

    virtual void setAutoComputeHomePosition( bool flag ) {
        if( bp::override func_setAutoComputeHomePosition = this->get_override( "setAutoComputeHomePosition" ) )
            func_setAutoComputeHomePosition( flag );
        else{
            this->osgGA::CameraManipulator::setAutoComputeHomePosition( flag );
        }
    }
    
    void default_setAutoComputeHomePosition( bool flag ) {
        osgGA::CameraManipulator::setAutoComputeHomePosition( flag );
    }

    virtual void setByInverseMatrix( ::osg::Matrixd const & matrix ){
        bp::override func_setByInverseMatrix = this->get_override( "setByInverseMatrix" );
        func_setByInverseMatrix( boost::ref(matrix) );
    }

    virtual void setByMatrix( ::osg::Matrixd const & matrix ){
        bp::override func_setByMatrix = this->get_override( "setByMatrix" );
        func_setByMatrix( boost::ref(matrix) );
    }

    virtual void setCoordinateFrameCallback( ::osgGA::CameraManipulator::CoordinateFrameCallback * cb ) {
        if( bp::override func_setCoordinateFrameCallback = this->get_override( "setCoordinateFrameCallback" ) )
            func_setCoordinateFrameCallback( boost::python::ptr(cb) );
        else{
            this->osgGA::CameraManipulator::setCoordinateFrameCallback( boost::python::ptr(cb) );
        }
    }
    
    void default_setCoordinateFrameCallback( ::osgGA::CameraManipulator::CoordinateFrameCallback * cb ) {
        osgGA::CameraManipulator::setCoordinateFrameCallback( boost::python::ptr(cb) );
    }

    virtual void setHomePosition( ::osg::Vec3d const & eye, ::osg::Vec3d const & center, ::osg::Vec3d const & up, bool autoComputeHomePosition=false ) {
        if( bp::override func_setHomePosition = this->get_override( "setHomePosition" ) )
            func_setHomePosition( boost::ref(eye), boost::ref(center), boost::ref(up), autoComputeHomePosition );
        else{
            this->osgGA::CameraManipulator::setHomePosition( boost::ref(eye), boost::ref(center), boost::ref(up), autoComputeHomePosition );
        }
    }
    
    void default_setHomePosition( ::osg::Vec3d const & eye, ::osg::Vec3d const & center, ::osg::Vec3d const & up, bool autoComputeHomePosition=false ) {
        osgGA::CameraManipulator::setHomePosition( boost::ref(eye), boost::ref(center), boost::ref(up), autoComputeHomePosition );
    }

    virtual void setNode( ::osg::Node * arg0 ) {
        if( bp::override func_setNode = this->get_override( "setNode" ) )
            func_setNode( boost::python::ptr(arg0) );
        else{
            this->osgGA::CameraManipulator::setNode( boost::python::ptr(arg0) );
        }
    }
    
    void default_setNode( ::osg::Node * arg0 ) {
        osgGA::CameraManipulator::setNode( boost::python::ptr(arg0) );
    }

    virtual void updateCamera( ::osg::Camera & camera ) {
        if( bp::override func_updateCamera = this->get_override( "updateCamera" ) )
            func_updateCamera( boost::ref(camera) );
        else{
            this->osgGA::CameraManipulator::updateCamera( boost::ref(camera) );
        }
    }
    
    void default_updateCamera( ::osg::Camera & camera ) {
        osgGA::CameraManipulator::updateCamera( boost::ref(camera) );
    }

    virtual ::osg::Object * clone( ::osg::CopyOp const & copyop ) const  {
        if( bp::override func_clone = this->get_override( "clone" ) )
            return func_clone( boost::ref(copyop) );
        else{
            return this->osgGA::GUIEventHandler::clone( boost::ref(copyop) );
        }
    }
    
    ::osg::Object * default_clone( ::osg::CopyOp const & copyop ) const  {
        return osgGA::GUIEventHandler::clone( boost::ref(copyop) );
    }

    virtual ::osg::Object * cloneType(  ) const  {
        if( bp::override func_cloneType = this->get_override( "cloneType" ) )
            return func_cloneType(  );
        else{
            return this->osgGA::GUIEventHandler::cloneType(  );
        }
    }
    
    ::osg::Object * default_cloneType(  ) const  {
        return osgGA::GUIEventHandler::cloneType( );
    }

    virtual void computeDataVariance(  ) {
        if( bp::override func_computeDataVariance = this->get_override( "computeDataVariance" ) )
            func_computeDataVariance(  );
        else{
            this->osg::Object::computeDataVariance(  );
        }
    }
    
    void default_computeDataVariance(  ) {
        osg::Object::computeDataVariance( );
    }

    virtual void event( ::osg::NodeVisitor * nv, ::osg::Drawable * drawable ) {
        if( bp::override func_event = this->get_override( "event" ) )
            func_event( boost::python::ptr(nv), boost::python::ptr(drawable) );
        else{
            this->osgGA::GUIEventHandler::event( boost::python::ptr(nv), boost::python::ptr(drawable) );
        }
    }
    
    void default_event( ::osg::NodeVisitor * nv, ::osg::Drawable * drawable ) {
        osgGA::GUIEventHandler::event( boost::python::ptr(nv), boost::python::ptr(drawable) );
    }

    virtual void getUsage( ::osg::ApplicationUsage & arg0 ) const  {
        if( bp::override func_getUsage = this->get_override( "getUsage" ) )
            func_getUsage( boost::ref(arg0) );
        else{
            this->osgGA::GUIEventHandler::getUsage( boost::ref(arg0) );
        }
    }
    
    void default_getUsage( ::osg::ApplicationUsage & arg0 ) const  {
        osgGA::GUIEventHandler::getUsage( boost::ref(arg0) );
    }

    virtual ::osg::Referenced * getUserData(  ) {
        if( bp::override func_getUserData = this->get_override( "getUserData" ) )
            return func_getUserData(  );
        else{
            return this->osg::Object::getUserData(  );
        }
    }
    
    ::osg::Referenced * default_getUserData(  ) {
        return osg::Object::getUserData( );
    }

    virtual ::osg::Referenced const * getUserData(  ) const  {
        if( bp::override func_getUserData = this->get_override( "getUserData" ) )
            return func_getUserData(  );
        else{
            return this->osg::Object::getUserData(  );
        }
    }
    
    ::osg::Referenced const * default_getUserData(  ) const  {
        return osg::Object::getUserData( );
    }

    virtual bool handle( ::osgGA::GUIEventAdapter const & ea, ::osgGA::GUIActionAdapter & aa, ::osg::Object * arg2, ::osg::NodeVisitor * arg3 ) {
        namespace bpl = boost::python;
        if( bpl::override func_handle = this->get_override( "handle" ) ){
            bpl::object py_result = bpl::call<bpl::object>( func_handle.ptr(), ea, aa, arg2, arg3 );
            return bpl::extract< bool >( pyplus_conv::get_out_argument( py_result, 0 ) );
        }
        else{
            return osgGA::GUIEventHandler::handle( boost::ref(ea), boost::ref(aa), boost::python::ptr(arg2), boost::python::ptr(arg3) );
        }
    }
    
    static boost::python::object default_handle_d0ba65b51c8a2afc5afff00aad1b91b3( ::osgGA::GUIEventHandler & inst, ::osgGA::GUIEventAdapter & ea, ::osgGA::GUIActionAdapter & aa, ::osg::Object * arg2, ::osg::NodeVisitor * arg3 ){
        bool result;
        if( dynamic_cast< CameraManipulator_wrapper * >( boost::addressof( inst ) ) ){
            result = inst.::osgGA::GUIEventHandler::handle(ea, aa, arg2, arg3);
        }
        else{
            result = inst.handle(ea, aa, arg2, arg3);
        }
        return bp::object( result );
    }

    virtual bool isSameKindAs( ::osg::Object const * obj ) const  {
        if( bp::override func_isSameKindAs = this->get_override( "isSameKindAs" ) )
            return func_isSameKindAs( boost::python::ptr(obj) );
        else{
            return this->osgGA::GUIEventHandler::isSameKindAs( boost::python::ptr(obj) );
        }
    }
    
    bool default_isSameKindAs( ::osg::Object const * obj ) const  {
        return osgGA::GUIEventHandler::isSameKindAs( boost::python::ptr(obj) );
    }

    virtual char const * libraryName(  ) const  {
        if( bp::override func_libraryName = this->get_override( "libraryName" ) )
            return func_libraryName(  );
        else{
            return this->osgGA::GUIEventHandler::libraryName(  );
        }
    }
    
    char const * default_libraryName(  ) const  {
        return osgGA::GUIEventHandler::libraryName( );
    }

    virtual void setName( ::std::string const & name ) {
        if( bp::override func_setName = this->get_override( "setName" ) )
            func_setName( name );
        else{
            this->osg::Object::setName( name );
        }
    }
    
    void default_setName( ::std::string const & name ) {
        osg::Object::setName( name );
    }

    virtual void setThreadSafeRefUnref( bool threadSafe ) {
        if( bp::override func_setThreadSafeRefUnref = this->get_override( "setThreadSafeRefUnref" ) )
            func_setThreadSafeRefUnref( threadSafe );
        else{
            this->osg::Object::setThreadSafeRefUnref( threadSafe );
        }
    }
    
    void default_setThreadSafeRefUnref( bool threadSafe ) {
        osg::Object::setThreadSafeRefUnref( threadSafe );
    }

    virtual void setUserData( ::osg::Referenced * obj ) {
        if( bp::override func_setUserData = this->get_override( "setUserData" ) )
            func_setUserData( boost::python::ptr(obj) );
        else{
            this->osg::Object::setUserData( boost::python::ptr(obj) );
        }
    }
    
    void default_setUserData( ::osg::Referenced * obj ) {
        osg::Object::setUserData( boost::python::ptr(obj) );
    }

};

void register_CameraManipulator_class(){

    { //::osgGA::CameraManipulator
        typedef bp::class_< CameraManipulator_wrapper, bp::bases< osgGA::GUIEventHandler >, osg::ref_ptr< CameraManipulator_wrapper >, boost::noncopyable > CameraManipulator_exposer_t;
        CameraManipulator_exposer_t CameraManipulator_exposer = CameraManipulator_exposer_t( "CameraManipulator", "\nCameraManipulator is an abstract base class defining the interface, and a certain\namount of default functionality, for classes which wish to control OSG cameras\nin response to GUI events.\n", bp::no_init );
        bp::scope CameraManipulator_scope( CameraManipulator_exposer );
        bp::class_< CameraManipulator_wrapper::CoordinateFrameCallback_wrapper, bp::bases< ::osg::Referenced >, osg::ref_ptr< CameraManipulator_wrapper::CoordinateFrameCallback_wrapper >, boost::noncopyable >( "CoordinateFrameCallback", "\n callback class to use to allow matrix manipulators to query the application for the local coordinate frame.\n", bp::no_init )    
            .def( 
                "getCoordinateFrame"
                , bp::pure_virtual( (::osg::CoordinateFrame ( ::osgGA::CameraManipulator::CoordinateFrameCallback::* )( ::osg::Vec3d const & ) const)(&::osgGA::CameraManipulator::CoordinateFrameCallback::getCoordinateFrame) )
                , ( bp::arg("position") )
                , "\n callback class to use to allow matrix manipulators to query the application for the local coordinate frame.\n" );
        { //::osgGA::CameraManipulator::className
        
            typedef char const * ( ::osgGA::CameraManipulator::*className_function_type )(  ) const;
            typedef char const * ( CameraManipulator_wrapper::*default_className_function_type )(  ) const;
            
            CameraManipulator_exposer.def( 
                "className"
                , className_function_type(&::osgGA::CameraManipulator::className)
                , default_className_function_type(&CameraManipulator_wrapper::default_className) );
        
        }
        { //::osgGA::CameraManipulator::computeHomePosition
        
            typedef void ( ::osgGA::CameraManipulator::*computeHomePosition_function_type )( ::osg::Camera const *,bool ) ;
            typedef void ( CameraManipulator_wrapper::*default_computeHomePosition_function_type )( ::osg::Camera const *,bool ) ;
            
            CameraManipulator_exposer.def( 
                "computeHomePosition"
                , computeHomePosition_function_type(&::osgGA::CameraManipulator::computeHomePosition)
                , default_computeHomePosition_function_type(&CameraManipulator_wrapper::default_computeHomePosition)
                , ( bp::arg("camera")=0l, bp::arg("useBoundingBox")=(bool)(false) ) );
        
        }
        { //::osgGA::CameraManipulator::getAutoComputeHomePosition
        
            typedef bool ( ::osgGA::CameraManipulator::*getAutoComputeHomePosition_function_type )(  ) const;
            
            CameraManipulator_exposer.def( 
                "getAutoComputeHomePosition"
                , getAutoComputeHomePosition_function_type( &::osgGA::CameraManipulator::getAutoComputeHomePosition )
                , " Get whether the automatic compute of the home position is enabled." );
        
        }
        { //::osgGA::CameraManipulator::getCoordinateFrame
        
            typedef ::osg::CoordinateFrame ( ::osgGA::CameraManipulator::*getCoordinateFrame_function_type )( ::osg::Vec3d const & ) const;
            
            CameraManipulator_exposer.def( 
                "getCoordinateFrame"
                , getCoordinateFrame_function_type( &::osgGA::CameraManipulator::getCoordinateFrame )
                , ( bp::arg("position") )
                , " get the coordinate frame." );
        
        }
        { //::osgGA::CameraManipulator::getCoordinateFrameCallback
        
            typedef ::osgGA::CameraManipulator::CoordinateFrameCallback * ( ::osgGA::CameraManipulator::*getCoordinateFrameCallback_function_type )(  ) ;
            
            CameraManipulator_exposer.def( 
                "getCoordinateFrameCallback"
                , getCoordinateFrameCallback_function_type( &::osgGA::CameraManipulator::getCoordinateFrameCallback )
                , bp::return_internal_reference< >()
                , " get the coordinate frame callback which tells the manipulator which way is up, east and north." );
        
        }
        { //::osgGA::CameraManipulator::getCoordinateFrameCallback
        
            typedef ::osgGA::CameraManipulator::CoordinateFrameCallback const * ( ::osgGA::CameraManipulator::*getCoordinateFrameCallback_function_type )(  ) const;
            
            CameraManipulator_exposer.def( 
                "getCoordinateFrameCallback"
                , getCoordinateFrameCallback_function_type( &::osgGA::CameraManipulator::getCoordinateFrameCallback )
                , bp::return_internal_reference< >()
                , " get the coordinate frame callback which tells the manipulator which way is up, east and north." );
        
        }
        { //::osgGA::CameraManipulator::getFrontVector
        
            typedef ::osg::Vec3d ( ::osgGA::CameraManipulator::*getFrontVector_function_type )( ::osg::CoordinateFrame const & ) const;
            
            CameraManipulator_exposer.def( 
                "getFrontVector"
                , getFrontVector_function_type( &::osgGA::CameraManipulator::getFrontVector )
                , ( bp::arg("cf") ) );
        
        }
        { //::osgGA::CameraManipulator::getFusionDistanceMode
        
            typedef ::osgUtil::SceneView::FusionDistanceMode ( ::osgGA::CameraManipulator::*getFusionDistanceMode_function_type )(  ) const;
            typedef ::osgUtil::SceneView::FusionDistanceMode ( CameraManipulator_wrapper::*default_getFusionDistanceMode_function_type )(  ) const;
            
            CameraManipulator_exposer.def( 
                "getFusionDistanceMode"
                , getFusionDistanceMode_function_type(&::osgGA::CameraManipulator::getFusionDistanceMode)
                , default_getFusionDistanceMode_function_type(&CameraManipulator_wrapper::default_getFusionDistanceMode) );
        
        }
        { //::osgGA::CameraManipulator::getFusionDistanceValue
        
            typedef float ( ::osgGA::CameraManipulator::*getFusionDistanceValue_function_type )(  ) const;
            typedef float ( CameraManipulator_wrapper::*default_getFusionDistanceValue_function_type )(  ) const;
            
            CameraManipulator_exposer.def( 
                "getFusionDistanceValue"
                , getFusionDistanceValue_function_type(&::osgGA::CameraManipulator::getFusionDistanceValue)
                , default_getFusionDistanceValue_function_type(&CameraManipulator_wrapper::default_getFusionDistanceValue) );
        
        }
        { //::osgGA::CameraManipulator::getHomePosition
        
            typedef void ( ::osgGA::CameraManipulator::*getHomePosition_function_type )( ::osg::Vec3d &,::osg::Vec3d &,::osg::Vec3d & ) const;
            typedef void ( CameraManipulator_wrapper::*default_getHomePosition_function_type )( ::osg::Vec3d &,::osg::Vec3d &,::osg::Vec3d & ) const;
            
            CameraManipulator_exposer.def( 
                "getHomePosition"
                , getHomePosition_function_type(&::osgGA::CameraManipulator::getHomePosition)
                , default_getHomePosition_function_type(&CameraManipulator_wrapper::default_getHomePosition)
                , ( bp::arg("eye"), bp::arg("center"), bp::arg("up") ) );
        
        }
        { //::osgGA::CameraManipulator::getIntersectTraversalMask
        
            typedef unsigned int ( ::osgGA::CameraManipulator::*getIntersectTraversalMask_function_type )(  ) const;
            
            CameraManipulator_exposer.def( 
                "getIntersectTraversalMask"
                , getIntersectTraversalMask_function_type( &::osgGA::CameraManipulator::getIntersectTraversalMask )
                , " Get the mask to use when set up intersection traversal such as used in manipulators that follow terrain or have collision detection." );
        
        }
        { //::osgGA::CameraManipulator::getInverseMatrix
        
            typedef ::osg::Matrixd ( ::osgGA::CameraManipulator::*getInverseMatrix_function_type )(  ) const;
            
            CameraManipulator_exposer.def( 
                "getInverseMatrix"
                , bp::pure_virtual( getInverseMatrix_function_type(&::osgGA::CameraManipulator::getInverseMatrix) )
                , "\n get the position of the manipulator as a inverse matrix of the manipulator, typically used as a model view matrix.\n" );
        
        }
        { //::osgGA::CameraManipulator::getMatrix
        
            typedef ::osg::Matrixd ( ::osgGA::CameraManipulator::*getMatrix_function_type )(  ) const;
            
            CameraManipulator_exposer.def( 
                "getMatrix"
                , bp::pure_virtual( getMatrix_function_type(&::osgGA::CameraManipulator::getMatrix) )
                , "\n get the position of the manipulator as 4x4 Matrix.\n" );
        
        }
        { //::osgGA::CameraManipulator::getNode
        
            typedef ::osg::Node const * ( ::osgGA::CameraManipulator::*getNode_function_type )(  ) const;
            typedef ::osg::Node const * ( CameraManipulator_wrapper::*default_getNode_function_type )(  ) const;
            
            CameraManipulator_exposer.def( 
                "getNode"
                , getNode_function_type(&::osgGA::CameraManipulator::getNode)
                , default_getNode_function_type(&CameraManipulator_wrapper::default_getNode)
                , bp::return_internal_reference< >() );
        
        }
        { //::osgGA::CameraManipulator::getNode
        
            typedef ::osg::Node * ( ::osgGA::CameraManipulator::*getNode_function_type )(  ) ;
            typedef ::osg::Node * ( CameraManipulator_wrapper::*default_getNode_function_type )(  ) ;
            
            CameraManipulator_exposer.def( 
                "getNode"
                , getNode_function_type(&::osgGA::CameraManipulator::getNode)
                , default_getNode_function_type(&CameraManipulator_wrapper::default_getNode)
                , bp::return_internal_reference< >() );
        
        }
        { //::osgGA::CameraManipulator::getSideVector
        
            typedef ::osg::Vec3d ( ::osgGA::CameraManipulator::*getSideVector_function_type )( ::osg::CoordinateFrame const & ) const;
            
            CameraManipulator_exposer.def( 
                "getSideVector"
                , getSideVector_function_type( &::osgGA::CameraManipulator::getSideVector )
                , ( bp::arg("cf") ) );
        
        }
        { //::osgGA::CameraManipulator::getUpVector
        
            typedef ::osg::Vec3d ( ::osgGA::CameraManipulator::*getUpVector_function_type )( ::osg::CoordinateFrame const & ) const;
            
            CameraManipulator_exposer.def( 
                "getUpVector"
                , getUpVector_function_type( &::osgGA::CameraManipulator::getUpVector )
                , ( bp::arg("cf") ) );
        
        }
        { //::osgGA::CameraManipulator::handle
        
            typedef boost::python::object ( *default_handle_function_type )( ::osgGA::CameraManipulator &,::osgGA::GUIEventAdapter &,::osgGA::GUIActionAdapter & );
            
            CameraManipulator_exposer.def( 
                "handle"
                , default_handle_function_type( &CameraManipulator_wrapper::default_handle )
                , ( bp::arg("inst"), bp::arg("ea"), bp::arg("us") )
                , "\n Handle events, return true if handled, false otherwise.\n" );
        
        }
        { //::osgGA::CameraManipulator::home
        
            typedef void ( *default_home_function_type )( ::osgGA::CameraManipulator &,::osgGA::GUIEventAdapter &,::osgGA::GUIActionAdapter & );
            
            CameraManipulator_exposer.def( 
                "home"
                , default_home_function_type( &CameraManipulator_wrapper::default_home_9715462911072744dcf4ae663764b018 )
                , ( bp::arg("inst"), bp::arg("arg0"), bp::arg("arg1") )
                , "\n        Move the camera to the default position.\n        May be ignored by manipulators if home functionality is not appropriate.\n" );
        
        }
        { //::osgGA::CameraManipulator::home
        
            typedef void ( *default_home_function_type )( ::osgGA::CameraManipulator &,double );
            
            CameraManipulator_exposer.def( 
                "home"
                , default_home_function_type( &CameraManipulator_wrapper::default_home_60d9f789ca14c44af8e13acc6b7f8b5f )
                , ( bp::arg("inst"), bp::arg("arg0") )
                , "\n        Move the camera to the default position.\n        This version does not require GUIEventAdapter and GUIActionAdapter so may be\n        called from somewhere other than a handle() method in GUIEventHandler.  Application\n        must be aware of implications.\n" );
        
        }
        { //::osgGA::CameraManipulator::init
        
            typedef void ( *default_init_function_type )( ::osgGA::CameraManipulator &,::osgGA::GUIEventAdapter &,::osgGA::GUIActionAdapter & );
            
            CameraManipulator_exposer.def( 
                "init"
                , default_init_function_type( &CameraManipulator_wrapper::default_init )
                , ( bp::arg("inst"), bp::arg("arg0"), bp::arg("arg1") )
                , "\n        Start/restart the manipulator.\n        FIXME: what does this actually mean? Provide examples.\n" );
        
        }
        { //::osgGA::CameraManipulator::setAutoComputeHomePosition
        
            typedef void ( ::osgGA::CameraManipulator::*setAutoComputeHomePosition_function_type )( bool ) ;
            typedef void ( CameraManipulator_wrapper::*default_setAutoComputeHomePosition_function_type )( bool ) ;
            
            CameraManipulator_exposer.def( 
                "setAutoComputeHomePosition"
                , setAutoComputeHomePosition_function_type(&::osgGA::CameraManipulator::setAutoComputeHomePosition)
                , default_setAutoComputeHomePosition_function_type(&CameraManipulator_wrapper::default_setAutoComputeHomePosition)
                , ( bp::arg("flag") ) );
        
        }
        { //::osgGA::CameraManipulator::setByInverseMatrix
        
            typedef void ( ::osgGA::CameraManipulator::*setByInverseMatrix_function_type )( ::osg::Matrixd const & ) ;
            
            CameraManipulator_exposer.def( 
                "setByInverseMatrix"
                , bp::pure_virtual( setByInverseMatrix_function_type(&::osgGA::CameraManipulator::setByInverseMatrix) )
                , ( bp::arg("matrix") )
                , "\n set the position of the matrix manipulator using a 4x4 Matrix.\n" );
        
        }
        { //::osgGA::CameraManipulator::setByMatrix
        
            typedef void ( ::osgGA::CameraManipulator::*setByMatrix_function_type )( ::osg::Matrixd const & ) ;
            
            CameraManipulator_exposer.def( 
                "setByMatrix"
                , bp::pure_virtual( setByMatrix_function_type(&::osgGA::CameraManipulator::setByMatrix) )
                , ( bp::arg("matrix") )
                , "\n set the position of the matrix manipulator using a 4x4 Matrix.\n" );
        
        }
        { //::osgGA::CameraManipulator::setCoordinateFrameCallback
        
            typedef void ( ::osgGA::CameraManipulator::*setCoordinateFrameCallback_function_type )( ::osgGA::CameraManipulator::CoordinateFrameCallback * ) ;
            typedef void ( CameraManipulator_wrapper::*default_setCoordinateFrameCallback_function_type )( ::osgGA::CameraManipulator::CoordinateFrameCallback * ) ;
            
            CameraManipulator_exposer.def( 
                "setCoordinateFrameCallback"
                , setCoordinateFrameCallback_function_type(&::osgGA::CameraManipulator::setCoordinateFrameCallback)
                , default_setCoordinateFrameCallback_function_type(&CameraManipulator_wrapper::default_setCoordinateFrameCallback)
                , ( bp::arg("cb") ) );
        
        }
        { //::osgGA::CameraManipulator::setHomePosition
        
            typedef void ( ::osgGA::CameraManipulator::*setHomePosition_function_type )( ::osg::Vec3d const &,::osg::Vec3d const &,::osg::Vec3d const &,bool ) ;
            typedef void ( CameraManipulator_wrapper::*default_setHomePosition_function_type )( ::osg::Vec3d const &,::osg::Vec3d const &,::osg::Vec3d const &,bool ) ;
            
            CameraManipulator_exposer.def( 
                "setHomePosition"
                , setHomePosition_function_type(&::osgGA::CameraManipulator::setHomePosition)
                , default_setHomePosition_function_type(&CameraManipulator_wrapper::default_setHomePosition)
                , ( bp::arg("eye"), bp::arg("center"), bp::arg("up"), bp::arg("autoComputeHomePosition")=(bool)(false) ) );
        
        }
        { //::osgGA::CameraManipulator::setIntersectTraversalMask
        
            typedef void ( ::osgGA::CameraManipulator::*setIntersectTraversalMask_function_type )( unsigned int ) ;
            
            CameraManipulator_exposer.def( 
                "setIntersectTraversalMask"
                , setIntersectTraversalMask_function_type( &::osgGA::CameraManipulator::setIntersectTraversalMask )
                , ( bp::arg("mask") )
                , " Set the mask to use when set up intersection traversal such as used in manipulators that follow terrain or have collision detection.\n The intersection traversal mask is useful for controlling what parts of the scene graph should be used for intersection purposes." );
        
        }
        { //::osgGA::CameraManipulator::setNode
        
            typedef void ( ::osgGA::CameraManipulator::*setNode_function_type )( ::osg::Node * ) ;
            typedef void ( CameraManipulator_wrapper::*default_setNode_function_type )( ::osg::Node * ) ;
            
            CameraManipulator_exposer.def( 
                "setNode"
                , setNode_function_type(&::osgGA::CameraManipulator::setNode)
                , default_setNode_function_type(&CameraManipulator_wrapper::default_setNode)
                , ( bp::arg("arg0") ) );
        
        }
        { //::osgGA::CameraManipulator::updateCamera
        
            typedef void ( ::osgGA::CameraManipulator::*updateCamera_function_type )( ::osg::Camera & ) ;
            typedef void ( CameraManipulator_wrapper::*default_updateCamera_function_type )( ::osg::Camera & ) ;
            
            CameraManipulator_exposer.def( 
                "updateCamera"
                , updateCamera_function_type(&::osgGA::CameraManipulator::updateCamera)
                , default_updateCamera_function_type(&CameraManipulator_wrapper::default_updateCamera)
                , ( bp::arg("camera") ) );
        
        }
        { //::osgGA::GUIEventHandler::clone
        
            typedef ::osg::Object * ( ::osgGA::GUIEventHandler::*clone_function_type )( ::osg::CopyOp const & ) const;
            typedef ::osg::Object * ( CameraManipulator_wrapper::*default_clone_function_type )( ::osg::CopyOp const & ) const;
            
            CameraManipulator_exposer.def( 
                "clone"
                , clone_function_type(&::osgGA::GUIEventHandler::clone)
                , default_clone_function_type(&CameraManipulator_wrapper::default_clone)
                , ( bp::arg("copyop") )
                , bp::return_value_policy< bp::reference_existing_object >() );
        
        }
        { //::osgGA::GUIEventHandler::cloneType
        
            typedef ::osg::Object * ( ::osgGA::GUIEventHandler::*cloneType_function_type )(  ) const;
            typedef ::osg::Object * ( CameraManipulator_wrapper::*default_cloneType_function_type )(  ) const;
            
            CameraManipulator_exposer.def( 
                "cloneType"
                , cloneType_function_type(&::osgGA::GUIEventHandler::cloneType)
                , default_cloneType_function_type(&CameraManipulator_wrapper::default_cloneType)
                , bp::return_value_policy< bp::reference_existing_object >() );
        
        }
        { //::osgGA::GUIEventHandler::event
        
            typedef void ( ::osgGA::GUIEventHandler::*event_function_type )( ::osg::NodeVisitor *,::osg::Drawable * ) ;
            typedef void ( CameraManipulator_wrapper::*default_event_function_type )( ::osg::NodeVisitor *,::osg::Drawable * ) ;
            
            CameraManipulator_exposer.def( 
                "event"
                , event_function_type(&::osgGA::GUIEventHandler::event)
                , default_event_function_type(&CameraManipulator_wrapper::default_event)
                , ( bp::arg("nv"), bp::arg("drawable") ) );
        
        }
        { //::osgGA::GUIEventHandler::getUsage
        
            typedef void ( ::osgGA::GUIEventHandler::*getUsage_function_type )( ::osg::ApplicationUsage & ) const;
            typedef void ( CameraManipulator_wrapper::*default_getUsage_function_type )( ::osg::ApplicationUsage & ) const;
            
            CameraManipulator_exposer.def( 
                "getUsage"
                , getUsage_function_type(&::osgGA::GUIEventHandler::getUsage)
                , default_getUsage_function_type(&CameraManipulator_wrapper::default_getUsage)
                , ( bp::arg("arg0") ) );
        
        }
        { //::osgGA::GUIEventHandler::handle
        
            typedef boost::python::object ( *default_handle_function_type )( ::osgGA::GUIEventHandler &,::osgGA::GUIEventAdapter &,::osgGA::GUIActionAdapter &,::osg::Object *,::osg::NodeVisitor * );
            
            CameraManipulator_exposer.def( 
                "handle"
                , default_handle_function_type( &CameraManipulator_wrapper::default_handle_d0ba65b51c8a2afc5afff00aad1b91b3 )
                , ( bp::arg("inst"), bp::arg("ea"), bp::arg("aa"), bp::arg("arg2"), bp::arg("arg3") )
                , "\n Handle events, return true if handled, false otherwise.\n" );
        
        }
        { //::osgGA::GUIEventHandler::isSameKindAs
        
            typedef bool ( ::osgGA::GUIEventHandler::*isSameKindAs_function_type )( ::osg::Object const * ) const;
            typedef bool ( CameraManipulator_wrapper::*default_isSameKindAs_function_type )( ::osg::Object const * ) const;
            
            CameraManipulator_exposer.def( 
                "isSameKindAs"
                , isSameKindAs_function_type(&::osgGA::GUIEventHandler::isSameKindAs)
                , default_isSameKindAs_function_type(&CameraManipulator_wrapper::default_isSameKindAs)
                , ( bp::arg("obj") ) );
        
        }
        { //::osgGA::GUIEventHandler::libraryName
        
            typedef char const * ( ::osgGA::GUIEventHandler::*libraryName_function_type )(  ) const;
            typedef char const * ( CameraManipulator_wrapper::*default_libraryName_function_type )(  ) const;
            
            CameraManipulator_exposer.def( 
                "libraryName"
                , libraryName_function_type(&::osgGA::GUIEventHandler::libraryName)
                , default_libraryName_function_type(&CameraManipulator_wrapper::default_libraryName) );
        
        }
    }

}
