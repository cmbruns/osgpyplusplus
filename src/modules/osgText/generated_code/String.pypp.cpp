// This file has been generated by Py++.

#include "boost/python.hpp"
#include "wrap_osgText.h"
#include "String.pypp.hpp"

namespace bp = boost::python;

void register_String_class(){

    { //::osgText::String
        typedef bp::class_< osgText::String, bp::bases< osgText::VectorUInt > > String_exposer_t;
        String_exposer_t String_exposer = String_exposer_t( "String", bp::init< >() );
        bp::scope String_scope( String_exposer );
        bp::enum_< osgText::String::Encoding>("Encoding")
            .value("ENCODING_UNDEFINED", osgText::String::ENCODING_UNDEFINED)
            .value("ENCODING_ASCII", osgText::String::ENCODING_ASCII)
            .value("ENCODING_UTF8", osgText::String::ENCODING_UTF8)
            .value("ENCODING_UTF16", osgText::String::ENCODING_UTF16)
            .value("ENCODING_UTF16_BE", osgText::String::ENCODING_UTF16_BE)
            .value("ENCODING_UTF16_LE", osgText::String::ENCODING_UTF16_LE)
            .value("ENCODING_UTF32", osgText::String::ENCODING_UTF32)
            .value("ENCODING_UTF32_BE", osgText::String::ENCODING_UTF32_BE)
            .value("ENCODING_UTF32_LE", osgText::String::ENCODING_UTF32_LE)
            .value("ENCODING_SIGNATURE", osgText::String::ENCODING_SIGNATURE)
            .export_values()
            ;
        String_exposer.def( bp::init< osgText::String const & >(( bp::arg("str") )) );
        String_exposer.def( bp::init< std::string const & >(( bp::arg("str") )) );
        bp::implicitly_convertible< std::string const &, osgText::String >();
        String_exposer.def( bp::init< wchar_t const * >(( bp::arg("text") )) );
        bp::implicitly_convertible< wchar_t const *, osgText::String >();
        String_exposer.def( bp::init< std::string const &, osgText::String::Encoding >(( bp::arg("text"), bp::arg("encoding") )) );
        { //::osgText::String::createUTF8EncodedString
        
            typedef ::std::string ( ::osgText::String::*createUTF8EncodedString_function_type )(  ) const;
            
            String_exposer.def( 
                "createUTF8EncodedString"
                , createUTF8EncodedString_function_type( &::osgText::String::createUTF8EncodedString )
                , "\n returns a UTF8 encoded version of this osgText::String.\n" );
        
        }
        { //::osgText::String::operator=
        
            typedef ::osgText::String & ( ::osgText::String::*assign_function_type )( ::osgText::String const & ) ;
            
            String_exposer.def( 
                "assign"
                , assign_function_type( &::osgText::String::operator= )
                , ( bp::arg("str") )
                , bp::return_self< >() );
        
        }
        { //::osgText::String::set
        
            typedef void ( ::osgText::String::*set_function_type )( ::std::string const & ) ;
            
            String_exposer.def( 
                "set"
                , set_function_type( &::osgText::String::set )
                , ( bp::arg("str") ) );
        
        }
        { //::osgText::String::set
        
            typedef void ( ::osgText::String::*set_function_type )( wchar_t const * ) ;
            
            String_exposer.def( 
                "set"
                , set_function_type( &::osgText::String::set )
                , ( bp::arg("text") )
                , "\n Set the text using a wchar_t string,\n which is converted to an internal TextString.\n" );
        
        }
        { //::osgText::String::set
        
            typedef void ( ::osgText::String::*set_function_type )( ::std::string const &,::osgText::String::Encoding ) ;
            
            String_exposer.def( 
                "set"
                , set_function_type( &::osgText::String::set )
                , ( bp::arg("text"), bp::arg("encoding") )
                , "\n Set the text using a Unicode encoded std::string, which is converted to an internal TextString.\n The encoding parameter specifies which Unicode encoding is used in the std::string.\n" );
        
        }
    }

}
