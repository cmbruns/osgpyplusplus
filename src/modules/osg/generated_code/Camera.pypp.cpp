// This file has been generated by Py++.

#include "boost/python.hpp"
#include "__call_policies.pypp.hpp"
#include "__convenience.pypp.hpp"
#include "wrap_osg.h"
#include "wrap_referenced.h"
#include "Camera.pypp.hpp"

namespace bp = boost::python;

struct Camera_wrapper : osg::Camera, bp::wrapper< osg::Camera > {

    struct DrawCallback_wrapper : osg::Camera::DrawCallback, bp::wrapper< osg::Camera::DrawCallback > {
    
        DrawCallback_wrapper( )
        : osg::Camera::DrawCallback( )
          , bp::wrapper< osg::Camera::DrawCallback >(){
            // null constructor
        
        }
    
        virtual char const * className(  ) const  {
            if( bp::override func_className = this->get_override( "className" ) )
                return func_className(  );
            else{
                return this->osg::Camera::DrawCallback::className(  );
            }
        }
        
        char const * default_className(  ) const  {
            return osg::Camera::DrawCallback::className( );
        }
    
        virtual ::osg::Object * clone( ::osg::CopyOp const & copyop ) const  {
            if( bp::override func_clone = this->get_override( "clone" ) )
                return func_clone( boost::ref(copyop) );
            else{
                return this->osg::Camera::DrawCallback::clone( boost::ref(copyop) );
            }
        }
        
        ::osg::Object * default_clone( ::osg::CopyOp const & copyop ) const  {
            return osg::Camera::DrawCallback::clone( boost::ref(copyop) );
        }
    
        virtual ::osg::Object * cloneType(  ) const  {
            if( bp::override func_cloneType = this->get_override( "cloneType" ) )
                return func_cloneType(  );
            else{
                return this->osg::Camera::DrawCallback::cloneType(  );
            }
        }
        
        ::osg::Object * default_cloneType(  ) const  {
            return osg::Camera::DrawCallback::cloneType( );
        }
    
        virtual bool isSameKindAs( ::osg::Object const * obj ) const  {
            if( bp::override func_isSameKindAs = this->get_override( "isSameKindAs" ) )
                return func_isSameKindAs( boost::python::ptr(obj) );
            else{
                return this->osg::Camera::DrawCallback::isSameKindAs( boost::python::ptr(obj) );
            }
        }
        
        bool default_isSameKindAs( ::osg::Object const * obj ) const  {
            return osg::Camera::DrawCallback::isSameKindAs( boost::python::ptr(obj) );
        }
    
        virtual char const * libraryName(  ) const  {
            if( bp::override func_libraryName = this->get_override( "libraryName" ) )
                return func_libraryName(  );
            else{
                return this->osg::Camera::DrawCallback::libraryName(  );
            }
        }
        
        char const * default_libraryName(  ) const  {
            return osg::Camera::DrawCallback::libraryName( );
        }
    
        virtual void operator()( ::osg::RenderInfo & renderInfo ) const  {
            if( bp::override func___call__ = this->get_override( "__call__" ) )
                func___call__( boost::ref(renderInfo) );
            else{
                this->osg::Camera::DrawCallback::operator()( boost::ref(renderInfo) );
            }
        }
        
        void default___call__( ::osg::RenderInfo & renderInfo ) const  {
            osg::Camera::DrawCallback::operator()( boost::ref(renderInfo) );
        }
    
        virtual void operator()( ::osg::Camera const & arg0 ) const  {
            namespace bpl = boost::python;
            if( bpl::override func___call__ = this->get_override( "__call__" ) ){
                bpl::object py_result = bpl::call<bpl::object>( func___call__.ptr(), arg0 );
            }
            else{
                osg::Camera::DrawCallback::operator()( boost::ref(arg0) );
            }
        }
        
        static void default_operator_call_8900c52bc7561d9994aad91cb1cd0699( ::osg::Camera::DrawCallback const & inst, ::osg::Camera & arg0 ){
            if( dynamic_cast< DrawCallback_wrapper const* >( boost::addressof( inst ) ) ){
                inst.::osg::Camera::DrawCallback::operator()(arg0);
            }
            else{
                inst.operator()(arg0);
            }
        }
    
    };

    Camera_wrapper( )
    : osg::Camera( )
      , bp::wrapper< osg::Camera >(){
        // null constructor
    
    }

    virtual void accept( ::osg::NodeVisitor & nv ) {
        if( bp::override func_accept = this->get_override( "accept" ) )
            func_accept( boost::ref(nv) );
        else{
            this->osg::Camera::accept( boost::ref(nv) );
        }
    }
    
    void default_accept( ::osg::NodeVisitor & nv ) {
        osg::Camera::accept( boost::ref(nv) );
    }

    virtual ::osg::Camera * asCamera(  ) {
        if( bp::override func_asCamera = this->get_override( "asCamera" ) )
            return func_asCamera(  );
        else{
            return this->osg::Camera::asCamera(  );
        }
    }
    
    ::osg::Camera * default_asCamera(  ) {
        return osg::Camera::asCamera( );
    }

    virtual ::osg::Camera const * asCamera(  ) const  {
        if( bp::override func_asCamera = this->get_override( "asCamera" ) )
            return func_asCamera(  );
        else{
            return this->osg::Camera::asCamera(  );
        }
    }
    
    ::osg::Camera const * default_asCamera(  ) const  {
        return osg::Camera::asCamera( );
    }

    virtual char const * className(  ) const  {
        if( bp::override func_className = this->get_override( "className" ) )
            return func_className(  );
        else{
            return this->osg::Camera::className(  );
        }
    }
    
    char const * default_className(  ) const  {
        return osg::Camera::className( );
    }

    virtual ::osg::Object * clone( ::osg::CopyOp const & copyop ) const  {
        if( bp::override func_clone = this->get_override( "clone" ) )
            return func_clone( boost::ref(copyop) );
        else{
            return this->osg::Camera::clone( boost::ref(copyop) );
        }
    }
    
    ::osg::Object * default_clone( ::osg::CopyOp const & copyop ) const  {
        return osg::Camera::clone( boost::ref(copyop) );
    }

    virtual ::osg::Object * cloneType(  ) const  {
        if( bp::override func_cloneType = this->get_override( "cloneType" ) )
            return func_cloneType(  );
        else{
            return this->osg::Camera::cloneType(  );
        }
    }
    
    ::osg::Object * default_cloneType(  ) const  {
        return osg::Camera::cloneType( );
    }

    virtual bool computeLocalToWorldMatrix( ::osg::Matrix & matrix, ::osg::NodeVisitor * arg1 ) const  {
        if( bp::override func_computeLocalToWorldMatrix = this->get_override( "computeLocalToWorldMatrix" ) )
            return func_computeLocalToWorldMatrix( boost::ref(matrix), boost::python::ptr(arg1) );
        else{
            return this->osg::Camera::computeLocalToWorldMatrix( boost::ref(matrix), boost::python::ptr(arg1) );
        }
    }
    
    bool default_computeLocalToWorldMatrix( ::osg::Matrix & matrix, ::osg::NodeVisitor * arg1 ) const  {
        return osg::Camera::computeLocalToWorldMatrix( boost::ref(matrix), boost::python::ptr(arg1) );
    }

    virtual bool computeWorldToLocalMatrix( ::osg::Matrix & matrix, ::osg::NodeVisitor * arg1 ) const  {
        if( bp::override func_computeWorldToLocalMatrix = this->get_override( "computeWorldToLocalMatrix" ) )
            return func_computeWorldToLocalMatrix( boost::ref(matrix), boost::python::ptr(arg1) );
        else{
            return this->osg::Camera::computeWorldToLocalMatrix( boost::ref(matrix), boost::python::ptr(arg1) );
        }
    }
    
    bool default_computeWorldToLocalMatrix( ::osg::Matrix & matrix, ::osg::NodeVisitor * arg1 ) const  {
        return osg::Camera::computeWorldToLocalMatrix( boost::ref(matrix), boost::python::ptr(arg1) );
    }

    virtual void inheritCullSettings( ::osg::CullSettings const & settings, unsigned int inheritanceMask ) {
        if( bp::override func_inheritCullSettings = this->get_override( "inheritCullSettings" ) )
            func_inheritCullSettings( boost::ref(settings), inheritanceMask );
        else{
            this->osg::Camera::inheritCullSettings( boost::ref(settings), inheritanceMask );
        }
    }
    
    void default_inheritCullSettings( ::osg::CullSettings const & settings, unsigned int inheritanceMask ) {
        osg::Camera::inheritCullSettings( boost::ref(settings), inheritanceMask );
    }

    virtual bool isSameKindAs( ::osg::Object const * obj ) const  {
        if( bp::override func_isSameKindAs = this->get_override( "isSameKindAs" ) )
            return func_isSameKindAs( boost::python::ptr(obj) );
        else{
            return this->osg::Camera::isSameKindAs( boost::python::ptr(obj) );
        }
    }
    
    bool default_isSameKindAs( ::osg::Object const * obj ) const  {
        return osg::Camera::isSameKindAs( boost::python::ptr(obj) );
    }

    virtual char const * libraryName(  ) const  {
        if( bp::override func_libraryName = this->get_override( "libraryName" ) )
            return func_libraryName(  );
        else{
            return this->osg::Camera::libraryName(  );
        }
    }
    
    char const * default_libraryName(  ) const  {
        return osg::Camera::libraryName( );
    }

    virtual void resizeGLObjectBuffers( unsigned int maxSize ) {
        if( bp::override func_resizeGLObjectBuffers = this->get_override( "resizeGLObjectBuffers" ) )
            func_resizeGLObjectBuffers( maxSize );
        else{
            this->osg::Camera::resizeGLObjectBuffers( maxSize );
        }
    }
    
    void default_resizeGLObjectBuffers( unsigned int maxSize ) {
        osg::Camera::resizeGLObjectBuffers( maxSize );
    }

    virtual bool addChild( ::osg::Node * child ) {
        if( bp::override func_addChild = this->get_override( "addChild" ) )
            return func_addChild( boost::python::ptr(child) );
        else{
            return this->osg::Group::addChild( boost::python::ptr(child) );
        }
    }
    
    bool default_addChild( ::osg::Node * child ) {
        return osg::Group::addChild( boost::python::ptr(child) );
    }

    virtual ::osg::Geode * asGeode(  ) {
        if( bp::override func_asGeode = this->get_override( "asGeode" ) )
            return func_asGeode(  );
        else{
            return this->osg::Node::asGeode(  );
        }
    }
    
    ::osg::Geode * default_asGeode(  ) {
        return osg::Node::asGeode( );
    }

    virtual ::osg::Geode const * asGeode(  ) const  {
        if( bp::override func_asGeode = this->get_override( "asGeode" ) )
            return func_asGeode(  );
        else{
            return this->osg::Node::asGeode(  );
        }
    }
    
    ::osg::Geode const * default_asGeode(  ) const  {
        return osg::Node::asGeode( );
    }

    virtual ::osg::Group * asGroup(  ) {
        if( bp::override func_asGroup = this->get_override( "asGroup" ) )
            return func_asGroup(  );
        else{
            return this->osg::Group::asGroup(  );
        }
    }
    
    ::osg::Group * default_asGroup(  ) {
        return osg::Group::asGroup( );
    }

    virtual ::osg::Group const * asGroup(  ) const  {
        if( bp::override func_asGroup = this->get_override( "asGroup" ) )
            return func_asGroup(  );
        else{
            return this->osg::Group::asGroup(  );
        }
    }
    
    ::osg::Group const * default_asGroup(  ) const  {
        return osg::Group::asGroup( );
    }

    virtual ::osg::MatrixTransform * asMatrixTransform(  ) {
        if( bp::override func_asMatrixTransform = this->get_override( "asMatrixTransform" ) )
            return func_asMatrixTransform(  );
        else{
            return this->osg::Transform::asMatrixTransform(  );
        }
    }
    
    ::osg::MatrixTransform * default_asMatrixTransform(  ) {
        return osg::Transform::asMatrixTransform( );
    }

    virtual ::osg::MatrixTransform const * asMatrixTransform(  ) const  {
        if( bp::override func_asMatrixTransform = this->get_override( "asMatrixTransform" ) )
            return func_asMatrixTransform(  );
        else{
            return this->osg::Transform::asMatrixTransform(  );
        }
    }
    
    ::osg::MatrixTransform const * default_asMatrixTransform(  ) const  {
        return osg::Transform::asMatrixTransform( );
    }

    virtual ::osg::PositionAttitudeTransform * asPositionAttitudeTransform(  ) {
        if( bp::override func_asPositionAttitudeTransform = this->get_override( "asPositionAttitudeTransform" ) )
            return func_asPositionAttitudeTransform(  );
        else{
            return this->osg::Transform::asPositionAttitudeTransform(  );
        }
    }
    
    ::osg::PositionAttitudeTransform * default_asPositionAttitudeTransform(  ) {
        return osg::Transform::asPositionAttitudeTransform( );
    }

    virtual ::osg::PositionAttitudeTransform const * asPositionAttitudeTransform(  ) const  {
        if( bp::override func_asPositionAttitudeTransform = this->get_override( "asPositionAttitudeTransform" ) )
            return func_asPositionAttitudeTransform(  );
        else{
            return this->osg::Transform::asPositionAttitudeTransform(  );
        }
    }
    
    ::osg::PositionAttitudeTransform const * default_asPositionAttitudeTransform(  ) const  {
        return osg::Transform::asPositionAttitudeTransform( );
    }

    virtual ::osg::Switch * asSwitch(  ) {
        if( bp::override func_asSwitch = this->get_override( "asSwitch" ) )
            return func_asSwitch(  );
        else{
            return this->osg::Node::asSwitch(  );
        }
    }
    
    ::osg::Switch * default_asSwitch(  ) {
        return osg::Node::asSwitch( );
    }

    virtual ::osg::Switch const * asSwitch(  ) const  {
        if( bp::override func_asSwitch = this->get_override( "asSwitch" ) )
            return func_asSwitch(  );
        else{
            return this->osg::Node::asSwitch(  );
        }
    }
    
    ::osg::Switch const * default_asSwitch(  ) const  {
        return osg::Node::asSwitch( );
    }

    virtual ::osg::Transform * asTransform(  ) {
        if( bp::override func_asTransform = this->get_override( "asTransform" ) )
            return func_asTransform(  );
        else{
            return this->osg::Transform::asTransform(  );
        }
    }
    
    ::osg::Transform * default_asTransform(  ) {
        return osg::Transform::asTransform( );
    }

    virtual ::osg::Transform const * asTransform(  ) const  {
        if( bp::override func_asTransform = this->get_override( "asTransform" ) )
            return func_asTransform(  );
        else{
            return this->osg::Transform::asTransform(  );
        }
    }
    
    ::osg::Transform const * default_asTransform(  ) const  {
        return osg::Transform::asTransform( );
    }

    virtual void ascend( ::osg::NodeVisitor & nv ) {
        if( bp::override func_ascend = this->get_override( "ascend" ) )
            func_ascend( boost::ref(nv) );
        else{
            this->osg::Node::ascend( boost::ref(nv) );
        }
    }
    
    void default_ascend( ::osg::NodeVisitor & nv ) {
        osg::Node::ascend( boost::ref(nv) );
    }

    virtual ::osg::BoundingSphere computeBound(  ) const  {
        if( bp::override func_computeBound = this->get_override( "computeBound" ) )
            return func_computeBound(  );
        else{
            return this->osg::Transform::computeBound(  );
        }
    }
    
    ::osg::BoundingSphere default_computeBound(  ) const  {
        return osg::Transform::computeBound( );
    }

    virtual void inheritCullSettings( ::osg::CullSettings const & settings ) {
        if( bp::override func_inheritCullSettings = this->get_override( "inheritCullSettings" ) )
            func_inheritCullSettings( boost::ref(settings) );
        else{
            this->osg::CullSettings::inheritCullSettings( boost::ref(settings) );
        }
    }
    
    void default_inheritCullSettings( ::osg::CullSettings const & settings ) {
        osg::CullSettings::inheritCullSettings( boost::ref(settings) );
    }

    virtual bool insertChild( unsigned int index, ::osg::Node * child ) {
        if( bp::override func_insertChild = this->get_override( "insertChild" ) )
            return func_insertChild( index, boost::python::ptr(child) );
        else{
            return this->osg::Group::insertChild( index, boost::python::ptr(child) );
        }
    }
    
    bool default_insertChild( unsigned int index, ::osg::Node * child ) {
        return osg::Group::insertChild( index, boost::python::ptr(child) );
    }

    virtual bool removeChildren( unsigned int pos, unsigned int numChildrenToRemove ) {
        if( bp::override func_removeChildren = this->get_override( "removeChildren" ) )
            return func_removeChildren( pos, numChildrenToRemove );
        else{
            return this->osg::Group::removeChildren( pos, numChildrenToRemove );
        }
    }
    
    bool default_removeChildren( unsigned int pos, unsigned int numChildrenToRemove ) {
        return osg::Group::removeChildren( pos, numChildrenToRemove );
    }

    virtual bool replaceChild( ::osg::Node * origChild, ::osg::Node * newChild ) {
        if( bp::override func_replaceChild = this->get_override( "replaceChild" ) )
            return func_replaceChild( boost::python::ptr(origChild), boost::python::ptr(newChild) );
        else{
            return this->osg::Group::replaceChild( boost::python::ptr(origChild), boost::python::ptr(newChild) );
        }
    }
    
    bool default_replaceChild( ::osg::Node * origChild, ::osg::Node * newChild ) {
        return osg::Group::replaceChild( boost::python::ptr(origChild), boost::python::ptr(newChild) );
    }

    virtual bool setChild( unsigned int i, ::osg::Node * node ) {
        if( bp::override func_setChild = this->get_override( "setChild" ) )
            return func_setChild( i, boost::python::ptr(node) );
        else{
            return this->osg::Group::setChild( i, boost::python::ptr(node) );
        }
    }
    
    bool default_setChild( unsigned int i, ::osg::Node * node ) {
        return osg::Group::setChild( i, boost::python::ptr(node) );
    }

    virtual void setDefaults(  ) {
        if( bp::override func_setDefaults = this->get_override( "setDefaults" ) )
            func_setDefaults(  );
        else{
            this->osg::CullSettings::setDefaults(  );
        }
    }
    
    void default_setDefaults(  ) {
        osg::CullSettings::setDefaults( );
    }

    virtual void setThreadSafeRefUnref( bool threadSafe ) {
        if( bp::override func_setThreadSafeRefUnref = this->get_override( "setThreadSafeRefUnref" ) )
            func_setThreadSafeRefUnref( threadSafe );
        else{
            this->osg::Group::setThreadSafeRefUnref( threadSafe );
        }
    }
    
    void default_setThreadSafeRefUnref( bool threadSafe ) {
        osg::Group::setThreadSafeRefUnref( threadSafe );
    }

    virtual void traverse( ::osg::NodeVisitor & nv ) {
        if( bp::override func_traverse = this->get_override( "traverse" ) )
            func_traverse( boost::ref(nv) );
        else{
            this->osg::Group::traverse( boost::ref(nv) );
        }
    }
    
    void default_traverse( ::osg::NodeVisitor & nv ) {
        osg::Group::traverse( boost::ref(nv) );
    }

};

void register_Camera_class(){

    { //::osg::Camera
        typedef bp::class_< Camera_wrapper, bp::bases< osg::Transform, osg::CullSettings >, osg::ref_ptr< ::osg::Camera >, boost::noncopyable > Camera_exposer_t;
        Camera_exposer_t Camera_exposer = Camera_exposer_t( "Camera", "\n Camera - is a subclass of Transform which represents encapsulates the settings of a Camera.\n", bp::no_init );
        bp::scope Camera_scope( Camera_exposer );
        bp::enum_< osg::Camera::BufferComponent>("BufferComponent")
            .value("DEPTH_BUFFER", osg::Camera::DEPTH_BUFFER)
            .value("STENCIL_BUFFER", osg::Camera::STENCIL_BUFFER)
            .value("PACKED_DEPTH_STENCIL_BUFFER", osg::Camera::PACKED_DEPTH_STENCIL_BUFFER)
            .value("COLOR_BUFFER", osg::Camera::COLOR_BUFFER)
            .value("COLOR_BUFFER0", osg::Camera::COLOR_BUFFER0)
            .value("COLOR_BUFFER1", osg::Camera::COLOR_BUFFER1)
            .value("COLOR_BUFFER2", osg::Camera::COLOR_BUFFER2)
            .value("COLOR_BUFFER3", osg::Camera::COLOR_BUFFER3)
            .value("COLOR_BUFFER4", osg::Camera::COLOR_BUFFER4)
            .value("COLOR_BUFFER5", osg::Camera::COLOR_BUFFER5)
            .value("COLOR_BUFFER6", osg::Camera::COLOR_BUFFER6)
            .value("COLOR_BUFFER7", osg::Camera::COLOR_BUFFER7)
            .value("COLOR_BUFFER8", osg::Camera::COLOR_BUFFER8)
            .value("COLOR_BUFFER9", osg::Camera::COLOR_BUFFER9)
            .value("COLOR_BUFFER10", osg::Camera::COLOR_BUFFER10)
            .value("COLOR_BUFFER11", osg::Camera::COLOR_BUFFER11)
            .value("COLOR_BUFFER12", osg::Camera::COLOR_BUFFER12)
            .value("COLOR_BUFFER13", osg::Camera::COLOR_BUFFER13)
            .value("COLOR_BUFFER14", osg::Camera::COLOR_BUFFER14)
            .value("COLOR_BUFFER15", osg::Camera::COLOR_BUFFER15)
            .export_values()
            ;
        bp::enum_< osg::Camera::ImplicitBufferAttachment>("ImplicitBufferAttachment")
            .value("IMPLICIT_DEPTH_BUFFER_ATTACHMENT", osg::Camera::IMPLICIT_DEPTH_BUFFER_ATTACHMENT)
            .value("IMPLICIT_STENCIL_BUFFER_ATTACHMENT", osg::Camera::IMPLICIT_STENCIL_BUFFER_ATTACHMENT)
            .value("IMPLICIT_COLOR_BUFFER_ATTACHMENT", osg::Camera::IMPLICIT_COLOR_BUFFER_ATTACHMENT)
            .value("USE_DISPLAY_SETTINGS_MASK", osg::Camera::USE_DISPLAY_SETTINGS_MASK)
            .export_values()
            ;
        bp::enum_< osg::Camera::ProjectionResizePolicy>("ProjectionResizePolicy")
            .value("FIXED", osg::Camera::FIXED)
            .value("HORIZONTAL", osg::Camera::HORIZONTAL)
            .value("VERTICAL", osg::Camera::VERTICAL)
            .export_values()
            ;
        bp::enum_< osg::Camera::RenderOrder>("RenderOrder")
            .value("PRE_RENDER", osg::Camera::PRE_RENDER)
            .value("NESTED_RENDER", osg::Camera::NESTED_RENDER)
            .value("POST_RENDER", osg::Camera::POST_RENDER)
            .export_values()
            ;
        bp::enum_< osg::Camera::RenderTargetImplementation>("RenderTargetImplementation")
            .value("FRAME_BUFFER_OBJECT", osg::Camera::FRAME_BUFFER_OBJECT)
            .value("PIXEL_BUFFER_RTT", osg::Camera::PIXEL_BUFFER_RTT)
            .value("PIXEL_BUFFER", osg::Camera::PIXEL_BUFFER)
            .value("FRAME_BUFFER", osg::Camera::FRAME_BUFFER)
            .value("SEPERATE_WINDOW", osg::Camera::SEPERATE_WINDOW)
            .export_values()
            ;
        bp::enum_< osg::Camera::TransformOrder>("TransformOrder")
            .value("PRE_MULTIPLY", osg::Camera::PRE_MULTIPLY)
            .value("POST_MULTIPLY", osg::Camera::POST_MULTIPLY)
            .export_values()
            ;
        bp::class_< osg::Camera::Attachment >( "Attachment", bp::init< >() )    
            .def( 
                "depth"
                , (int ( ::osg::Camera::Attachment::* )(  ) const)( &::osg::Camera::Attachment::depth ) )    
            .def( 
                "height"
                , (int ( ::osg::Camera::Attachment::* )(  ) const)( &::osg::Camera::Attachment::height ) )    
            .def( 
                "width"
                , (int ( ::osg::Camera::Attachment::* )(  ) const)( &::osg::Camera::Attachment::width ) )    
            .def_readwrite( "_face", &osg::Camera::Attachment::_face )    
            .def_readwrite( "_image", &osg::Camera::Attachment::_image )    
            .def_readwrite( "_internalFormat", &osg::Camera::Attachment::_internalFormat )    
            .def_readwrite( "_level", &osg::Camera::Attachment::_level )    
            .def_readwrite( "_mipMapGeneration", &osg::Camera::Attachment::_mipMapGeneration )    
            .def_readwrite( "_multisampleColorSamples", &osg::Camera::Attachment::_multisampleColorSamples )    
            .def_readwrite( "_multisampleSamples", &osg::Camera::Attachment::_multisampleSamples )    
            .def_readwrite( "_texture", &osg::Camera::Attachment::_texture );
        bp::class_< Camera_wrapper::DrawCallback_wrapper, bp::bases< osg::Object >, osg::ref_ptr< Camera_wrapper::DrawCallback_wrapper >, boost::noncopyable >( "DrawCallback", "\n Draw callback for custom operations.\n", bp::init< >("\n Draw callback for custom operations.\n") )    
            .def( 
                "className"
                , (char const * ( ::osg::Camera::DrawCallback::* )(  ) const)(&::osg::Camera::DrawCallback::className)
                , (char const * ( Camera_wrapper::DrawCallback_wrapper::* )(  ) const)(&Camera_wrapper::DrawCallback_wrapper::default_className) )    
            .def( 
                "clone"
                , (::osg::Object * ( ::osg::Camera::DrawCallback::* )( ::osg::CopyOp const & ) const)(&::osg::Camera::DrawCallback::clone)
                , (::osg::Object * ( Camera_wrapper::DrawCallback_wrapper::* )( ::osg::CopyOp const & ) const)(&Camera_wrapper::DrawCallback_wrapper::default_clone)
                , ( bp::arg("copyop") )
                , bp::return_value_policy< bp::reference_existing_object >() )    
            .def( 
                "cloneType"
                , (::osg::Object * ( ::osg::Camera::DrawCallback::* )(  ) const)(&::osg::Camera::DrawCallback::cloneType)
                , (::osg::Object * ( Camera_wrapper::DrawCallback_wrapper::* )(  ) const)(&Camera_wrapper::DrawCallback_wrapper::default_cloneType)
                , bp::return_value_policy< bp::reference_existing_object >() )    
            .def( 
                "isSameKindAs"
                , (bool ( ::osg::Camera::DrawCallback::* )( ::osg::Object const * ) const)(&::osg::Camera::DrawCallback::isSameKindAs)
                , (bool ( Camera_wrapper::DrawCallback_wrapper::* )( ::osg::Object const * ) const)(&Camera_wrapper::DrawCallback_wrapper::default_isSameKindAs)
                , ( bp::arg("obj") ) )    
            .def( 
                "libraryName"
                , (char const * ( ::osg::Camera::DrawCallback::* )(  ) const)(&::osg::Camera::DrawCallback::libraryName)
                , (char const * ( Camera_wrapper::DrawCallback_wrapper::* )(  ) const)(&Camera_wrapper::DrawCallback_wrapper::default_libraryName) )    
            .def( 
                "__call__"
                , (void ( ::osg::Camera::DrawCallback::* )( ::osg::RenderInfo & ) const)(&::osg::Camera::DrawCallback::operator())
                , (void ( Camera_wrapper::DrawCallback_wrapper::* )( ::osg::RenderInfo & ) const)(&Camera_wrapper::DrawCallback_wrapper::default___call__)
                , ( bp::arg("renderInfo") ) )    
            .def( 
                "__call__"
                , (void (*)( ::osg::Camera::DrawCallback const &,::osg::Camera & ))( &Camera_wrapper::DrawCallback_wrapper::default_operator_call_8900c52bc7561d9994aad91cb1cd0699 )
                , ( bp::arg("inst"), bp::arg("arg0") )
                , "\n Functor method, provided for backwards compatibility, called by operator() (osg::RenderInfo& renderInfo) method.\n" );
        Camera_exposer.def( bp::init< >("\n Camera - is a subclass of Transform which represents encapsulates the settings of a Camera.\n") );
        { //::osg::Camera::accept
        
            typedef void ( ::osg::Camera::*accept_function_type )( ::osg::NodeVisitor & ) ;
            typedef void ( Camera_wrapper::*default_accept_function_type )( ::osg::NodeVisitor & ) ;
            
            Camera_exposer.def( 
                "accept"
                , accept_function_type(&::osg::Camera::accept)
                , default_accept_function_type(&Camera_wrapper::default_accept)
                , ( bp::arg("nv") ) );
        
        }
        { //::osg::Camera::asCamera
        
            typedef ::osg::Camera * ( ::osg::Camera::*asCamera_function_type )(  ) ;
            typedef ::osg::Camera * ( Camera_wrapper::*default_asCamera_function_type )(  ) ;
            
            Camera_exposer.def( 
                "asCamera"
                , asCamera_function_type(&::osg::Camera::asCamera)
                , default_asCamera_function_type(&Camera_wrapper::default_asCamera)
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::Camera::asCamera
        
            typedef ::osg::Camera const * ( ::osg::Camera::*asCamera_function_type )(  ) const;
            typedef ::osg::Camera const * ( Camera_wrapper::*default_asCamera_function_type )(  ) const;
            
            Camera_exposer.def( 
                "asCamera"
                , asCamera_function_type(&::osg::Camera::asCamera)
                , default_asCamera_function_type(&Camera_wrapper::default_asCamera)
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::Camera::attach
        
            typedef void ( ::osg::Camera::*attach_function_type )( ::osg::Camera::BufferComponent,::GLenum ) ;
            
            Camera_exposer.def( 
                "attach"
                , attach_function_type( &::osg::Camera::attach )
                , ( bp::arg("buffer"), bp::arg("internalFormat") )
                , " Attach a buffer with specified OpenGL internal format." );
        
        }
        { //::osg::Camera::attach
        
            typedef void ( ::osg::Camera::*attach_function_type )( ::osg::Camera::BufferComponent,::osg::Texture *,unsigned int,unsigned int,bool,unsigned int,unsigned int ) ;
            
            Camera_exposer.def( 
                "attach"
                , attach_function_type( &::osg::Camera::attach )
                , ( bp::arg("buffer"), bp::arg("texture"), bp::arg("level")=(unsigned int)(0), bp::arg("face")=(unsigned int)(0), bp::arg("mipMapGeneration")=(bool)(false), bp::arg("multisampleSamples")=(unsigned int)(0), bp::arg("multisampleColorSamples")=(unsigned int)(0) )
                , " Attach a Texture to specified buffer component.\n The level parameter controls the mip map level of the texture that is attached.\n The face parameter controls the face of texture cube map or z level of 3d texture.\n The mipMapGeneration flag controls whether mipmap generation should be done for texture." );
        
        }
        { //::osg::Camera::attach
        
            typedef void ( ::osg::Camera::*attach_function_type )( ::osg::Camera::BufferComponent,::osg::Image *,unsigned int,unsigned int ) ;
            
            Camera_exposer.def( 
                "attach"
                , attach_function_type( &::osg::Camera::attach )
                , ( bp::arg("buffer"), bp::arg("image"), bp::arg("multisampleSamples")=(unsigned int)(0), bp::arg("multisampleColorSamples")=(unsigned int)(0) )
                , " Attach a Image to specified buffer component." );
        
        }
        { //::osg::Camera::className
        
            typedef char const * ( ::osg::Camera::*className_function_type )(  ) const;
            typedef char const * ( Camera_wrapper::*default_className_function_type )(  ) const;
            
            Camera_exposer.def( 
                "className"
                , className_function_type(&::osg::Camera::className)
                , default_className_function_type(&Camera_wrapper::default_className) );
        
        }
        { //::osg::Camera::clone
        
            typedef ::osg::Object * ( ::osg::Camera::*clone_function_type )( ::osg::CopyOp const & ) const;
            typedef ::osg::Object * ( Camera_wrapper::*default_clone_function_type )( ::osg::CopyOp const & ) const;
            
            Camera_exposer.def( 
                "clone"
                , clone_function_type(&::osg::Camera::clone)
                , default_clone_function_type(&Camera_wrapper::default_clone)
                , ( bp::arg("copyop") )
                , bp::return_value_policy< bp::reference_existing_object >() );
        
        }
        { //::osg::Camera::cloneType
        
            typedef ::osg::Object * ( ::osg::Camera::*cloneType_function_type )(  ) const;
            typedef ::osg::Object * ( Camera_wrapper::*default_cloneType_function_type )(  ) const;
            
            Camera_exposer.def( 
                "cloneType"
                , cloneType_function_type(&::osg::Camera::cloneType)
                , default_cloneType_function_type(&Camera_wrapper::default_cloneType)
                , bp::return_value_policy< bp::reference_existing_object >() );
        
        }
        { //::osg::Camera::computeLocalToWorldMatrix
        
            typedef bool ( ::osg::Camera::*computeLocalToWorldMatrix_function_type )( ::osg::Matrix &,::osg::NodeVisitor * ) const;
            typedef bool ( Camera_wrapper::*default_computeLocalToWorldMatrix_function_type )( ::osg::Matrix &,::osg::NodeVisitor * ) const;
            
            Camera_exposer.def( 
                "computeLocalToWorldMatrix"
                , computeLocalToWorldMatrix_function_type(&::osg::Camera::computeLocalToWorldMatrix)
                , default_computeLocalToWorldMatrix_function_type(&Camera_wrapper::default_computeLocalToWorldMatrix)
                , ( bp::arg("matrix"), bp::arg("arg1") ) );
        
        }
        { //::osg::Camera::computeWorldToLocalMatrix
        
            typedef bool ( ::osg::Camera::*computeWorldToLocalMatrix_function_type )( ::osg::Matrix &,::osg::NodeVisitor * ) const;
            typedef bool ( Camera_wrapper::*default_computeWorldToLocalMatrix_function_type )( ::osg::Matrix &,::osg::NodeVisitor * ) const;
            
            Camera_exposer.def( 
                "computeWorldToLocalMatrix"
                , computeWorldToLocalMatrix_function_type(&::osg::Camera::computeWorldToLocalMatrix)
                , default_computeWorldToLocalMatrix_function_type(&Camera_wrapper::default_computeWorldToLocalMatrix)
                , ( bp::arg("matrix"), bp::arg("arg1") ) );
        
        }
        { //::osg::Camera::createCameraThread
        
            typedef void ( ::osg::Camera::*createCameraThread_function_type )(  ) ;
            
            Camera_exposer.def( 
                "createCameraThread"
                , createCameraThread_function_type( &::osg::Camera::createCameraThread )
                , " Create a operation thread for this camera." );
        
        }
        { //::osg::Camera::detach
        
            typedef void ( ::osg::Camera::*detach_function_type )( ::osg::Camera::BufferComponent ) ;
            
            Camera_exposer.def( 
                "detach"
                , detach_function_type( &::osg::Camera::detach )
                , ( bp::arg("buffer") )
                , " Detach specified buffer component." );
        
        }
        { //::osg::Camera::getAllowEventFocus
        
            typedef bool ( ::osg::Camera::*getAllowEventFocus_function_type )(  ) const;
            
            Camera_exposer.def( 
                "getAllowEventFocus"
                , getAllowEventFocus_function_type( &::osg::Camera::getAllowEventFocus )
                , " Get whether this camera allows events to be generated by the\n associated graphics window to be associated with this camera." );
        
        }
        { //::osg::Camera::getBufferAttachmentMap
        
            typedef ::std::map< osg::Camera::BufferComponent, osg::Camera::Attachment > & ( ::osg::Camera::*getBufferAttachmentMap_function_type )(  ) ;
            
            Camera_exposer.def( 
                "getBufferAttachmentMap"
                , getBufferAttachmentMap_function_type( &::osg::Camera::getBufferAttachmentMap )
                , bp::return_internal_reference< >()
                , " Get the BufferAttachmentMap, used to configure frame buffer objects, pbuffers and texture reads." );
        
        }
        { //::osg::Camera::getBufferAttachmentMap
        
            typedef ::std::map< osg::Camera::BufferComponent, osg::Camera::Attachment > const & ( ::osg::Camera::*getBufferAttachmentMap_function_type )(  ) const;
            
            Camera_exposer.def( 
                "getBufferAttachmentMap"
                , getBufferAttachmentMap_function_type( &::osg::Camera::getBufferAttachmentMap )
                , bp::return_internal_reference< >()
                , " Get the const BufferAttachmentMap, used to configure frame buffer objects, pbuffers and texture reads." );
        
        }
        { //::osg::Camera::getCameraThread
        
            typedef ::osg::OperationThread * ( ::osg::Camera::*getCameraThread_function_type )(  ) ;
            
            Camera_exposer.def( 
                "getCameraThread"
                , getCameraThread_function_type( &::osg::Camera::getCameraThread )
                , bp::return_internal_reference< >()
                , " Get the operation thread assigned to this camera." );
        
        }
        { //::osg::Camera::getCameraThread
        
            typedef ::osg::OperationThread const * ( ::osg::Camera::*getCameraThread_function_type )(  ) const;
            
            Camera_exposer.def( 
                "getCameraThread"
                , getCameraThread_function_type( &::osg::Camera::getCameraThread )
                , bp::return_internal_reference< >()
                , " Get the const operation thread assigned to this camera." );
        
        }
        { //::osg::Camera::getClearAccum
        
            typedef ::osg::Vec4 const & ( ::osg::Camera::*getClearAccum_function_type )(  ) const;
            
            Camera_exposer.def( 
                "getClearAccum"
                , getClearAccum_function_type( &::osg::Camera::getClearAccum )
                , bp::return_internal_reference< >()
                , " Get the clear accum value." );
        
        }
        { //::osg::Camera::getClearColor
        
            typedef ::osg::Vec4 const & ( ::osg::Camera::*getClearColor_function_type )(  ) const;
            
            Camera_exposer.def( 
                "getClearColor"
                , getClearColor_function_type( &::osg::Camera::getClearColor )
                , bp::return_internal_reference< >()
                , " Get the clear color." );
        
        }
        { //::osg::Camera::getClearDepth
        
            typedef double ( ::osg::Camera::*getClearDepth_function_type )(  ) const;
            
            Camera_exposer.def( 
                "getClearDepth"
                , getClearDepth_function_type( &::osg::Camera::getClearDepth )
                , " Get the clear depth value." );
        
        }
        { //::osg::Camera::getClearMask
        
            typedef ::GLbitfield ( ::osg::Camera::*getClearMask_function_type )(  ) const;
            
            Camera_exposer.def( 
                "getClearMask"
                , getClearMask_function_type( &::osg::Camera::getClearMask )
                , " Get the clear mask." );
        
        }
        { //::osg::Camera::getClearStencil
        
            typedef int ( ::osg::Camera::*getClearStencil_function_type )(  ) const;
            
            Camera_exposer.def( 
                "getClearStencil"
                , getClearStencil_function_type( &::osg::Camera::getClearStencil )
                , " Get the clear stencil value." );
        
        }
        { //::osg::Camera::getColorMask
        
            typedef ::osg::ColorMask const * ( ::osg::Camera::*getColorMask_function_type )(  ) const;
            
            Camera_exposer.def( 
                "getColorMask"
                , getColorMask_function_type( &::osg::Camera::getColorMask )
                , bp::return_internal_reference< >()
                , " Get the const ColorMask." );
        
        }
        { //::osg::Camera::getColorMask
        
            typedef ::osg::ColorMask * ( ::osg::Camera::*getColorMask_function_type )(  ) ;
            
            Camera_exposer.def( 
                "getColorMask"
                , getColorMask_function_type( &::osg::Camera::getColorMask )
                , bp::return_internal_reference< >()
                , " Get the ColorMask." );
        
        }
        { //::osg::Camera::getDataChangeMutex
        
            typedef ::OpenThreads::Mutex * ( ::osg::Camera::*getDataChangeMutex_function_type )(  ) const;
            
            Camera_exposer.def( 
                "getDataChangeMutex"
                , getDataChangeMutex_function_type( &::osg::Camera::getDataChangeMutex )
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::Camera::getDisplaySettings
        
            typedef ::osg::DisplaySettings * ( ::osg::Camera::*getDisplaySettings_function_type )(  ) ;
            
            Camera_exposer.def( 
                "getDisplaySettings"
                , getDisplaySettings_function_type( &::osg::Camera::getDisplaySettings )
                , bp::return_internal_reference< >()
                , " Get the DisplaySettings object associated with this view." );
        
        }
        { //::osg::Camera::getDisplaySettings
        
            typedef ::osg::DisplaySettings const * ( ::osg::Camera::*getDisplaySettings_function_type )(  ) const;
            
            Camera_exposer.def( 
                "getDisplaySettings"
                , getDisplaySettings_function_type( &::osg::Camera::getDisplaySettings )
                , bp::return_internal_reference< >()
                , " Get the const DisplaySettings object associated with this view." );
        
        }
        { //::osg::Camera::getDrawBuffer
        
            typedef ::GLenum ( ::osg::Camera::*getDrawBuffer_function_type )(  ) const;
            
            Camera_exposer.def( 
                "getDrawBuffer"
                , getDrawBuffer_function_type( &::osg::Camera::getDrawBuffer )
                , " Get the draw buffer used at the start of each frame draw." );
        
        }
        { //::osg::Camera::getFinalDrawCallback
        
            typedef ::osg::Camera::DrawCallback * ( ::osg::Camera::*getFinalDrawCallback_function_type )(  ) ;
            
            Camera_exposer.def( 
                "getFinalDrawCallback"
                , getFinalDrawCallback_function_type( &::osg::Camera::getFinalDrawCallback )
                , bp::return_internal_reference< >()
                , " Get the final draw callback." );
        
        }
        { //::osg::Camera::getFinalDrawCallback
        
            typedef ::osg::Camera::DrawCallback const * ( ::osg::Camera::*getFinalDrawCallback_function_type )(  ) const;
            
            Camera_exposer.def( 
                "getFinalDrawCallback"
                , getFinalDrawCallback_function_type( &::osg::Camera::getFinalDrawCallback )
                , bp::return_internal_reference< >()
                , " Get the const final draw callback." );
        
        }
        { //::osg::Camera::getGraphicsContext
        
            typedef ::osg::GraphicsContext * ( ::osg::Camera::*getGraphicsContext_function_type )(  ) ;
            
            Camera_exposer.def( 
                "getGraphicsContext"
                , getGraphicsContext_function_type( &::osg::Camera::getGraphicsContext )
                , bp::return_internal_reference< >()
                , " Get the GraphicsContext." );
        
        }
        { //::osg::Camera::getGraphicsContext
        
            typedef ::osg::GraphicsContext const * ( ::osg::Camera::*getGraphicsContext_function_type )(  ) const;
            
            Camera_exposer.def( 
                "getGraphicsContext"
                , getGraphicsContext_function_type( &::osg::Camera::getGraphicsContext )
                , bp::return_internal_reference< >()
                , " Get the const GraphicsContext." );
        
        }
        { //::osg::Camera::getImplicitBufferAttachmentRenderMask
        
            typedef int ( ::osg::Camera::*getImplicitBufferAttachmentRenderMask_function_type )( bool ) const;
            
            Camera_exposer.def( 
                "getImplicitBufferAttachmentRenderMask"
                , getImplicitBufferAttachmentRenderMask_function_type( &::osg::Camera::getImplicitBufferAttachmentRenderMask )
                , ( bp::arg("effectiveMask")=(bool)(false) )
                , "        Get mask selecting implict buffer attachments for Camera primary FBO\n        if effectiveMask parameter is set, method follows USE_DISPLAY_SETTINGS_MASK dependence and returns effective mask\n        if effectiveMask parameter is reset, method returns nominal mask set by the Camera" );
        
        }
        { //::osg::Camera::getImplicitBufferAttachmentResolveMask
        
            typedef int ( ::osg::Camera::*getImplicitBufferAttachmentResolveMask_function_type )( bool ) const;
            
            Camera_exposer.def( 
                "getImplicitBufferAttachmentResolveMask"
                , getImplicitBufferAttachmentResolveMask_function_type( &::osg::Camera::getImplicitBufferAttachmentResolveMask )
                , ( bp::arg("effectiveMask")=(bool)(false) )
                , "        Get mask selecting implict buffer attachments for Camera secondary MULTISAMPLE FBO\n        if effectiveMask parameter is set, method follows USE_DISPLAY_SETTINGS_MASK dependence and returns effective mask\n        if effectiveMask parameter is reset, method returns nominal mask set by the Camera" );
        
        }
        { //::osg::Camera::getInitialDrawCallback
        
            typedef ::osg::Camera::DrawCallback * ( ::osg::Camera::*getInitialDrawCallback_function_type )(  ) ;
            
            Camera_exposer.def( 
                "getInitialDrawCallback"
                , getInitialDrawCallback_function_type( &::osg::Camera::getInitialDrawCallback )
                , bp::return_internal_reference< >()
                , " Get the initial draw callback." );
        
        }
        { //::osg::Camera::getInitialDrawCallback
        
            typedef ::osg::Camera::DrawCallback const * ( ::osg::Camera::*getInitialDrawCallback_function_type )(  ) const;
            
            Camera_exposer.def( 
                "getInitialDrawCallback"
                , getInitialDrawCallback_function_type( &::osg::Camera::getInitialDrawCallback )
                , bp::return_internal_reference< >()
                , " Get the const initial draw callback." );
        
        }
        { //::osg::Camera::getInverseViewMatrix
        
            typedef ::osg::Matrixd ( ::osg::Camera::*getInverseViewMatrix_function_type )(  ) const;
            
            Camera_exposer.def( 
                "getInverseViewMatrix"
                , getInverseViewMatrix_function_type( &::osg::Camera::getInverseViewMatrix )
                , " Get the inverse view matrix." );
        
        }
        { //::osg::Camera::getPostDrawCallback
        
            typedef ::osg::Camera::DrawCallback * ( ::osg::Camera::*getPostDrawCallback_function_type )(  ) ;
            
            Camera_exposer.def( 
                "getPostDrawCallback"
                , getPostDrawCallback_function_type( &::osg::Camera::getPostDrawCallback )
                , bp::return_internal_reference< >()
                , " Get the post draw callback." );
        
        }
        { //::osg::Camera::getPostDrawCallback
        
            typedef ::osg::Camera::DrawCallback const * ( ::osg::Camera::*getPostDrawCallback_function_type )(  ) const;
            
            Camera_exposer.def( 
                "getPostDrawCallback"
                , getPostDrawCallback_function_type( &::osg::Camera::getPostDrawCallback )
                , bp::return_internal_reference< >()
                , " Get the const post draw callback." );
        
        }
        { //::osg::Camera::getPreDrawCallback
        
            typedef ::osg::Camera::DrawCallback * ( ::osg::Camera::*getPreDrawCallback_function_type )(  ) ;
            
            Camera_exposer.def( 
                "getPreDrawCallback"
                , getPreDrawCallback_function_type( &::osg::Camera::getPreDrawCallback )
                , bp::return_internal_reference< >()
                , " Get the pre draw callback." );
        
        }
        { //::osg::Camera::getPreDrawCallback
        
            typedef ::osg::Camera::DrawCallback const * ( ::osg::Camera::*getPreDrawCallback_function_type )(  ) const;
            
            Camera_exposer.def( 
                "getPreDrawCallback"
                , getPreDrawCallback_function_type( &::osg::Camera::getPreDrawCallback )
                , bp::return_internal_reference< >()
                , " Get the const pre draw callback." );
        
        }
        { //::osg::Camera::getProjectionMatrix
        
            typedef ::osg::Matrixd & ( ::osg::Camera::*getProjectionMatrix_function_type )(  ) ;
            
            Camera_exposer.def( 
                "getProjectionMatrix"
                , getProjectionMatrix_function_type( &::osg::Camera::getProjectionMatrix )
                , bp::return_internal_reference< >()
                , " Get the projection matrix." );
        
        }
        { //::osg::Camera::getProjectionMatrix
        
            typedef ::osg::Matrixd const & ( ::osg::Camera::*getProjectionMatrix_function_type )(  ) const;
            
            Camera_exposer.def( 
                "getProjectionMatrix"
                , getProjectionMatrix_function_type( &::osg::Camera::getProjectionMatrix )
                , bp::return_internal_reference< >()
                , " Get the const projection matrix." );
        
        }
        { //::osg::Camera::getProjectionMatrixAsFrustum
        
            typedef bool ( ::osg::Camera::*getProjectionMatrixAsFrustum_function_type )( double &,double &,double &,double &,double &,double & ) const;
            
            Camera_exposer.def( 
                "getProjectionMatrixAsFrustum"
                , getProjectionMatrixAsFrustum_function_type( &::osg::Camera::getProjectionMatrixAsFrustum )
                , ( bp::arg("left"), bp::arg("right"), bp::arg("bottom"), bp::arg("top"), bp::arg("zNear"), bp::arg("zFar") )
                , " Get the frustum setting of a perspective projection matrix.\n Returns false if matrix is not a perspective matrix, where parameter values are undefined." );
        
        }
        { //::osg::Camera::getProjectionMatrixAsOrtho
        
            typedef bool ( ::osg::Camera::*getProjectionMatrixAsOrtho_function_type )( double &,double &,double &,double &,double &,double & ) const;
            
            Camera_exposer.def( 
                "getProjectionMatrixAsOrtho"
                , getProjectionMatrixAsOrtho_function_type( &::osg::Camera::getProjectionMatrixAsOrtho )
                , ( bp::arg("left"), bp::arg("right"), bp::arg("bottom"), bp::arg("top"), bp::arg("zNear"), bp::arg("zFar") )
                , " Get the orthographic settings of the orthographic projection matrix.\n Returns false if matrix is not an orthographic matrix, where parameter values are undefined." );
        
        }
        { //::osg::Camera::getProjectionMatrixAsPerspective
        
            typedef bool ( ::osg::Camera::*getProjectionMatrixAsPerspective_function_type )( double &,double &,double &,double & ) const;
            
            Camera_exposer.def( 
                "getProjectionMatrixAsPerspective"
                , getProjectionMatrixAsPerspective_function_type( &::osg::Camera::getProjectionMatrixAsPerspective )
                , ( bp::arg("fovy"), bp::arg("aspectRatio"), bp::arg("zNear"), bp::arg("zFar") )
                , " Get the frustum setting of a symmetric perspective projection matrix.\n Returns false if matrix is not a perspective matrix, where parameter values are undefined.\n Note, if matrix is not a symmetric perspective matrix then the shear will be lost.\n Asymmetric matrices occur when stereo, power walls, caves and reality center display are used.\n In these configurations one should use the getProjectionMatrixAsFrustum method instead." );
        
        }
        { //::osg::Camera::getProjectionResizePolicy
        
            typedef ::osg::Camera::ProjectionResizePolicy ( ::osg::Camera::*getProjectionResizePolicy_function_type )(  ) const;
            
            Camera_exposer.def( 
                "getProjectionResizePolicy"
                , getProjectionResizePolicy_function_type( &::osg::Camera::getProjectionResizePolicy )
                , " Get the policy used to determine if and how the projection matrix should be adjusted on window resizes." );
        
        }
        { //::osg::Camera::getReadBuffer
        
            typedef ::GLenum ( ::osg::Camera::*getReadBuffer_function_type )(  ) const;
            
            Camera_exposer.def( 
                "getReadBuffer"
                , getReadBuffer_function_type( &::osg::Camera::getReadBuffer )
                , " Get the read buffer for any required copy operations to use." );
        
        }
        { //::osg::Camera::getRenderOrder
        
            typedef ::osg::Camera::RenderOrder ( ::osg::Camera::*getRenderOrder_function_type )(  ) const;
            
            Camera_exposer.def( 
                "getRenderOrder"
                , getRenderOrder_function_type( &::osg::Camera::getRenderOrder )
                , " Get the rendering order of this cameras subgraph relative to any camera that this subgraph is nested within." );
        
        }
        { //::osg::Camera::getRenderOrderNum
        
            typedef int ( ::osg::Camera::*getRenderOrderNum_function_type )(  ) const;
            
            Camera_exposer.def( 
                "getRenderOrderNum"
                , getRenderOrderNum_function_type( &::osg::Camera::getRenderOrderNum )
                , " Get the rendering order number of this camera relative to any sibling cameras in this subgraph." );
        
        }
        { //::osg::Camera::getRenderTargetFallback
        
            typedef ::osg::Camera::RenderTargetImplementation ( ::osg::Camera::*getRenderTargetFallback_function_type )(  ) const;
            
            Camera_exposer.def( 
                "getRenderTargetFallback"
                , getRenderTargetFallback_function_type( &::osg::Camera::getRenderTargetFallback )
                , " Get the render target fallback." );
        
        }
        { //::osg::Camera::getRenderTargetImplementation
        
            typedef ::osg::Camera::RenderTargetImplementation ( ::osg::Camera::*getRenderTargetImplementation_function_type )(  ) const;
            
            Camera_exposer.def( 
                "getRenderTargetImplementation"
                , getRenderTargetImplementation_function_type( &::osg::Camera::getRenderTargetImplementation )
                , " Get the render target." );
        
        }
        { //::osg::Camera::getRenderer
        
            typedef ::osg::GraphicsOperation * ( ::osg::Camera::*getRenderer_function_type )(  ) ;
            
            Camera_exposer.def( 
                "getRenderer"
                , getRenderer_function_type( &::osg::Camera::getRenderer )
                , bp::return_internal_reference< >()
                , " Get the Rendering object that is used to implement rendering of the subgraph." );
        
        }
        { //::osg::Camera::getRenderer
        
            typedef ::osg::GraphicsOperation const * ( ::osg::Camera::*getRenderer_function_type )(  ) const;
            
            Camera_exposer.def( 
                "getRenderer"
                , getRenderer_function_type( &::osg::Camera::getRenderer )
                , bp::return_internal_reference< >()
                , " Get the const Rendering object that is used to implement rendering of the subgraph." );
        
        }
        { //::osg::Camera::getRenderingCache
        
            typedef ::osg::Object * ( ::osg::Camera::*getRenderingCache_function_type )(  ) ;
            
            Camera_exposer.def( 
                "getRenderingCache"
                , getRenderingCache_function_type( &::osg::Camera::getRenderingCache )
                , bp::return_internal_reference< >()
                , " Get the Rendering cache that is used for cached objects associated with rendering of subgraphs." );
        
        }
        { //::osg::Camera::getRenderingCache
        
            typedef ::osg::Object const * ( ::osg::Camera::*getRenderingCache_function_type )(  ) const;
            
            Camera_exposer.def( 
                "getRenderingCache"
                , getRenderingCache_function_type( &::osg::Camera::getRenderingCache )
                , bp::return_internal_reference< >()
                , " Get the const Rendering cache that is used for cached objects associated with rendering of subgraphs." );
        
        }
        { //::osg::Camera::getStats
        
            typedef ::osg::Stats * ( ::osg::Camera::*getStats_function_type )(  ) ;
            
            Camera_exposer.def( 
                "getStats"
                , getStats_function_type( &::osg::Camera::getStats )
                , bp::return_internal_reference< >()
                , " Get the Stats object." );
        
        }
        { //::osg::Camera::getStats
        
            typedef ::osg::Stats const * ( ::osg::Camera::*getStats_function_type )(  ) const;
            
            Camera_exposer.def( 
                "getStats"
                , getStats_function_type( &::osg::Camera::getStats )
                , bp::return_internal_reference< >()
                , " Get the const Stats object." );
        
        }
        { //::osg::Camera::getTransformOrder
        
            typedef ::osg::Camera::TransformOrder ( ::osg::Camera::*getTransformOrder_function_type )(  ) const;
            
            Camera_exposer.def( 
                "getTransformOrder"
                , getTransformOrder_function_type( &::osg::Camera::getTransformOrder )
                , " Get the transformation order." );
        
        }
        { //::osg::Camera::getView
        
            typedef ::osg::View * ( ::osg::Camera::*getView_function_type )(  ) ;
            
            Camera_exposer.def( 
                "getView"
                , getView_function_type( &::osg::Camera::getView )
                , bp::return_internal_reference< >()
                , " Get the View that this Camera is part of." );
        
        }
        { //::osg::Camera::getView
        
            typedef ::osg::View const * ( ::osg::Camera::*getView_function_type )(  ) const;
            
            Camera_exposer.def( 
                "getView"
                , getView_function_type( &::osg::Camera::getView )
                , bp::return_internal_reference< >()
                , " Get the const View that this Camera is part of." );
        
        }
        { //::osg::Camera::getViewMatrix
        
            typedef ::osg::Matrixd & ( ::osg::Camera::*getViewMatrix_function_type )(  ) ;
            
            Camera_exposer.def( 
                "getViewMatrix"
                , getViewMatrix_function_type( &::osg::Camera::getViewMatrix )
                , bp::return_internal_reference< >()
                , " Get the view matrix." );
        
        }
        { //::osg::Camera::getViewMatrix
        
            typedef ::osg::Matrixd const & ( ::osg::Camera::*getViewMatrix_function_type )(  ) const;
            
            Camera_exposer.def( 
                "getViewMatrix"
                , getViewMatrix_function_type( &::osg::Camera::getViewMatrix )
                , bp::return_internal_reference< >()
                , " Get the const view matrix." );
        
        }
        { //::osg::Camera::getViewMatrixAsLookAt
        
            typedef void ( ::osg::Camera::*getViewMatrixAsLookAt_function_type )( ::osg::Vec3d &,::osg::Vec3d &,::osg::Vec3d &,double ) const;
            
            Camera_exposer.def( 
                "getViewMatrixAsLookAt"
                , getViewMatrixAsLookAt_function_type( &::osg::Camera::getViewMatrixAsLookAt )
                , ( bp::arg("eye"), bp::arg("center"), bp::arg("up"), bp::arg("lookDistance")=1.0e+0 )
                , " Get to the position and orientation of a modelview matrix, using the same convention as gluLookAt." );
        
        }
        { //::osg::Camera::getViewMatrixAsLookAt
        
            typedef void ( ::osg::Camera::*getViewMatrixAsLookAt_function_type )( ::osg::Vec3f &,::osg::Vec3f &,::osg::Vec3f &,float ) const;
            
            Camera_exposer.def( 
                "getViewMatrixAsLookAt"
                , getViewMatrixAsLookAt_function_type( &::osg::Camera::getViewMatrixAsLookAt )
                , ( bp::arg("eye"), bp::arg("center"), bp::arg("up"), bp::arg("lookDistance")=1.0e+0f )
                , " Get to the position and orientation of a modelview matrix, using the same convention as gluLookAt." );
        
        }
        { //::osg::Camera::getViewport
        
            typedef ::osg::Viewport const * ( ::osg::Camera::*getViewport_function_type )(  ) const;
            
            Camera_exposer.def( 
                "getViewport"
                , getViewport_function_type( &::osg::Camera::getViewport )
                , bp::return_internal_reference< >()
                , " Get the const viewport." );
        
        }
        { //::osg::Camera::getViewport
        
            typedef ::osg::Viewport * ( ::osg::Camera::*getViewport_function_type )(  ) ;
            
            Camera_exposer.def( 
                "getViewport"
                , getViewport_function_type( &::osg::Camera::getViewport )
                , bp::return_internal_reference< >()
                , " Get the viewport." );
        
        }
        { //::osg::Camera::inheritCullSettings
        
            typedef void ( ::osg::Camera::*inheritCullSettings_function_type )( ::osg::CullSettings const &,unsigned int ) ;
            typedef void ( Camera_wrapper::*default_inheritCullSettings_function_type )( ::osg::CullSettings const &,unsigned int ) ;
            
            Camera_exposer.def( 
                "inheritCullSettings"
                , inheritCullSettings_function_type(&::osg::Camera::inheritCullSettings)
                , default_inheritCullSettings_function_type(&Camera_wrapper::default_inheritCullSettings)
                , ( bp::arg("settings"), bp::arg("inheritanceMask") ) );
        
        }
        { //::osg::Camera::isRenderToTextureCamera
        
            typedef bool ( ::osg::Camera::*isRenderToTextureCamera_function_type )(  ) const;
            
            Camera_exposer.def( 
                "isRenderToTextureCamera"
                , isRenderToTextureCamera_function_type( &::osg::Camera::isRenderToTextureCamera )
                , " Return true if this Camera is set up as a render to texture camera, i.e. it has textures assigned to it." );
        
        }
        { //::osg::Camera::isSameKindAs
        
            typedef bool ( ::osg::Camera::*isSameKindAs_function_type )( ::osg::Object const * ) const;
            typedef bool ( Camera_wrapper::*default_isSameKindAs_function_type )( ::osg::Object const * ) const;
            
            Camera_exposer.def( 
                "isSameKindAs"
                , isSameKindAs_function_type(&::osg::Camera::isSameKindAs)
                , default_isSameKindAs_function_type(&Camera_wrapper::default_isSameKindAs)
                , ( bp::arg("obj") ) );
        
        }
        { //::osg::Camera::libraryName
        
            typedef char const * ( ::osg::Camera::*libraryName_function_type )(  ) const;
            typedef char const * ( Camera_wrapper::*default_libraryName_function_type )(  ) const;
            
            Camera_exposer.def( 
                "libraryName"
                , libraryName_function_type(&::osg::Camera::libraryName)
                , default_libraryName_function_type(&Camera_wrapper::default_libraryName) );
        
        }
        { //::osg::Camera::resizeGLObjectBuffers
        
            typedef void ( ::osg::Camera::*resizeGLObjectBuffers_function_type )( unsigned int ) ;
            typedef void ( Camera_wrapper::*default_resizeGLObjectBuffers_function_type )( unsigned int ) ;
            
            Camera_exposer.def( 
                "resizeGLObjectBuffers"
                , resizeGLObjectBuffers_function_type(&::osg::Camera::resizeGLObjectBuffers)
                , default_resizeGLObjectBuffers_function_type(&Camera_wrapper::default_resizeGLObjectBuffers)
                , ( bp::arg("maxSize") ) );
        
        }
        { //::osg::Camera::setAllowEventFocus
        
            typedef void ( ::osg::Camera::*setAllowEventFocus_function_type )( bool ) ;
            
            Camera_exposer.def( 
                "setAllowEventFocus"
                , setAllowEventFocus_function_type( &::osg::Camera::setAllowEventFocus )
                , ( bp::arg("focus") )
                , " Set whether this camera allows events to be generated by the\n associated graphics window to be associated with this camera." );
        
        }
        { //::osg::Camera::setCameraThread
        
            typedef void ( ::osg::Camera::*setCameraThread_function_type )( ::osg::OperationThread * ) ;
            
            Camera_exposer.def( 
                "setCameraThread"
                , setCameraThread_function_type( &::osg::Camera::setCameraThread )
                , ( bp::arg("gt") )
                , " Assign a operation thread to the camera." );
        
        }
        { //::osg::Camera::setClearAccum
        
            typedef void ( ::osg::Camera::*setClearAccum_function_type )( ::osg::Vec4 const & ) ;
            
            Camera_exposer.def( 
                "setClearAccum"
                , setClearAccum_function_type( &::osg::Camera::setClearAccum )
                , ( bp::arg("color") )
                , " Set the clear accum used in glClearAccum().\n glClearAcumm is only called if mask & GL_ACCUM_BUFFER_BIT is true." );
        
        }
        { //::osg::Camera::setClearColor
        
            typedef void ( ::osg::Camera::*setClearColor_function_type )( ::osg::Vec4 const & ) ;
            
            Camera_exposer.def( 
                "setClearColor"
                , setClearColor_function_type( &::osg::Camera::setClearColor )
                , ( bp::arg("color") )
                , " Set the clear color used in glClearColor().\n glClearColor is only called if mask & GL_COLOR_BUFFER_BIT is true" );
        
        }
        { //::osg::Camera::setClearDepth
        
            typedef void ( ::osg::Camera::*setClearDepth_function_type )( double ) ;
            
            Camera_exposer.def( 
                "setClearDepth"
                , setClearDepth_function_type( &::osg::Camera::setClearDepth )
                , ( bp::arg("depth") )
                , " Set the clear depth used in glClearDepth(). Defaults to 1.0\n glClearDepth is only called if mask & GL_DEPTH_BUFFER_BIT is true." );
        
        }
        { //::osg::Camera::setClearMask
        
            typedef void ( ::osg::Camera::*setClearMask_function_type )( ::GLbitfield ) ;
            
            Camera_exposer.def( 
                "setClearMask"
                , setClearMask_function_type( &::osg::Camera::setClearMask )
                , ( bp::arg("mask") )
                , " Set the clear mask used in glClear().\n Defaults to GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT." );
        
        }
        { //::osg::Camera::setClearStencil
        
            typedef void ( ::osg::Camera::*setClearStencil_function_type )( int ) ;
            
            Camera_exposer.def( 
                "setClearStencil"
                , setClearStencil_function_type( &::osg::Camera::setClearStencil )
                , ( bp::arg("stencil") )
                , " Set the clear stencil value used in glClearStencil(). Defaults to 0;\n glClearStencil is only called if mask & GL_STENCIL_BUFFER_BIT is true" );
        
        }
        { //::osg::Camera::setColorMask
        
            typedef void ( ::osg::Camera::*setColorMask_function_type )( ::osg::ColorMask * ) ;
            
            Camera_exposer.def( 
                "setColorMask"
                , setColorMask_function_type( &::osg::Camera::setColorMask )
                , ( bp::arg("colorMask") )
                , " Set the color mask of the camera to use specified osg::ColorMask." );
        
        }
        { //::osg::Camera::setColorMask
        
            typedef void ( ::osg::Camera::*setColorMask_function_type )( bool,bool,bool,bool ) ;
            
            Camera_exposer.def( 
                "setColorMask"
                , setColorMask_function_type( &::osg::Camera::setColorMask )
                , ( bp::arg("red"), bp::arg("green"), bp::arg("blue"), bp::arg("alpha") )
                , " Set the color mask of the camera to specified values." );
        
        }
        { //::osg::Camera::setDisplaySettings
        
            typedef void ( ::osg::Camera::*setDisplaySettings_function_type )( ::osg::DisplaySettings * ) ;
            
            Camera_exposer.def( 
                "setDisplaySettings"
                , setDisplaySettings_function_type( &::osg::Camera::setDisplaySettings )
                , ( bp::arg("ds") )
                , " Set the DisplaySettings object associated with this view." );
        
        }
        { //::osg::Camera::setDrawBuffer
        
            typedef void ( ::osg::Camera::*setDrawBuffer_function_type )( ::GLenum ) ;
            
            Camera_exposer.def( 
                "setDrawBuffer"
                , setDrawBuffer_function_type( &::osg::Camera::setDrawBuffer )
                , ( bp::arg("buffer") )
                , " Set the draw buffer used at the start of each frame draw.\n Note, a buffer value of GL_NONE is used to sepecify that the rendering back-end should choose the most appropriate buffer." );
        
        }
        { //::osg::Camera::setFinalDrawCallback
        
            typedef void ( ::osg::Camera::*setFinalDrawCallback_function_type )( ::osg::Camera::DrawCallback * ) ;
            
            Camera_exposer.def( 
                "setFinalDrawCallback"
                , setFinalDrawCallback_function_type( &::osg::Camera::setFinalDrawCallback )
                , ( bp::arg("cb") )
                , bp::with_custodian_and_ward< 2, 1 >()
                , " Set the final draw callback for custom operations to be done after the drawing of the cameras subgraph and all of the post render stages has been completed." );
        
        }
        { //::osg::Camera::setGraphicsContext
        
            typedef void ( ::osg::Camera::*setGraphicsContext_function_type )( ::osg::GraphicsContext * ) ;
            
            Camera_exposer.def( 
                "setGraphicsContext"
                , setGraphicsContext_function_type( &::osg::Camera::setGraphicsContext )
                , ( bp::arg("context") )
                , " Set the GraphicsContext that provides the mechansim for managing the OpenGL graphics context associated with this camera." );
        
        }
        { //::osg::Camera::setImplicitBufferAttachmentMask
        
            typedef void ( ::osg::Camera::*setImplicitBufferAttachmentMask_function_type )( int,int ) ;
            
            Camera_exposer.def( 
                "setImplicitBufferAttachmentMask"
                , setImplicitBufferAttachmentMask_function_type( &::osg::Camera::setImplicitBufferAttachmentMask )
                , ( bp::arg("renderMask")=(int)(DEFAULT_IMPLICIT_BUFFER_ATTACHMENT), bp::arg("resolveMask")=(int)(DEFAULT_IMPLICIT_BUFFER_ATTACHMENT) ) );
        
        }
        { //::osg::Camera::setImplicitBufferAttachmentRenderMask
        
            typedef void ( ::osg::Camera::*setImplicitBufferAttachmentRenderMask_function_type )( int ) ;
            
            Camera_exposer.def( 
                "setImplicitBufferAttachmentRenderMask"
                , setImplicitBufferAttachmentRenderMask_function_type( &::osg::Camera::setImplicitBufferAttachmentRenderMask )
                , ( bp::arg("implicitBufferAttachmentRenderMask") ) );
        
        }
        { //::osg::Camera::setImplicitBufferAttachmentResolveMask
        
            typedef void ( ::osg::Camera::*setImplicitBufferAttachmentResolveMask_function_type )( int ) ;
            
            Camera_exposer.def( 
                "setImplicitBufferAttachmentResolveMask"
                , setImplicitBufferAttachmentResolveMask_function_type( &::osg::Camera::setImplicitBufferAttachmentResolveMask )
                , ( bp::arg("implicitBufferAttachmentResolveMask") ) );
        
        }
        { //::osg::Camera::setInitialDrawCallback
        
            typedef void ( ::osg::Camera::*setInitialDrawCallback_function_type )( ::osg::Camera::DrawCallback * ) ;
            
            Camera_exposer.def( 
                "setInitialDrawCallback"
                , setInitialDrawCallback_function_type( &::osg::Camera::setInitialDrawCallback )
                , ( bp::arg("cb") )
                , bp::with_custodian_and_ward< 2, 1 >()
                , " Set the initial draw callback for custom operations to be done before the drawing of the cameras subgraph and pre render stages." );
        
        }
        { //::osg::Camera::setPostDrawCallback
        
            typedef void ( ::osg::Camera::*setPostDrawCallback_function_type )( ::osg::Camera::DrawCallback * ) ;
            
            Camera_exposer.def( 
                "setPostDrawCallback"
                , setPostDrawCallback_function_type( &::osg::Camera::setPostDrawCallback )
                , ( bp::arg("cb") )
                , bp::with_custodian_and_ward< 2, 1 >()
                , " Set the post draw callback for custom operations to be done after the drawing of the cameras subgraph but before the any post render stages have been completed." );
        
        }
        { //::osg::Camera::setPreDrawCallback
        
            typedef void ( ::osg::Camera::*setPreDrawCallback_function_type )( ::osg::Camera::DrawCallback * ) ;
            
            Camera_exposer.def( 
                "setPreDrawCallback"
                , setPreDrawCallback_function_type( &::osg::Camera::setPreDrawCallback )
                , ( bp::arg("cb") )
                , bp::with_custodian_and_ward< 2, 1 >()
                , " Set the pre draw callback for custom operations to be done before the drawing of the cameras subgraph but after any pre render stages have been completed." );
        
        }
        { //::osg::Camera::setProjectionMatrix
        
            typedef void ( ::osg::Camera::*setProjectionMatrix_function_type )( ::osg::Matrixf const & ) ;
            
            Camera_exposer.def( 
                "setProjectionMatrix"
                , setProjectionMatrix_function_type( &::osg::Camera::setProjectionMatrix )
                , ( bp::arg("matrix") )
                , " Set the projection matrix. Can be thought of as setting the lens of a camera." );
        
        }
        { //::osg::Camera::setProjectionMatrix
        
            typedef void ( ::osg::Camera::*setProjectionMatrix_function_type )( ::osg::Matrixd const & ) ;
            
            Camera_exposer.def( 
                "setProjectionMatrix"
                , setProjectionMatrix_function_type( &::osg::Camera::setProjectionMatrix )
                , ( bp::arg("matrix") )
                , " Set the projection matrix. Can be thought of as setting the lens of a camera." );
        
        }
        { //::osg::Camera::setProjectionMatrixAsFrustum
        
            typedef void ( ::osg::Camera::*setProjectionMatrixAsFrustum_function_type )( double,double,double,double,double,double ) ;
            
            Camera_exposer.def( 
                "setProjectionMatrixAsFrustum"
                , setProjectionMatrixAsFrustum_function_type( &::osg::Camera::setProjectionMatrixAsFrustum )
                , ( bp::arg("left"), bp::arg("right"), bp::arg("bottom"), bp::arg("top"), bp::arg("zNear"), bp::arg("zFar") )
                , " Set to a perspective projection. See OpenGL glFrustum documentation for further details." );
        
        }
        { //::osg::Camera::setProjectionMatrixAsOrtho
        
            typedef void ( ::osg::Camera::*setProjectionMatrixAsOrtho_function_type )( double,double,double,double,double,double ) ;
            
            Camera_exposer.def( 
                "setProjectionMatrixAsOrtho"
                , setProjectionMatrixAsOrtho_function_type( &::osg::Camera::setProjectionMatrixAsOrtho )
                , ( bp::arg("left"), bp::arg("right"), bp::arg("bottom"), bp::arg("top"), bp::arg("zNear"), bp::arg("zFar") )
                , " Set to an orthographic projection. See OpenGL glOrtho for documentation further details." );
        
        }
        { //::osg::Camera::setProjectionMatrixAsOrtho2D
        
            typedef void ( ::osg::Camera::*setProjectionMatrixAsOrtho2D_function_type )( double,double,double,double ) ;
            
            Camera_exposer.def( 
                "setProjectionMatrixAsOrtho2D"
                , setProjectionMatrixAsOrtho2D_function_type( &::osg::Camera::setProjectionMatrixAsOrtho2D )
                , ( bp::arg("left"), bp::arg("right"), bp::arg("bottom"), bp::arg("top") )
                , " Set to a 2D orthographic projection. See OpenGL glOrtho2D documentation for further details." );
        
        }
        { //::osg::Camera::setProjectionMatrixAsPerspective
        
            typedef void ( ::osg::Camera::*setProjectionMatrixAsPerspective_function_type )( double,double,double,double ) ;
            
            Camera_exposer.def( 
                "setProjectionMatrixAsPerspective"
                , setProjectionMatrixAsPerspective_function_type( &::osg::Camera::setProjectionMatrixAsPerspective )
                , ( bp::arg("fovy"), bp::arg("aspectRatio"), bp::arg("zNear"), bp::arg("zFar") )
                , " Create a symmetrical perspective projection, See OpenGL gluPerspective documentation for further details.\n Aspect ratio is defined as width/height." );
        
        }
        { //::osg::Camera::setProjectionResizePolicy
        
            typedef void ( ::osg::Camera::*setProjectionResizePolicy_function_type )( ::osg::Camera::ProjectionResizePolicy ) ;
            
            Camera_exposer.def( 
                "setProjectionResizePolicy"
                , setProjectionResizePolicy_function_type( &::osg::Camera::setProjectionResizePolicy )
                , ( bp::arg("policy") )
                , " Set the policy used to determine if and how the projection matrix should be adjusted on window resizes." );
        
        }
        { //::osg::Camera::setReadBuffer
        
            typedef void ( ::osg::Camera::*setReadBuffer_function_type )( ::GLenum ) ;
            
            Camera_exposer.def( 
                "setReadBuffer"
                , setReadBuffer_function_type( &::osg::Camera::setReadBuffer )
                , ( bp::arg("buffer") )
                , " Set the read buffer for any required copy operations to use.\n Note, a buffer value of GL_NONE is used to sepecify that the rendering back-end should choose the most appropriate buffer." );
        
        }
        { //::osg::Camera::setRenderOrder
        
            typedef void ( ::osg::Camera::*setRenderOrder_function_type )( ::osg::Camera::RenderOrder,int ) ;
            
            Camera_exposer.def( 
                "setRenderOrder"
                , setRenderOrder_function_type( &::osg::Camera::setRenderOrder )
                , ( bp::arg("order"), bp::arg("orderNum")=(int)(0) )
                , " Set the rendering order of this cameras subgraph relative to any camera that this subgraph is nested within.\n For rendering to a texture, one typically uses PRE_RENDER.\n For Head Up Displays, one would typically use POST_RENDER." );
        
        }
        { //::osg::Camera::setRenderTargetImplementation
        
            typedef void ( ::osg::Camera::*setRenderTargetImplementation_function_type )( ::osg::Camera::RenderTargetImplementation ) ;
            
            Camera_exposer.def( 
                "setRenderTargetImplementation"
                , setRenderTargetImplementation_function_type( &::osg::Camera::setRenderTargetImplementation )
                , ( bp::arg("impl") )
                , " Set the render target." );
        
        }
        { //::osg::Camera::setRenderTargetImplementation
        
            typedef void ( ::osg::Camera::*setRenderTargetImplementation_function_type )( ::osg::Camera::RenderTargetImplementation,::osg::Camera::RenderTargetImplementation ) ;
            
            Camera_exposer.def( 
                "setRenderTargetImplementation"
                , setRenderTargetImplementation_function_type( &::osg::Camera::setRenderTargetImplementation )
                , ( bp::arg("impl"), bp::arg("fallback") )
                , " Set the render target and fall-back thats used if the former isnt available." );
        
        }
        { //::osg::Camera::setRenderer
        
            typedef void ( ::osg::Camera::*setRenderer_function_type )( ::osg::GraphicsOperation * ) ;
            
            Camera_exposer.def( 
                "setRenderer"
                , setRenderer_function_type( &::osg::Camera::setRenderer )
                , ( bp::arg("rc") )
                , " Set the Rendering object that is used to implement rendering of the subgraph." );
        
        }
        { //::osg::Camera::setRenderingCache
        
            typedef void ( ::osg::Camera::*setRenderingCache_function_type )( ::osg::Object * ) ;
            
            Camera_exposer.def( 
                "setRenderingCache"
                , setRenderingCache_function_type( &::osg::Camera::setRenderingCache )
                , ( bp::arg("rc") )
                , " Set the Rendering cache that is used for cached objects associated with rendering of subgraphs." );
        
        }
        { //::osg::Camera::setStats
        
            typedef void ( ::osg::Camera::*setStats_function_type )( ::osg::Stats * ) ;
            
            Camera_exposer.def( 
                "setStats"
                , setStats_function_type( &::osg::Camera::setStats )
                , ( bp::arg("stats") )
                , " Set the Stats object used for collect various frame related\n timing and scene graph stats." );
        
        }
        { //::osg::Camera::setTransformOrder
        
            typedef void ( ::osg::Camera::*setTransformOrder_function_type )( ::osg::Camera::TransformOrder ) ;
            
            Camera_exposer.def( 
                "setTransformOrder"
                , setTransformOrder_function_type( &::osg::Camera::setTransformOrder )
                , ( bp::arg("order") )
                , " Set the transformation order for world-to-local and local-to-world transformation." );
        
        }
        { //::osg::Camera::setView
        
            typedef void ( ::osg::Camera::*setView_function_type )( ::osg::View * ) ;
            
            Camera_exposer.def( 
                "setView"
                , setView_function_type( &::osg::Camera::setView )
                , ( bp::arg("view") )
                , " Set the View that this Camera is part of." );
        
        }
        { //::osg::Camera::setViewMatrix
        
            typedef void ( ::osg::Camera::*setViewMatrix_function_type )( ::osg::Matrixf const & ) ;
            
            Camera_exposer.def( 
                "setViewMatrix"
                , setViewMatrix_function_type( &::osg::Camera::setViewMatrix )
                , ( bp::arg("matrix") )
                , " Set the view matrix. Can be thought of as setting the position of the world relative to the camera in camera coordinates." );
        
        }
        { //::osg::Camera::setViewMatrix
        
            typedef void ( ::osg::Camera::*setViewMatrix_function_type )( ::osg::Matrixd const & ) ;
            
            Camera_exposer.def( 
                "setViewMatrix"
                , setViewMatrix_function_type( &::osg::Camera::setViewMatrix )
                , ( bp::arg("matrix") )
                , " Set the view matrix. Can be thought of as setting the position of the world relative to the camera in camera coordinates." );
        
        }
        { //::osg::Camera::setViewMatrixAsLookAt
        
            typedef void ( ::osg::Camera::*setViewMatrixAsLookAt_function_type )( ::osg::Vec3d const &,::osg::Vec3d const &,::osg::Vec3d const & ) ;
            
            Camera_exposer.def( 
                "setViewMatrixAsLookAt"
                , setViewMatrixAsLookAt_function_type( &::osg::Camera::setViewMatrixAsLookAt )
                , ( bp::arg("eye"), bp::arg("center"), bp::arg("up") )
                , " Set to the position and orientation of view matrix, using the same convention as gluLookAt." );
        
        }
        { //::osg::Camera::setViewport
        
            typedef void ( ::osg::Camera::*setViewport_function_type )( ::osg::Viewport * ) ;
            
            Camera_exposer.def( 
                "setViewport"
                , setViewport_function_type( &::osg::Camera::setViewport )
                , ( bp::arg("viewport") )
                , " Set the viewport of the camera to use specified osg::Viewport." );
        
        }
        { //::osg::Camera::setViewport
        
            typedef void ( ::osg::Camera::*setViewport_function_type )( int,int,int,int ) ;
            
            Camera_exposer.def( 
                "setViewport"
                , setViewport_function_type( &::osg::Camera::setViewport )
                , ( bp::arg("x"), bp::arg("y"), bp::arg("width"), bp::arg("height") )
                , " Set the viewport of the camera to specified dimensions." );
        
        }
        Camera_exposer.def_readonly( "FACE_CONTROLLED_BY_GEOMETRY_SHADER", osg::Camera::FACE_CONTROLLED_BY_GEOMETRY_SHADER );
        { //::osg::Group::addChild
        
            typedef bool ( ::osg::Group::*addChild_function_type )( ::osg::Node * ) ;
            typedef bool ( Camera_wrapper::*default_addChild_function_type )( ::osg::Node * ) ;
            
            Camera_exposer.def( 
                "addChild"
                , addChild_function_type(&::osg::Group::addChild)
                , default_addChild_function_type(&Camera_wrapper::default_addChild)
                , ( bp::arg("child") ) );
        
        }
        { //::osg::Node::asGeode
        
            typedef ::osg::Geode * ( ::osg::Node::*asGeode_function_type )(  ) ;
            typedef ::osg::Geode * ( Camera_wrapper::*default_asGeode_function_type )(  ) ;
            
            Camera_exposer.def( 
                "asGeode"
                , asGeode_function_type(&::osg::Node::asGeode)
                , default_asGeode_function_type(&Camera_wrapper::default_asGeode)
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::Node::asGeode
        
            typedef ::osg::Geode const * ( ::osg::Node::*asGeode_function_type )(  ) const;
            typedef ::osg::Geode const * ( Camera_wrapper::*default_asGeode_function_type )(  ) const;
            
            Camera_exposer.def( 
                "asGeode"
                , asGeode_function_type(&::osg::Node::asGeode)
                , default_asGeode_function_type(&Camera_wrapper::default_asGeode)
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::Group::asGroup
        
            typedef ::osg::Group * ( ::osg::Group::*asGroup_function_type )(  ) ;
            typedef ::osg::Group * ( Camera_wrapper::*default_asGroup_function_type )(  ) ;
            
            Camera_exposer.def( 
                "asGroup"
                , asGroup_function_type(&::osg::Group::asGroup)
                , default_asGroup_function_type(&Camera_wrapper::default_asGroup)
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::Group::asGroup
        
            typedef ::osg::Group const * ( ::osg::Group::*asGroup_function_type )(  ) const;
            typedef ::osg::Group const * ( Camera_wrapper::*default_asGroup_function_type )(  ) const;
            
            Camera_exposer.def( 
                "asGroup"
                , asGroup_function_type(&::osg::Group::asGroup)
                , default_asGroup_function_type(&Camera_wrapper::default_asGroup)
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::Transform::asMatrixTransform
        
            typedef ::osg::MatrixTransform * ( ::osg::Transform::*asMatrixTransform_function_type )(  ) ;
            typedef ::osg::MatrixTransform * ( Camera_wrapper::*default_asMatrixTransform_function_type )(  ) ;
            
            Camera_exposer.def( 
                "asMatrixTransform"
                , asMatrixTransform_function_type(&::osg::Transform::asMatrixTransform)
                , default_asMatrixTransform_function_type(&Camera_wrapper::default_asMatrixTransform)
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::Transform::asMatrixTransform
        
            typedef ::osg::MatrixTransform const * ( ::osg::Transform::*asMatrixTransform_function_type )(  ) const;
            typedef ::osg::MatrixTransform const * ( Camera_wrapper::*default_asMatrixTransform_function_type )(  ) const;
            
            Camera_exposer.def( 
                "asMatrixTransform"
                , asMatrixTransform_function_type(&::osg::Transform::asMatrixTransform)
                , default_asMatrixTransform_function_type(&Camera_wrapper::default_asMatrixTransform)
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::Transform::asPositionAttitudeTransform
        
            typedef ::osg::PositionAttitudeTransform * ( ::osg::Transform::*asPositionAttitudeTransform_function_type )(  ) ;
            typedef ::osg::PositionAttitudeTransform * ( Camera_wrapper::*default_asPositionAttitudeTransform_function_type )(  ) ;
            
            Camera_exposer.def( 
                "asPositionAttitudeTransform"
                , asPositionAttitudeTransform_function_type(&::osg::Transform::asPositionAttitudeTransform)
                , default_asPositionAttitudeTransform_function_type(&Camera_wrapper::default_asPositionAttitudeTransform)
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::Transform::asPositionAttitudeTransform
        
            typedef ::osg::PositionAttitudeTransform const * ( ::osg::Transform::*asPositionAttitudeTransform_function_type )(  ) const;
            typedef ::osg::PositionAttitudeTransform const * ( Camera_wrapper::*default_asPositionAttitudeTransform_function_type )(  ) const;
            
            Camera_exposer.def( 
                "asPositionAttitudeTransform"
                , asPositionAttitudeTransform_function_type(&::osg::Transform::asPositionAttitudeTransform)
                , default_asPositionAttitudeTransform_function_type(&Camera_wrapper::default_asPositionAttitudeTransform)
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::Node::asSwitch
        
            typedef ::osg::Switch * ( ::osg::Node::*asSwitch_function_type )(  ) ;
            typedef ::osg::Switch * ( Camera_wrapper::*default_asSwitch_function_type )(  ) ;
            
            Camera_exposer.def( 
                "asSwitch"
                , asSwitch_function_type(&::osg::Node::asSwitch)
                , default_asSwitch_function_type(&Camera_wrapper::default_asSwitch)
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::Node::asSwitch
        
            typedef ::osg::Switch const * ( ::osg::Node::*asSwitch_function_type )(  ) const;
            typedef ::osg::Switch const * ( Camera_wrapper::*default_asSwitch_function_type )(  ) const;
            
            Camera_exposer.def( 
                "asSwitch"
                , asSwitch_function_type(&::osg::Node::asSwitch)
                , default_asSwitch_function_type(&Camera_wrapper::default_asSwitch)
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::Transform::asTransform
        
            typedef ::osg::Transform * ( ::osg::Transform::*asTransform_function_type )(  ) ;
            typedef ::osg::Transform * ( Camera_wrapper::*default_asTransform_function_type )(  ) ;
            
            Camera_exposer.def( 
                "asTransform"
                , asTransform_function_type(&::osg::Transform::asTransform)
                , default_asTransform_function_type(&Camera_wrapper::default_asTransform)
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::Transform::asTransform
        
            typedef ::osg::Transform const * ( ::osg::Transform::*asTransform_function_type )(  ) const;
            typedef ::osg::Transform const * ( Camera_wrapper::*default_asTransform_function_type )(  ) const;
            
            Camera_exposer.def( 
                "asTransform"
                , asTransform_function_type(&::osg::Transform::asTransform)
                , default_asTransform_function_type(&Camera_wrapper::default_asTransform)
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::Node::ascend
        
            typedef void ( ::osg::Node::*ascend_function_type )( ::osg::NodeVisitor & ) ;
            typedef void ( Camera_wrapper::*default_ascend_function_type )( ::osg::NodeVisitor & ) ;
            
            Camera_exposer.def( 
                "ascend"
                , ascend_function_type(&::osg::Node::ascend)
                , default_ascend_function_type(&Camera_wrapper::default_ascend)
                , ( bp::arg("nv") ) );
        
        }
        { //::osg::Transform::computeBound
        
            typedef ::osg::BoundingSphere ( ::osg::Transform::*computeBound_function_type )(  ) const;
            typedef ::osg::BoundingSphere ( Camera_wrapper::*default_computeBound_function_type )(  ) const;
            
            Camera_exposer.def( 
                "computeBound"
                , computeBound_function_type(&::osg::Transform::computeBound)
                , default_computeBound_function_type(&Camera_wrapper::default_computeBound) );
        
        }
        { //::osg::CullSettings::inheritCullSettings
        
            typedef void ( ::osg::CullSettings::*inheritCullSettings_function_type )( ::osg::CullSettings const & ) ;
            typedef void ( Camera_wrapper::*default_inheritCullSettings_function_type )( ::osg::CullSettings const & ) ;
            
            Camera_exposer.def( 
                "inheritCullSettings"
                , inheritCullSettings_function_type(&::osg::CullSettings::inheritCullSettings)
                , default_inheritCullSettings_function_type(&Camera_wrapper::default_inheritCullSettings)
                , ( bp::arg("settings") ) );
        
        }
        { //::osg::Group::insertChild
        
            typedef bool ( ::osg::Group::*insertChild_function_type )( unsigned int,::osg::Node * ) ;
            typedef bool ( Camera_wrapper::*default_insertChild_function_type )( unsigned int,::osg::Node * ) ;
            
            Camera_exposer.def( 
                "insertChild"
                , insertChild_function_type(&::osg::Group::insertChild)
                , default_insertChild_function_type(&Camera_wrapper::default_insertChild)
                , ( bp::arg("index"), bp::arg("child") ) );
        
        }
        { //::osg::Group::removeChildren
        
            typedef bool ( ::osg::Group::*removeChildren_function_type )( unsigned int,unsigned int ) ;
            typedef bool ( Camera_wrapper::*default_removeChildren_function_type )( unsigned int,unsigned int ) ;
            
            Camera_exposer.def( 
                "removeChildren"
                , removeChildren_function_type(&::osg::Group::removeChildren)
                , default_removeChildren_function_type(&Camera_wrapper::default_removeChildren)
                , ( bp::arg("pos"), bp::arg("numChildrenToRemove") ) );
        
        }
        { //::osg::Group::replaceChild
        
            typedef bool ( ::osg::Group::*replaceChild_function_type )( ::osg::Node *,::osg::Node * ) ;
            typedef bool ( Camera_wrapper::*default_replaceChild_function_type )( ::osg::Node *,::osg::Node * ) ;
            
            Camera_exposer.def( 
                "replaceChild"
                , replaceChild_function_type(&::osg::Group::replaceChild)
                , default_replaceChild_function_type(&Camera_wrapper::default_replaceChild)
                , ( bp::arg("origChild"), bp::arg("newChild") ) );
        
        }
        { //::osg::Group::setChild
        
            typedef bool ( ::osg::Group::*setChild_function_type )( unsigned int,::osg::Node * ) ;
            typedef bool ( Camera_wrapper::*default_setChild_function_type )( unsigned int,::osg::Node * ) ;
            
            Camera_exposer.def( 
                "setChild"
                , setChild_function_type(&::osg::Group::setChild)
                , default_setChild_function_type(&Camera_wrapper::default_setChild)
                , ( bp::arg("i"), bp::arg("node") ) );
        
        }
        { //::osg::CullSettings::setDefaults
        
            typedef void ( ::osg::CullSettings::*setDefaults_function_type )(  ) ;
            typedef void ( Camera_wrapper::*default_setDefaults_function_type )(  ) ;
            
            Camera_exposer.def( 
                "setDefaults"
                , setDefaults_function_type(&::osg::CullSettings::setDefaults)
                , default_setDefaults_function_type(&Camera_wrapper::default_setDefaults) );
        
        }
        { //::osg::Group::setThreadSafeRefUnref
        
            typedef void ( ::osg::Group::*setThreadSafeRefUnref_function_type )( bool ) ;
            typedef void ( Camera_wrapper::*default_setThreadSafeRefUnref_function_type )( bool ) ;
            
            Camera_exposer.def( 
                "setThreadSafeRefUnref"
                , setThreadSafeRefUnref_function_type(&::osg::Group::setThreadSafeRefUnref)
                , default_setThreadSafeRefUnref_function_type(&Camera_wrapper::default_setThreadSafeRefUnref)
                , ( bp::arg("threadSafe") ) );
        
        }
        { //::osg::Group::traverse
        
            typedef void ( ::osg::Group::*traverse_function_type )( ::osg::NodeVisitor & ) ;
            typedef void ( Camera_wrapper::*default_traverse_function_type )( ::osg::NodeVisitor & ) ;
            
            Camera_exposer.def( 
                "traverse"
                , traverse_function_type(&::osg::Group::traverse)
                , default_traverse_function_type(&Camera_wrapper::default_traverse)
                , ( bp::arg("nv") ) );
        
        }
    }

}
