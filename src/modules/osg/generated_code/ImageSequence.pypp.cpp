// This file has been generated by Py++.

#include "boost/python.hpp"
#include "wrap_osg.h"
#include "wrap_referenced.h"
#include "ImageSequence.pypp.hpp"

namespace bp = boost::python;

struct ImageSequence_wrapper : osg::ImageSequence, bp::wrapper< osg::ImageSequence > {

    ImageSequence_wrapper( )
    : osg::ImageSequence( )
      , bp::wrapper< osg::ImageSequence >(){
        // null constructor
    
    }

    virtual char const * className(  ) const  {
        if( bp::override func_className = this->get_override( "className" ) )
            return func_className(  );
        else{
            return this->osg::ImageSequence::className(  );
        }
    }
    
    char const * default_className(  ) const  {
        return osg::ImageSequence::className( );
    }

    virtual ::osg::Object * clone( ::osg::CopyOp const & copyop ) const  {
        if( bp::override func_clone = this->get_override( "clone" ) )
            return func_clone( boost::ref(copyop) );
        else{
            return this->osg::ImageSequence::clone( boost::ref(copyop) );
        }
    }
    
    ::osg::Object * default_clone( ::osg::CopyOp const & copyop ) const  {
        return osg::ImageSequence::clone( boost::ref(copyop) );
    }

    virtual ::osg::Object * cloneType(  ) const  {
        if( bp::override func_cloneType = this->get_override( "cloneType" ) )
            return func_cloneType(  );
        else{
            return this->osg::ImageSequence::cloneType(  );
        }
    }
    
    ::osg::Object * default_cloneType(  ) const  {
        return osg::ImageSequence::cloneType( );
    }

    virtual double getLength(  ) const  {
        if( bp::override func_getLength = this->get_override( "getLength" ) )
            return func_getLength(  );
        else{
            return this->osg::ImageSequence::getLength(  );
        }
    }
    
    double default_getLength(  ) const  {
        return osg::ImageSequence::getLength( );
    }

    virtual double getReferenceTime(  ) const  {
        if( bp::override func_getReferenceTime = this->get_override( "getReferenceTime" ) )
            return func_getReferenceTime(  );
        else{
            return this->osg::ImageSequence::getReferenceTime(  );
        }
    }
    
    double default_getReferenceTime(  ) const  {
        return osg::ImageSequence::getReferenceTime( );
    }

    virtual double getTimeMultiplier(  ) const  {
        if( bp::override func_getTimeMultiplier = this->get_override( "getTimeMultiplier" ) )
            return func_getTimeMultiplier(  );
        else{
            return this->osg::ImageSequence::getTimeMultiplier(  );
        }
    }
    
    double default_getTimeMultiplier(  ) const  {
        return osg::ImageSequence::getTimeMultiplier( );
    }

    virtual bool isSameKindAs( ::osg::Object const * obj ) const  {
        if( bp::override func_isSameKindAs = this->get_override( "isSameKindAs" ) )
            return func_isSameKindAs( boost::python::ptr(obj) );
        else{
            return this->osg::ImageSequence::isSameKindAs( boost::python::ptr(obj) );
        }
    }
    
    bool default_isSameKindAs( ::osg::Object const * obj ) const  {
        return osg::ImageSequence::isSameKindAs( boost::python::ptr(obj) );
    }

    virtual char const * libraryName(  ) const  {
        if( bp::override func_libraryName = this->get_override( "libraryName" ) )
            return func_libraryName(  );
        else{
            return this->osg::ImageSequence::libraryName(  );
        }
    }
    
    char const * default_libraryName(  ) const  {
        return osg::ImageSequence::libraryName( );
    }

    virtual void pause(  ) {
        if( bp::override func_pause = this->get_override( "pause" ) )
            func_pause(  );
        else{
            this->osg::ImageSequence::pause(  );
        }
    }
    
    void default_pause(  ) {
        osg::ImageSequence::pause( );
    }

    virtual void play(  ) {
        if( bp::override func_play = this->get_override( "play" ) )
            func_play(  );
        else{
            this->osg::ImageSequence::play(  );
        }
    }
    
    void default_play(  ) {
        osg::ImageSequence::play( );
    }

    virtual bool requiresUpdateCall(  ) const  {
        if( bp::override func_requiresUpdateCall = this->get_override( "requiresUpdateCall" ) )
            return func_requiresUpdateCall(  );
        else{
            return this->osg::ImageSequence::requiresUpdateCall(  );
        }
    }
    
    bool default_requiresUpdateCall(  ) const  {
        return osg::ImageSequence::requiresUpdateCall( );
    }

    virtual void rewind(  ) {
        if( bp::override func_rewind = this->get_override( "rewind" ) )
            func_rewind(  );
        else{
            this->osg::ImageSequence::rewind(  );
        }
    }
    
    void default_rewind(  ) {
        osg::ImageSequence::rewind( );
    }

    virtual void seek( double time ) {
        if( bp::override func_seek = this->get_override( "seek" ) )
            func_seek( time );
        else{
            this->osg::ImageSequence::seek( time );
        }
    }
    
    void default_seek( double time ) {
        osg::ImageSequence::seek( time );
    }

    virtual void setReferenceTime( double t ) {
        if( bp::override func_setReferenceTime = this->get_override( "setReferenceTime" ) )
            func_setReferenceTime( t );
        else{
            this->osg::ImageSequence::setReferenceTime( t );
        }
    }
    
    void default_setReferenceTime( double t ) {
        osg::ImageSequence::setReferenceTime( t );
    }

    virtual void setTimeMultiplier( double tm ) {
        if( bp::override func_setTimeMultiplier = this->get_override( "setTimeMultiplier" ) )
            func_setTimeMultiplier( tm );
        else{
            this->osg::ImageSequence::setTimeMultiplier( tm );
        }
    }
    
    void default_setTimeMultiplier( double tm ) {
        osg::ImageSequence::setTimeMultiplier( tm );
    }

    virtual void update( ::osg::NodeVisitor * nv ) {
        if( bp::override func_update = this->get_override( "update" ) )
            func_update( boost::python::ptr(nv) );
        else{
            this->osg::ImageSequence::update( boost::python::ptr(nv) );
        }
    }
    
    void default_update( ::osg::NodeVisitor * nv ) {
        osg::ImageSequence::update( boost::python::ptr(nv) );
    }

    virtual void allocateImage( int s, int t, int r, ::GLenum pixelFormat, ::GLenum type, int packing=1 ) {
        if( bp::override func_allocateImage = this->get_override( "allocateImage" ) )
            func_allocateImage( s, t, r, pixelFormat, type, packing );
        else{
            this->osg::Image::allocateImage( s, t, r, pixelFormat, type, packing );
        }
    }
    
    void default_allocateImage( int s, int t, int r, ::GLenum pixelFormat, ::GLenum type, int packing=1 ) {
        osg::Image::allocateImage( s, t, r, pixelFormat, type, packing );
    }

    virtual ::osg::Array * asArray(  ) {
        if( bp::override func_asArray = this->get_override( "asArray" ) )
            return func_asArray(  );
        else{
            return this->osg::BufferData::asArray(  );
        }
    }
    
    ::osg::Array * default_asArray(  ) {
        return osg::BufferData::asArray( );
    }

    virtual ::osg::Array const * asArray(  ) const  {
        if( bp::override func_asArray = this->get_override( "asArray" ) )
            return func_asArray(  );
        else{
            return this->osg::BufferData::asArray(  );
        }
    }
    
    ::osg::Array const * default_asArray(  ) const  {
        return osg::BufferData::asArray( );
    }

    virtual ::osg::Image * asImage(  ) {
        if( bp::override func_asImage = this->get_override( "asImage" ) )
            return func_asImage(  );
        else{
            return this->osg::Image::asImage(  );
        }
    }
    
    ::osg::Image * default_asImage(  ) {
        return osg::Image::asImage( );
    }

    virtual ::osg::Image const * asImage(  ) const  {
        if( bp::override func_asImage = this->get_override( "asImage" ) )
            return func_asImage(  );
        else{
            return this->osg::Image::asImage(  );
        }
    }
    
    ::osg::Image const * default_asImage(  ) const  {
        return osg::Image::asImage( );
    }

    virtual void copySubImage( int s_offset, int t_offset, int r_offset, ::osg::Image const * source ) {
        if( bp::override func_copySubImage = this->get_override( "copySubImage" ) )
            func_copySubImage( s_offset, t_offset, r_offset, boost::python::ptr(source) );
        else{
            this->osg::Image::copySubImage( s_offset, t_offset, r_offset, boost::python::ptr(source) );
        }
    }
    
    void default_copySubImage( int s_offset, int t_offset, int r_offset, ::osg::Image const * source ) {
        osg::Image::copySubImage( s_offset, t_offset, r_offset, boost::python::ptr(source) );
    }

    virtual ::osg::Texture * createSuitableTexture(  ) {
        if( bp::override func_createSuitableTexture = this->get_override( "createSuitableTexture" ) )
            return func_createSuitableTexture(  );
        else{
            return this->osg::ImageStream::createSuitableTexture(  );
        }
    }
    
    ::osg::Texture * default_createSuitableTexture(  ) {
        return osg::ImageStream::createSuitableTexture( );
    }

    virtual float getAudioBalance(  ) {
        if( bp::override func_getAudioBalance = this->get_override( "getAudioBalance" ) )
            return func_getAudioBalance(  );
        else{
            return this->osg::ImageStream::getAudioBalance(  );
        }
    }
    
    float default_getAudioBalance(  ) {
        return osg::ImageStream::getAudioBalance( );
    }

    virtual double getCreationTime(  ) const  {
        if( bp::override func_getCreationTime = this->get_override( "getCreationTime" ) )
            return func_getCreationTime(  );
        else{
            return this->osg::ImageStream::getCreationTime(  );
        }
    }
    
    double default_getCreationTime(  ) const  {
        return osg::ImageStream::getCreationTime( );
    }

    virtual double getCurrentTime(  ) const  {
        if( bp::override func_getCurrentTime = this->get_override( "getCurrentTime" ) )
            return func_getCurrentTime(  );
        else{
            return this->osg::ImageStream::getCurrentTime(  );
        }
    }
    
    double default_getCurrentTime(  ) const  {
        return osg::ImageStream::getCurrentTime( );
    }

    virtual ::GLvoid const * getDataPointer(  ) const  {
        if( bp::override func_getDataPointer = this->get_override( "getDataPointer" ) )
            return func_getDataPointer(  );
        else{
            return this->osg::Image::getDataPointer(  );
        }
    }
    
    ::GLvoid const * default_getDataPointer(  ) const  {
        return osg::Image::getDataPointer( );
    }

    virtual double getFrameRate(  ) const  {
        if( bp::override func_getFrameRate = this->get_override( "getFrameRate" ) )
            return func_getFrameRate(  );
        else{
            return this->osg::ImageStream::getFrameRate(  );
        }
    }
    
    double default_getFrameRate(  ) const  {
        return osg::ImageStream::getFrameRate( );
    }

    virtual unsigned int getTotalDataSize(  ) const  {
        if( bp::override func_getTotalDataSize = this->get_override( "getTotalDataSize" ) )
            return func_getTotalDataSize(  );
        else{
            return this->osg::Image::getTotalDataSize(  );
        }
    }
    
    unsigned int default_getTotalDataSize(  ) const  {
        return osg::Image::getTotalDataSize( );
    }

    virtual float getVolume(  ) const  {
        if( bp::override func_getVolume = this->get_override( "getVolume" ) )
            return func_getVolume(  );
        else{
            return this->osg::ImageStream::getVolume(  );
        }
    }
    
    float default_getVolume(  ) const  {
        return osg::ImageStream::getVolume( );
    }

    virtual bool isImageTranslucent(  ) const  {
        if( bp::override func_isImageTranslucent = this->get_override( "isImageTranslucent" ) )
            return func_isImageTranslucent(  );
        else{
            return this->osg::Image::isImageTranslucent(  );
        }
    }
    
    bool default_isImageTranslucent(  ) const  {
        return osg::Image::isImageTranslucent( );
    }

    virtual void quit( bool arg0=true ) {
        if( bp::override func_quit = this->get_override( "quit" ) )
            func_quit( arg0 );
        else{
            this->osg::ImageStream::quit( arg0 );
        }
    }
    
    void default_quit( bool arg0=true ) {
        osg::ImageStream::quit( arg0 );
    }

    virtual void readImageFromCurrentTexture( unsigned int contextID, bool copyMipMapsIfAvailable, ::GLenum type=5121, unsigned int face=0 ) {
        if( bp::override func_readImageFromCurrentTexture = this->get_override( "readImageFromCurrentTexture" ) )
            func_readImageFromCurrentTexture( contextID, copyMipMapsIfAvailable, type, face );
        else{
            this->osg::Image::readImageFromCurrentTexture( contextID, copyMipMapsIfAvailable, type, face );
        }
    }
    
    void default_readImageFromCurrentTexture( unsigned int contextID, bool copyMipMapsIfAvailable, ::GLenum type=5121, unsigned int face=0 ) {
        osg::Image::readImageFromCurrentTexture( contextID, copyMipMapsIfAvailable, type, face );
    }

    virtual void readPixels( int x, int y, int width, int height, ::GLenum pixelFormat, ::GLenum type, int packing=1 ) {
        if( bp::override func_readPixels = this->get_override( "readPixels" ) )
            func_readPixels( x, y, width, height, pixelFormat, type, packing );
        else{
            this->osg::Image::readPixels( x, y, width, height, pixelFormat, type, packing );
        }
    }
    
    void default_readPixels( int x, int y, int width, int height, ::GLenum pixelFormat, ::GLenum type, int packing=1 ) {
        osg::Image::readPixels( x, y, width, height, pixelFormat, type, packing );
    }

    virtual void resizeGLObjectBuffers( unsigned int maxSize ) {
        if( bp::override func_resizeGLObjectBuffers = this->get_override( "resizeGLObjectBuffers" ) )
            func_resizeGLObjectBuffers( maxSize );
        else{
            this->osg::BufferData::resizeGLObjectBuffers( maxSize );
        }
    }
    
    void default_resizeGLObjectBuffers( unsigned int maxSize ) {
        osg::BufferData::resizeGLObjectBuffers( maxSize );
    }

    virtual void scaleImage( int s, int t, int r, ::GLenum newDataType ) {
        if( bp::override func_scaleImage = this->get_override( "scaleImage" ) )
            func_scaleImage( s, t, r, newDataType );
        else{
            this->osg::Image::scaleImage( s, t, r, newDataType );
        }
    }
    
    void default_scaleImage( int s, int t, int r, ::GLenum newDataType ) {
        osg::Image::scaleImage( s, t, r, newDataType );
    }

    virtual bool sendFocusHint( bool arg0 ) {
        if( bp::override func_sendFocusHint = this->get_override( "sendFocusHint" ) )
            return func_sendFocusHint( arg0 );
        else{
            return this->osg::Image::sendFocusHint( arg0 );
        }
    }
    
    bool default_sendFocusHint( bool arg0 ) {
        return osg::Image::sendFocusHint( arg0 );
    }

    virtual bool sendKeyEvent( int arg0, bool arg1 ) {
        if( bp::override func_sendKeyEvent = this->get_override( "sendKeyEvent" ) )
            return func_sendKeyEvent( arg0, arg1 );
        else{
            return this->osg::Image::sendKeyEvent( arg0, arg1 );
        }
    }
    
    bool default_sendKeyEvent( int arg0, bool arg1 ) {
        return osg::Image::sendKeyEvent( arg0, arg1 );
    }

    virtual bool sendPointerEvent( int arg0, int arg1, int arg2 ) {
        if( bp::override func_sendPointerEvent = this->get_override( "sendPointerEvent" ) )
            return func_sendPointerEvent( arg0, arg1, arg2 );
        else{
            return this->osg::Image::sendPointerEvent( arg0, arg1, arg2 );
        }
    }
    
    bool default_sendPointerEvent( int arg0, int arg1, int arg2 ) {
        return osg::Image::sendPointerEvent( arg0, arg1, arg2 );
    }

    virtual void setAudioBalance( float arg0 ) {
        if( bp::override func_setAudioBalance = this->get_override( "setAudioBalance" ) )
            func_setAudioBalance( arg0 );
        else{
            this->osg::ImageStream::setAudioBalance( arg0 );
        }
    }
    
    void default_setAudioBalance( float arg0 ) {
        osg::ImageStream::setAudioBalance( arg0 );
    }

    virtual void setFrameLastRendered( ::osg::FrameStamp const * arg0 ) {
        if( bp::override func_setFrameLastRendered = this->get_override( "setFrameLastRendered" ) )
            func_setFrameLastRendered( boost::python::ptr(arg0) );
        else{
            this->osg::Image::setFrameLastRendered( boost::python::ptr(arg0) );
        }
    }
    
    void default_setFrameLastRendered( ::osg::FrameStamp const * arg0 ) {
        osg::Image::setFrameLastRendered( boost::python::ptr(arg0) );
    }

    virtual void setImage( int s, int t, int r, ::GLint internalTextureformat, ::GLenum pixelFormat, ::GLenum type, unsigned char * data, ::osg::Image::AllocationMode mode, int packing=1, int rowLength=0 ) {
        if( bp::override func_setImage = this->get_override( "setImage" ) )
            func_setImage( s, t, r, internalTextureformat, pixelFormat, type, data, mode, packing, rowLength );
        else{
            this->osg::Image::setImage( s, t, r, internalTextureformat, pixelFormat, type, data, mode, packing, rowLength );
        }
    }
    
    void default_setImage( int s, int t, int r, ::GLint internalTextureformat, ::GLenum pixelFormat, ::GLenum type, unsigned char * data, ::osg::Image::AllocationMode mode, int packing=1, int rowLength=0 ) {
        osg::Image::setImage( s, t, r, internalTextureformat, pixelFormat, type, data, mode, packing, rowLength );
    }

    virtual void setVolume( float arg0 ) {
        if( bp::override func_setVolume = this->get_override( "setVolume" ) )
            func_setVolume( arg0 );
        else{
            this->osg::ImageStream::setVolume( arg0 );
        }
    }
    
    void default_setVolume( float arg0 ) {
        osg::ImageStream::setVolume( arg0 );
    }

};

void register_ImageSequence_class(){

    { //::osg::ImageSequence
        typedef bp::class_< ImageSequence_wrapper, bp::bases< osg::ImageStream >, osg::ref_ptr< ::osg::ImageSequence >, boost::noncopyable > ImageSequence_exposer_t;
        ImageSequence_exposer_t ImageSequence_exposer = ImageSequence_exposer_t( "ImageSequence", "\n Image Buffer class.\n", bp::no_init );
        bp::scope ImageSequence_scope( ImageSequence_exposer );
        bp::enum_< osg::ImageSequence::Mode>("Mode")
            .value("PRE_LOAD_ALL_IMAGES", osg::ImageSequence::PRE_LOAD_ALL_IMAGES)
            .value("PAGE_AND_RETAIN_IMAGES", osg::ImageSequence::PAGE_AND_RETAIN_IMAGES)
            .value("PAGE_AND_DISCARD_USED_IMAGES", osg::ImageSequence::PAGE_AND_DISCARD_USED_IMAGES)
            .value("LOAD_AND_RETAIN_IN_UPDATE_TRAVERSAL", osg::ImageSequence::LOAD_AND_RETAIN_IN_UPDATE_TRAVERSAL)
            .value("LOAD_AND_DISCARD_IN_UPDATE_TRAVERSAL", osg::ImageSequence::LOAD_AND_DISCARD_IN_UPDATE_TRAVERSAL)
            .export_values()
            ;
        { //::osg::ImageSequence::ImageData
            typedef bp::class_< osg::ImageSequence::ImageData > ImageData_exposer_t;
            ImageData_exposer_t ImageData_exposer = ImageData_exposer_t( "ImageData", bp::init< >() );
            bp::scope ImageData_scope( ImageData_exposer );
            ImageData_exposer.def( bp::init< osg::ImageSequence::ImageData const & >(( bp::arg("id") )) );
            ImageData_exposer.def_readwrite( "_filename", &osg::ImageSequence::ImageData::_filename );
            ImageData_exposer.def_readwrite( "_image", &osg::ImageSequence::ImageData::_image );
            ImageData_exposer.def_readwrite( "_imageRequest", &osg::ImageSequence::ImageData::_imageRequest );
        }
        ImageSequence_exposer.def( bp::init< >("\n Image Buffer class.\n") );
        { //::osg::ImageSequence::addImage
        
            typedef void ( ::osg::ImageSequence::*addImage_function_type )( ::osg::Image * ) ;
            
            ImageSequence_exposer.def( 
                "addImage"
                , addImage_function_type( &::osg::ImageSequence::addImage )
                , ( bp::arg("image") ) );
        
        }
        { //::osg::ImageSequence::addImageFile
        
            typedef void ( ::osg::ImageSequence::*addImageFile_function_type )( ::std::string const & ) ;
            
            ImageSequence_exposer.def( 
                "addImageFile"
                , addImageFile_function_type( &::osg::ImageSequence::addImageFile )
                , ( bp::arg("fileName") ) );
        
        }
        { //::osg::ImageSequence::className
        
            typedef char const * ( ::osg::ImageSequence::*className_function_type )(  ) const;
            typedef char const * ( ImageSequence_wrapper::*default_className_function_type )(  ) const;
            
            ImageSequence_exposer.def( 
                "className"
                , className_function_type(&::osg::ImageSequence::className)
                , default_className_function_type(&ImageSequence_wrapper::default_className) );
        
        }
        { //::osg::ImageSequence::clone
        
            typedef ::osg::Object * ( ::osg::ImageSequence::*clone_function_type )( ::osg::CopyOp const & ) const;
            typedef ::osg::Object * ( ImageSequence_wrapper::*default_clone_function_type )( ::osg::CopyOp const & ) const;
            
            ImageSequence_exposer.def( 
                "clone"
                , clone_function_type(&::osg::ImageSequence::clone)
                , default_clone_function_type(&ImageSequence_wrapper::default_clone)
                , ( bp::arg("copyop") )
                , bp::return_value_policy< bp::reference_existing_object >() );
        
        }
        { //::osg::ImageSequence::cloneType
        
            typedef ::osg::Object * ( ::osg::ImageSequence::*cloneType_function_type )(  ) const;
            typedef ::osg::Object * ( ImageSequence_wrapper::*default_cloneType_function_type )(  ) const;
            
            ImageSequence_exposer.def( 
                "cloneType"
                , cloneType_function_type(&::osg::ImageSequence::cloneType)
                , default_cloneType_function_type(&ImageSequence_wrapper::default_cloneType)
                , bp::return_value_policy< bp::reference_existing_object >() );
        
        }
        { //::osg::ImageSequence::getImage
        
            typedef ::osg::Image * ( ::osg::ImageSequence::*getImage_function_type )( unsigned int ) ;
            
            ImageSequence_exposer.def( 
                "getImage"
                , getImage_function_type( &::osg::ImageSequence::getImage )
                , ( bp::arg("pos") )
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::ImageSequence::getImage
        
            typedef ::osg::Image const * ( ::osg::ImageSequence::*getImage_function_type )( unsigned int ) const;
            
            ImageSequence_exposer.def( 
                "getImage"
                , getImage_function_type( &::osg::ImageSequence::getImage )
                , ( bp::arg("pos") )
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::ImageSequence::getImageDataList
        
            typedef ::std::vector< osg::ImageSequence::ImageData > & ( ::osg::ImageSequence::*getImageDataList_function_type )(  ) ;
            
            ImageSequence_exposer.def( 
                "getImageDataList"
                , getImageDataList_function_type( &::osg::ImageSequence::getImageDataList )
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::ImageSequence::getImageDataList
        
            typedef ::std::vector< osg::ImageSequence::ImageData > const & ( ::osg::ImageSequence::*getImageDataList_function_type )(  ) const;
            
            ImageSequence_exposer.def( 
                "getImageDataList"
                , getImageDataList_function_type( &::osg::ImageSequence::getImageDataList )
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::ImageSequence::getImageFile
        
            typedef ::std::string ( ::osg::ImageSequence::*getImageFile_function_type )( unsigned int ) const;
            
            ImageSequence_exposer.def( 
                "getImageFile"
                , getImageFile_function_type( &::osg::ImageSequence::getImageFile )
                , ( bp::arg("pos") ) );
        
        }
        { //::osg::ImageSequence::getLength
        
            typedef double ( ::osg::ImageSequence::*getLength_function_type )(  ) const;
            typedef double ( ImageSequence_wrapper::*default_getLength_function_type )(  ) const;
            
            ImageSequence_exposer.def( 
                "getLength"
                , getLength_function_type(&::osg::ImageSequence::getLength)
                , default_getLength_function_type(&ImageSequence_wrapper::default_getLength) );
        
        }
        { //::osg::ImageSequence::getMode
        
            typedef ::osg::ImageSequence::Mode ( ::osg::ImageSequence::*getMode_function_type )(  ) const;
            
            ImageSequence_exposer.def( 
                "getMode"
                , getMode_function_type( &::osg::ImageSequence::getMode ) );
        
        }
        { //::osg::ImageSequence::getNumImageData
        
            typedef unsigned int ( ::osg::ImageSequence::*getNumImageData_function_type )(  ) const;
            
            ImageSequence_exposer.def( 
                "getNumImageData"
                , getNumImageData_function_type( &::osg::ImageSequence::getNumImageData ) );
        
        }
        { //::osg::ImageSequence::getReadOptions
        
            typedef ::osg::Referenced * ( ::osg::ImageSequence::*getReadOptions_function_type )(  ) ;
            
            ImageSequence_exposer.def( 
                "getReadOptions"
                , getReadOptions_function_type( &::osg::ImageSequence::getReadOptions )
                , bp::return_internal_reference< >()
                , " Get the optional osgDB::Options object used when reading images." );
        
        }
        { //::osg::ImageSequence::getReadOptions
        
            typedef ::osg::Referenced const * ( ::osg::ImageSequence::*getReadOptions_function_type )(  ) const;
            
            ImageSequence_exposer.def( 
                "getReadOptions"
                , getReadOptions_function_type( &::osg::ImageSequence::getReadOptions )
                , bp::return_internal_reference< >()
                , " Get the optional osgDB::Options object used when reading images." );
        
        }
        { //::osg::ImageSequence::getReferenceTime
        
            typedef double ( ::osg::ImageSequence::*getReferenceTime_function_type )(  ) const;
            typedef double ( ImageSequence_wrapper::*default_getReferenceTime_function_type )(  ) const;
            
            ImageSequence_exposer.def( 
                "getReferenceTime"
                , getReferenceTime_function_type(&::osg::ImageSequence::getReferenceTime)
                , default_getReferenceTime_function_type(&ImageSequence_wrapper::default_getReferenceTime) );
        
        }
        { //::osg::ImageSequence::getTimeMultiplier
        
            typedef double ( ::osg::ImageSequence::*getTimeMultiplier_function_type )(  ) const;
            typedef double ( ImageSequence_wrapper::*default_getTimeMultiplier_function_type )(  ) const;
            
            ImageSequence_exposer.def( 
                "getTimeMultiplier"
                , getTimeMultiplier_function_type(&::osg::ImageSequence::getTimeMultiplier)
                , default_getTimeMultiplier_function_type(&ImageSequence_wrapper::default_getTimeMultiplier) );
        
        }
        { //::osg::ImageSequence::isSameKindAs
        
            typedef bool ( ::osg::ImageSequence::*isSameKindAs_function_type )( ::osg::Object const * ) const;
            typedef bool ( ImageSequence_wrapper::*default_isSameKindAs_function_type )( ::osg::Object const * ) const;
            
            ImageSequence_exposer.def( 
                "isSameKindAs"
                , isSameKindAs_function_type(&::osg::ImageSequence::isSameKindAs)
                , default_isSameKindAs_function_type(&ImageSequence_wrapper::default_isSameKindAs)
                , ( bp::arg("obj") ) );
        
        }
        { //::osg::ImageSequence::libraryName
        
            typedef char const * ( ::osg::ImageSequence::*libraryName_function_type )(  ) const;
            typedef char const * ( ImageSequence_wrapper::*default_libraryName_function_type )(  ) const;
            
            ImageSequence_exposer.def( 
                "libraryName"
                , libraryName_function_type(&::osg::ImageSequence::libraryName)
                , default_libraryName_function_type(&ImageSequence_wrapper::default_libraryName) );
        
        }
        { //::osg::ImageSequence::pause
        
            typedef void ( ::osg::ImageSequence::*pause_function_type )(  ) ;
            typedef void ( ImageSequence_wrapper::*default_pause_function_type )(  ) ;
            
            ImageSequence_exposer.def( 
                "pause"
                , pause_function_type(&::osg::ImageSequence::pause)
                , default_pause_function_type(&ImageSequence_wrapper::default_pause) );
        
        }
        { //::osg::ImageSequence::play
        
            typedef void ( ::osg::ImageSequence::*play_function_type )(  ) ;
            typedef void ( ImageSequence_wrapper::*default_play_function_type )(  ) ;
            
            ImageSequence_exposer.def( 
                "play"
                , play_function_type(&::osg::ImageSequence::play)
                , default_play_function_type(&ImageSequence_wrapper::default_play) );
        
        }
        { //::osg::ImageSequence::requiresUpdateCall
        
            typedef bool ( ::osg::ImageSequence::*requiresUpdateCall_function_type )(  ) const;
            typedef bool ( ImageSequence_wrapper::*default_requiresUpdateCall_function_type )(  ) const;
            
            ImageSequence_exposer.def( 
                "requiresUpdateCall"
                , requiresUpdateCall_function_type(&::osg::ImageSequence::requiresUpdateCall)
                , default_requiresUpdateCall_function_type(&ImageSequence_wrapper::default_requiresUpdateCall) );
        
        }
        { //::osg::ImageSequence::rewind
        
            typedef void ( ::osg::ImageSequence::*rewind_function_type )(  ) ;
            typedef void ( ImageSequence_wrapper::*default_rewind_function_type )(  ) ;
            
            ImageSequence_exposer.def( 
                "rewind"
                , rewind_function_type(&::osg::ImageSequence::rewind)
                , default_rewind_function_type(&ImageSequence_wrapper::default_rewind) );
        
        }
        { //::osg::ImageSequence::seek
        
            typedef void ( ::osg::ImageSequence::*seek_function_type )( double ) ;
            typedef void ( ImageSequence_wrapper::*default_seek_function_type )( double ) ;
            
            ImageSequence_exposer.def( 
                "seek"
                , seek_function_type(&::osg::ImageSequence::seek)
                , default_seek_function_type(&ImageSequence_wrapper::default_seek)
                , ( bp::arg("time") ) );
        
        }
        { //::osg::ImageSequence::setImage
        
            typedef void ( ::osg::ImageSequence::*setImage_function_type )( int,int,int,::GLint,::GLenum,::GLenum,unsigned char *,::osg::Image::AllocationMode,int ) ;
            
            ImageSequence_exposer.def( 
                "setImage"
                , setImage_function_type( &::osg::ImageSequence::setImage )
                , ( bp::arg("s"), bp::arg("t"), bp::arg("r"), bp::arg("internalTextureformat"), bp::arg("pixelFormat"), bp::arg("type"), bp::arg("data"), bp::arg("mode"), bp::arg("packing")=(int)(1) ) );
        
        }
        { //::osg::ImageSequence::setImage
        
            typedef void ( ::osg::ImageSequence::*setImage_function_type )( unsigned int,::osg::Image * ) ;
            
            ImageSequence_exposer.def( 
                "setImage"
                , setImage_function_type( &::osg::ImageSequence::setImage )
                , ( bp::arg("pos"), bp::arg("image") ) );
        
        }
        { //::osg::ImageSequence::setImageFile
        
            typedef void ( ::osg::ImageSequence::*setImageFile_function_type )( unsigned int,::std::string const & ) ;
            
            ImageSequence_exposer.def( 
                "setImageFile"
                , setImageFile_function_type( &::osg::ImageSequence::setImageFile )
                , ( bp::arg("pos"), bp::arg("fileName") ) );
        
        }
        { //::osg::ImageSequence::setLength
        
            typedef void ( ::osg::ImageSequence::*setLength_function_type )( double ) ;
            
            ImageSequence_exposer.def( 
                "setLength"
                , setLength_function_type( &::osg::ImageSequence::setLength )
                , ( bp::arg("length") ) );
        
        }
        { //::osg::ImageSequence::setMode
        
            typedef void ( ::osg::ImageSequence::*setMode_function_type )( ::osg::ImageSequence::Mode ) ;
            
            ImageSequence_exposer.def( 
                "setMode"
                , setMode_function_type( &::osg::ImageSequence::setMode )
                , ( bp::arg("mode") ) );
        
        }
        { //::osg::ImageSequence::setReadOptions
        
            typedef void ( ::osg::ImageSequence::*setReadOptions_function_type )( ::osg::Referenced * ) ;
            
            ImageSequence_exposer.def( 
                "setReadOptions"
                , setReadOptions_function_type( &::osg::ImageSequence::setReadOptions )
                , ( bp::arg("options") )
                , " Set the optional osgDB::Options object to use when reading images." );
        
        }
        { //::osg::ImageSequence::setReferenceTime
        
            typedef void ( ::osg::ImageSequence::*setReferenceTime_function_type )( double ) ;
            typedef void ( ImageSequence_wrapper::*default_setReferenceTime_function_type )( double ) ;
            
            ImageSequence_exposer.def( 
                "setReferenceTime"
                , setReferenceTime_function_type(&::osg::ImageSequence::setReferenceTime)
                , default_setReferenceTime_function_type(&ImageSequence_wrapper::default_setReferenceTime)
                , ( bp::arg("t") ) );
        
        }
        { //::osg::ImageSequence::setTimeMultiplier
        
            typedef void ( ::osg::ImageSequence::*setTimeMultiplier_function_type )( double ) ;
            typedef void ( ImageSequence_wrapper::*default_setTimeMultiplier_function_type )( double ) ;
            
            ImageSequence_exposer.def( 
                "setTimeMultiplier"
                , setTimeMultiplier_function_type(&::osg::ImageSequence::setTimeMultiplier)
                , default_setTimeMultiplier_function_type(&ImageSequence_wrapper::default_setTimeMultiplier)
                , ( bp::arg("tm") ) );
        
        }
        { //::osg::ImageSequence::update
        
            typedef void ( ::osg::ImageSequence::*update_function_type )( ::osg::NodeVisitor * ) ;
            typedef void ( ImageSequence_wrapper::*default_update_function_type )( ::osg::NodeVisitor * ) ;
            
            ImageSequence_exposer.def( 
                "update"
                , update_function_type(&::osg::ImageSequence::update)
                , default_update_function_type(&ImageSequence_wrapper::default_update)
                , ( bp::arg("nv") ) );
        
        }
        { //::osg::Image::allocateImage
        
            typedef void ( ::osg::Image::*allocateImage_function_type )( int,int,int,::GLenum,::GLenum,int ) ;
            typedef void ( ImageSequence_wrapper::*default_allocateImage_function_type )( int,int,int,::GLenum,::GLenum,int ) ;
            
            ImageSequence_exposer.def( 
                "allocateImage"
                , allocateImage_function_type(&::osg::Image::allocateImage)
                , default_allocateImage_function_type(&ImageSequence_wrapper::default_allocateImage)
                , ( bp::arg("s"), bp::arg("t"), bp::arg("r"), bp::arg("pixelFormat"), bp::arg("type"), bp::arg("packing")=(int)(1) ) );
        
        }
        { //::osg::BufferData::asArray
        
            typedef ::osg::Array * ( ::osg::BufferData::*asArray_function_type )(  ) ;
            typedef ::osg::Array * ( ImageSequence_wrapper::*default_asArray_function_type )(  ) ;
            
            ImageSequence_exposer.def( 
                "asArray"
                , asArray_function_type(&::osg::BufferData::asArray)
                , default_asArray_function_type(&ImageSequence_wrapper::default_asArray)
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::BufferData::asArray
        
            typedef ::osg::Array const * ( ::osg::BufferData::*asArray_function_type )(  ) const;
            typedef ::osg::Array const * ( ImageSequence_wrapper::*default_asArray_function_type )(  ) const;
            
            ImageSequence_exposer.def( 
                "asArray"
                , asArray_function_type(&::osg::BufferData::asArray)
                , default_asArray_function_type(&ImageSequence_wrapper::default_asArray)
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::Image::asImage
        
            typedef ::osg::Image * ( ::osg::Image::*asImage_function_type )(  ) ;
            typedef ::osg::Image * ( ImageSequence_wrapper::*default_asImage_function_type )(  ) ;
            
            ImageSequence_exposer.def( 
                "asImage"
                , asImage_function_type(&::osg::Image::asImage)
                , default_asImage_function_type(&ImageSequence_wrapper::default_asImage)
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::Image::asImage
        
            typedef ::osg::Image const * ( ::osg::Image::*asImage_function_type )(  ) const;
            typedef ::osg::Image const * ( ImageSequence_wrapper::*default_asImage_function_type )(  ) const;
            
            ImageSequence_exposer.def( 
                "asImage"
                , asImage_function_type(&::osg::Image::asImage)
                , default_asImage_function_type(&ImageSequence_wrapper::default_asImage)
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::Image::copySubImage
        
            typedef void ( ::osg::Image::*copySubImage_function_type )( int,int,int,::osg::Image const * ) ;
            typedef void ( ImageSequence_wrapper::*default_copySubImage_function_type )( int,int,int,::osg::Image const * ) ;
            
            ImageSequence_exposer.def( 
                "copySubImage"
                , copySubImage_function_type(&::osg::Image::copySubImage)
                , default_copySubImage_function_type(&ImageSequence_wrapper::default_copySubImage)
                , ( bp::arg("s_offset"), bp::arg("t_offset"), bp::arg("r_offset"), bp::arg("source") ) );
        
        }
        { //::osg::ImageStream::createSuitableTexture
        
            typedef ::osg::Texture * ( ::osg::ImageStream::*createSuitableTexture_function_type )(  ) ;
            typedef ::osg::Texture * ( ImageSequence_wrapper::*default_createSuitableTexture_function_type )(  ) ;
            
            ImageSequence_exposer.def( 
                "createSuitableTexture"
                , createSuitableTexture_function_type(&::osg::ImageStream::createSuitableTexture)
                , default_createSuitableTexture_function_type(&ImageSequence_wrapper::default_createSuitableTexture)
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::ImageStream::getAudioBalance
        
            typedef float ( ::osg::ImageStream::*getAudioBalance_function_type )(  ) ;
            typedef float ( ImageSequence_wrapper::*default_getAudioBalance_function_type )(  ) ;
            
            ImageSequence_exposer.def( 
                "getAudioBalance"
                , getAudioBalance_function_type(&::osg::ImageStream::getAudioBalance)
                , default_getAudioBalance_function_type(&ImageSequence_wrapper::default_getAudioBalance) );
        
        }
        { //::osg::ImageStream::getCreationTime
        
            typedef double ( ::osg::ImageStream::*getCreationTime_function_type )(  ) const;
            typedef double ( ImageSequence_wrapper::*default_getCreationTime_function_type )(  ) const;
            
            ImageSequence_exposer.def( 
                "getCreationTime"
                , getCreationTime_function_type(&::osg::ImageStream::getCreationTime)
                , default_getCreationTime_function_type(&ImageSequence_wrapper::default_getCreationTime) );
        
        }
        { //::osg::ImageStream::getCurrentTime
        
            typedef double ( ::osg::ImageStream::*getCurrentTime_function_type )(  ) const;
            typedef double ( ImageSequence_wrapper::*default_getCurrentTime_function_type )(  ) const;
            
            ImageSequence_exposer.def( 
                "getCurrentTime"
                , getCurrentTime_function_type(&::osg::ImageStream::getCurrentTime)
                , default_getCurrentTime_function_type(&ImageSequence_wrapper::default_getCurrentTime) );
        
        }
        { //::osg::Image::getDataPointer
        
            typedef ::GLvoid const * ( ::osg::Image::*getDataPointer_function_type )(  ) const;
            typedef ::GLvoid const * ( ImageSequence_wrapper::*default_getDataPointer_function_type )(  ) const;
            
            ImageSequence_exposer.def( 
                "getDataPointer"
                , getDataPointer_function_type(&::osg::Image::getDataPointer)
                , default_getDataPointer_function_type(&ImageSequence_wrapper::default_getDataPointer)
                , bp::return_value_policy< bp::return_opaque_pointer >() );
        
        }
        { //::osg::ImageStream::getFrameRate
        
            typedef double ( ::osg::ImageStream::*getFrameRate_function_type )(  ) const;
            typedef double ( ImageSequence_wrapper::*default_getFrameRate_function_type )(  ) const;
            
            ImageSequence_exposer.def( 
                "getFrameRate"
                , getFrameRate_function_type(&::osg::ImageStream::getFrameRate)
                , default_getFrameRate_function_type(&ImageSequence_wrapper::default_getFrameRate) );
        
        }
        { //::osg::Image::getTotalDataSize
        
            typedef unsigned int ( ::osg::Image::*getTotalDataSize_function_type )(  ) const;
            typedef unsigned int ( ImageSequence_wrapper::*default_getTotalDataSize_function_type )(  ) const;
            
            ImageSequence_exposer.def( 
                "getTotalDataSize"
                , getTotalDataSize_function_type(&::osg::Image::getTotalDataSize)
                , default_getTotalDataSize_function_type(&ImageSequence_wrapper::default_getTotalDataSize) );
        
        }
        { //::osg::ImageStream::getVolume
        
            typedef float ( ::osg::ImageStream::*getVolume_function_type )(  ) const;
            typedef float ( ImageSequence_wrapper::*default_getVolume_function_type )(  ) const;
            
            ImageSequence_exposer.def( 
                "getVolume"
                , getVolume_function_type(&::osg::ImageStream::getVolume)
                , default_getVolume_function_type(&ImageSequence_wrapper::default_getVolume) );
        
        }
        { //::osg::Image::isImageTranslucent
        
            typedef bool ( ::osg::Image::*isImageTranslucent_function_type )(  ) const;
            typedef bool ( ImageSequence_wrapper::*default_isImageTranslucent_function_type )(  ) const;
            
            ImageSequence_exposer.def( 
                "isImageTranslucent"
                , isImageTranslucent_function_type(&::osg::Image::isImageTranslucent)
                , default_isImageTranslucent_function_type(&ImageSequence_wrapper::default_isImageTranslucent) );
        
        }
        { //::osg::ImageStream::quit
        
            typedef void ( ::osg::ImageStream::*quit_function_type )( bool ) ;
            typedef void ( ImageSequence_wrapper::*default_quit_function_type )( bool ) ;
            
            ImageSequence_exposer.def( 
                "quit"
                , quit_function_type(&::osg::ImageStream::quit)
                , default_quit_function_type(&ImageSequence_wrapper::default_quit)
                , ( bp::arg("arg0")=(bool)(true) ) );
        
        }
        { //::osg::Image::readImageFromCurrentTexture
        
            typedef void ( ::osg::Image::*readImageFromCurrentTexture_function_type )( unsigned int,bool,::GLenum,unsigned int ) ;
            typedef void ( ImageSequence_wrapper::*default_readImageFromCurrentTexture_function_type )( unsigned int,bool,::GLenum,unsigned int ) ;
            
            ImageSequence_exposer.def( 
                "readImageFromCurrentTexture"
                , readImageFromCurrentTexture_function_type(&::osg::Image::readImageFromCurrentTexture)
                , default_readImageFromCurrentTexture_function_type(&ImageSequence_wrapper::default_readImageFromCurrentTexture)
                , ( bp::arg("contextID"), bp::arg("copyMipMapsIfAvailable"), bp::arg("type")=(::GLenum)(5121), bp::arg("face")=(unsigned int)(0) ) );
        
        }
        { //::osg::Image::readPixels
        
            typedef void ( ::osg::Image::*readPixels_function_type )( int,int,int,int,::GLenum,::GLenum,int ) ;
            typedef void ( ImageSequence_wrapper::*default_readPixels_function_type )( int,int,int,int,::GLenum,::GLenum,int ) ;
            
            ImageSequence_exposer.def( 
                "readPixels"
                , readPixels_function_type(&::osg::Image::readPixels)
                , default_readPixels_function_type(&ImageSequence_wrapper::default_readPixels)
                , ( bp::arg("x"), bp::arg("y"), bp::arg("width"), bp::arg("height"), bp::arg("pixelFormat"), bp::arg("type"), bp::arg("packing")=(int)(1) ) );
        
        }
        { //::osg::BufferData::resizeGLObjectBuffers
        
            typedef void ( ::osg::BufferData::*resizeGLObjectBuffers_function_type )( unsigned int ) ;
            typedef void ( ImageSequence_wrapper::*default_resizeGLObjectBuffers_function_type )( unsigned int ) ;
            
            ImageSequence_exposer.def( 
                "resizeGLObjectBuffers"
                , resizeGLObjectBuffers_function_type(&::osg::BufferData::resizeGLObjectBuffers)
                , default_resizeGLObjectBuffers_function_type(&ImageSequence_wrapper::default_resizeGLObjectBuffers)
                , ( bp::arg("maxSize") ) );
        
        }
        { //::osg::Image::scaleImage
        
            typedef void ( ::osg::Image::*scaleImage_function_type )( int,int,int ) ;
            
            ImageSequence_exposer.def( 
                "scaleImage"
                , scaleImage_function_type( &::osg::Image::scaleImage )
                , ( bp::arg("s"), bp::arg("t"), bp::arg("r") )
                , " Scale image to specified size." );
        
        }
        { //::osg::Image::scaleImage
        
            typedef void ( ::osg::Image::*scaleImage_function_type )( int,int,int,::GLenum ) ;
            typedef void ( ImageSequence_wrapper::*default_scaleImage_function_type )( int,int,int,::GLenum ) ;
            
            ImageSequence_exposer.def( 
                "scaleImage"
                , scaleImage_function_type(&::osg::Image::scaleImage)
                , default_scaleImage_function_type(&ImageSequence_wrapper::default_scaleImage)
                , ( bp::arg("s"), bp::arg("t"), bp::arg("r"), bp::arg("newDataType") ) );
        
        }
        { //::osg::Image::sendFocusHint
        
            typedef bool ( ::osg::Image::*sendFocusHint_function_type )( bool ) ;
            typedef bool ( ImageSequence_wrapper::*default_sendFocusHint_function_type )( bool ) ;
            
            ImageSequence_exposer.def( 
                "sendFocusHint"
                , sendFocusHint_function_type(&::osg::Image::sendFocusHint)
                , default_sendFocusHint_function_type(&ImageSequence_wrapper::default_sendFocusHint)
                , ( bp::arg("arg0") ) );
        
        }
        { //::osg::Image::sendKeyEvent
        
            typedef bool ( ::osg::Image::*sendKeyEvent_function_type )( int,bool ) ;
            typedef bool ( ImageSequence_wrapper::*default_sendKeyEvent_function_type )( int,bool ) ;
            
            ImageSequence_exposer.def( 
                "sendKeyEvent"
                , sendKeyEvent_function_type(&::osg::Image::sendKeyEvent)
                , default_sendKeyEvent_function_type(&ImageSequence_wrapper::default_sendKeyEvent)
                , ( bp::arg("arg0"), bp::arg("arg1") ) );
        
        }
        { //::osg::Image::sendPointerEvent
        
            typedef bool ( ::osg::Image::*sendPointerEvent_function_type )( int,int,int ) ;
            typedef bool ( ImageSequence_wrapper::*default_sendPointerEvent_function_type )( int,int,int ) ;
            
            ImageSequence_exposer.def( 
                "sendPointerEvent"
                , sendPointerEvent_function_type(&::osg::Image::sendPointerEvent)
                , default_sendPointerEvent_function_type(&ImageSequence_wrapper::default_sendPointerEvent)
                , ( bp::arg("arg0"), bp::arg("arg1"), bp::arg("arg2") ) );
        
        }
        { //::osg::ImageStream::setAudioBalance
        
            typedef void ( ::osg::ImageStream::*setAudioBalance_function_type )( float ) ;
            typedef void ( ImageSequence_wrapper::*default_setAudioBalance_function_type )( float ) ;
            
            ImageSequence_exposer.def( 
                "setAudioBalance"
                , setAudioBalance_function_type(&::osg::ImageStream::setAudioBalance)
                , default_setAudioBalance_function_type(&ImageSequence_wrapper::default_setAudioBalance)
                , ( bp::arg("arg0") ) );
        
        }
        { //::osg::Image::setFrameLastRendered
        
            typedef void ( ::osg::Image::*setFrameLastRendered_function_type )( ::osg::FrameStamp const * ) ;
            typedef void ( ImageSequence_wrapper::*default_setFrameLastRendered_function_type )( ::osg::FrameStamp const * ) ;
            
            ImageSequence_exposer.def( 
                "setFrameLastRendered"
                , setFrameLastRendered_function_type(&::osg::Image::setFrameLastRendered)
                , default_setFrameLastRendered_function_type(&ImageSequence_wrapper::default_setFrameLastRendered)
                , ( bp::arg("arg0") ) );
        
        }
        { //::osg::Image::setImage
        
            typedef void ( ::osg::Image::*setImage_function_type )( int,int,int,::GLint,::GLenum,::GLenum,unsigned char *,::osg::Image::AllocationMode,int,int ) ;
            typedef void ( ImageSequence_wrapper::*default_setImage_function_type )( int,int,int,::GLint,::GLenum,::GLenum,unsigned char *,::osg::Image::AllocationMode,int,int ) ;
            
            ImageSequence_exposer.def( 
                "setImage"
                , setImage_function_type(&::osg::Image::setImage)
                , default_setImage_function_type(&ImageSequence_wrapper::default_setImage)
                , ( bp::arg("s"), bp::arg("t"), bp::arg("r"), bp::arg("internalTextureformat"), bp::arg("pixelFormat"), bp::arg("type"), bp::arg("data"), bp::arg("mode"), bp::arg("packing")=(int)(1), bp::arg("rowLength")=(int)(0) ) );
        
        }
        { //::osg::ImageStream::setVolume
        
            typedef void ( ::osg::ImageStream::*setVolume_function_type )( float ) ;
            typedef void ( ImageSequence_wrapper::*default_setVolume_function_type )( float ) ;
            
            ImageSequence_exposer.def( 
                "setVolume"
                , setVolume_function_type(&::osg::ImageStream::setVolume)
                , default_setVolume_function_type(&ImageSequence_wrapper::default_setVolume)
                , ( bp::arg("arg0") ) );
        
        }
    }

}
