// This file has been generated by Py++.

#include "boost/python.hpp"
#include "wrap_osg.h"
#include "_osg_free_functions.pypp.hpp"

namespace bp = boost::python;

void register_free_functions(){

    { //::osg::DegreesToRadians
    
        typedef double ( *DegreesToRadians_function_type )( double );
        
        bp::def( 
            "DegreesToRadians"
            , DegreesToRadians_function_type( &::osg::DegreesToRadians )
            , ( bp::arg("angle") ) );
    
    }

    { //::osg::DegreesToRadians
    
        typedef float ( *DegreesToRadians_function_type )( float );
        
        bp::def( 
            "DegreesToRadians"
            , DegreesToRadians_function_type( &::osg::DegreesToRadians )
            , ( bp::arg("angle") ) );
    
    }

    { //::OpenThreads::GetNumberOfProcessors
    
        typedef int ( *GetNumberOfProcessors_function_type )(  );
        
        bp::def( 
            "GetNumberOfProcessors"
            , GetNumberOfProcessors_function_type( &::OpenThreads::GetNumberOfProcessors )
            , "  Get the number of processors.\n\n  Note, systems where no support exists for querrying the number of processors, 1 is returned." );
    
    }

    { //::osg::RadiansToDegrees
    
        typedef double ( *RadiansToDegrees_function_type )( double );
        
        bp::def( 
            "RadiansToDegrees"
            , RadiansToDegrees_function_type( &::osg::RadiansToDegrees )
            , ( bp::arg("angle") ) );
    
    }

    { //::osg::RadiansToDegrees
    
        typedef float ( *RadiansToDegrees_function_type )( float );
        
        bp::def( 
            "RadiansToDegrees"
            , RadiansToDegrees_function_type( &::osg::RadiansToDegrees )
            , ( bp::arg("angle") ) );
    
    }

    { //::OpenThreads::SetProcessorAffinityOfCurrentThread
    
        typedef int ( *SetProcessorAffinityOfCurrentThread_function_type )( unsigned int );
        
        bp::def( 
            "SetProcessorAffinityOfCurrentThread"
            , SetProcessorAffinityOfCurrentThread_function_type( &::OpenThreads::SetProcessorAffinityOfCurrentThread )
            , ( bp::arg("cpunum") )
            , "  Set the processor affinity of current thread.\n\n  Note, systems where no support exists no affinity will be set, and -1 will be returned." );
    
    }

    { //::osg::asciiToDouble
    
        typedef double ( *asciiToDouble_function_type )( char const * );
        
        bp::def( 
            "asciiToDouble"
            , asciiToDouble_function_type( &::osg::asciiToDouble )
            , ( bp::arg("str") )
            , " Convert a ascii number to a double, ignoring locale settings." );
    
    }

    { //::osg::asciiToFloat
    
        typedef float ( *asciiToFloat_function_type )( char const * );
        
        bp::def( 
            "asciiToFloat"
            , asciiToFloat_function_type( &::osg::asciiToFloat )
            , ( bp::arg("str") )
            , " Convert a ascii number to a float, ignoring locale settings." );
    
    }

    { //::osg::clampTo
    
        typedef double ( *clampTo_function_type )( double,double,double );
        
        bp::def( 
            "clampTo"
            , clampTo_function_type( &::osg::clampTo )
            , ( bp::arg("v"), bp::arg("minimum"), bp::arg("maximum") ) );
    
    }

    { //::osg::clampTo
    
        typedef float ( *clampTo_function_type )( float,float,float );
        
        bp::def( 
            "clampTo"
            , clampTo_function_type( &::osg::clampTo )
            , ( bp::arg("v"), bp::arg("minimum"), bp::arg("maximum") ) );
    
    }

    { //::osg::clearImageToColor
    
        typedef bool ( *clearImageToColor_function_type )( ::osg::Image *,::osg::Vec4 const & );
        
        bp::def( 
            "clearImageToColor"
            , clearImageToColor_function_type( &::osg::clearImageToColor )
            , ( bp::arg("image"), bp::arg("colour") )
            , " Compute the min max colour values in the image." );
    
    }

    { //::osg::colorSpaceConversion
    
        typedef ::osg::Image * ( *colorSpaceConversion_function_type )( ::osg::ColorSpaceOperation,::osg::Image *,::osg::Vec4 const & );
        
        bp::def( 
            "colorSpaceConversion"
            , colorSpaceConversion_function_type( &::osg::colorSpaceConversion )
            , ( bp::arg("op"), bp::arg("image"), bp::arg("colour") )
            , bp::return_value_policy< bp::reference_existing_object >()
            , " Convert the RGBA values in a Image based on a ColorSpaceOperation defined scheme." );
    
    }

    { //::osg::componentDivide
    
        typedef ::osg::Vec4us ( *componentDivide_function_type )( ::osg::Vec4us const &,::osg::Vec4us const & );
        
        bp::def( 
            "componentDivide"
            , componentDivide_function_type( &::osg::componentDivide )
            , ( bp::arg("lhs"), bp::arg("rhs") )
            , " divide rhs components by rhs vector components." );
    
    }

    { //::osg::componentDivide
    
        typedef ::osg::Vec3us ( *componentDivide_function_type )( ::osg::Vec3us const &,::osg::Vec3us const & );
        
        bp::def( 
            "componentDivide"
            , componentDivide_function_type( &::osg::componentDivide )
            , ( bp::arg("lhs"), bp::arg("rhs") )
            , " divide rhs components by rhs vector components." );
    
    }

    { //::osg::componentDivide
    
        typedef ::osg::Vec2us ( *componentDivide_function_type )( ::osg::Vec2us const &,::osg::Vec2us const & );
        
        bp::def( 
            "componentDivide"
            , componentDivide_function_type( &::osg::componentDivide )
            , ( bp::arg("lhs"), bp::arg("rhs") )
            , " divide rhs components by rhs vector components." );
    
    }

    { //::osg::componentDivide
    
        typedef ::osg::Vec3ub ( *componentDivide_function_type )( ::osg::Vec3ub const &,::osg::Vec3ub const & );
        
        bp::def( 
            "componentDivide"
            , componentDivide_function_type( &::osg::componentDivide )
            , ( bp::arg("lhs"), bp::arg("rhs") )
            , " divide rhs components by rhs vector components." );
    
    }

    { //::osg::componentDivide
    
        typedef ::osg::Vec2ub ( *componentDivide_function_type )( ::osg::Vec2ub const &,::osg::Vec2ub const & );
        
        bp::def( 
            "componentDivide"
            , componentDivide_function_type( &::osg::componentDivide )
            , ( bp::arg("lhs"), bp::arg("rhs") )
            , " divide rhs components by rhs vector components." );
    
    }

    { //::osg::componentDivide
    
        typedef ::osg::Vec4s ( *componentDivide_function_type )( ::osg::Vec4s const &,::osg::Vec4s const & );
        
        bp::def( 
            "componentDivide"
            , componentDivide_function_type( &::osg::componentDivide )
            , ( bp::arg("lhs"), bp::arg("rhs") )
            , " divide rhs components by rhs vector components." );
    
    }

    { //::osg::componentDivide
    
        typedef ::osg::Vec3s ( *componentDivide_function_type )( ::osg::Vec3s const &,::osg::Vec3s const & );
        
        bp::def( 
            "componentDivide"
            , componentDivide_function_type( &::osg::componentDivide )
            , ( bp::arg("lhs"), bp::arg("rhs") )
            , " divide rhs components by rhs vector components." );
    
    }

    { //::osg::componentDivide
    
        typedef ::osg::Vec2s ( *componentDivide_function_type )( ::osg::Vec2s const &,::osg::Vec2s const & );
        
        bp::def( 
            "componentDivide"
            , componentDivide_function_type( &::osg::componentDivide )
            , ( bp::arg("lhs"), bp::arg("rhs") )
            , " divide rhs components by rhs vector components." );
    
    }

    { //::osg::componentDivide
    
        typedef ::osg::Vec4d ( *componentDivide_function_type )( ::osg::Vec4d const &,::osg::Vec4d const & );
        
        bp::def( 
            "componentDivide"
            , componentDivide_function_type( &::osg::componentDivide )
            , ( bp::arg("lhs"), bp::arg("rhs") )
            , " divide rhs components by rhs vector components." );
    
    }

    { //::osg::componentDivide
    
        typedef ::osg::Vec4f ( *componentDivide_function_type )( ::osg::Vec4f const &,::osg::Vec4f const & );
        
        bp::def( 
            "componentDivide"
            , componentDivide_function_type( &::osg::componentDivide )
            , ( bp::arg("lhs"), bp::arg("rhs") )
            , " divide rhs components by rhs vector components." );
    
    }

    { //::osg::componentDivide
    
        typedef ::osg::Vec3d ( *componentDivide_function_type )( ::osg::Vec3d const &,::osg::Vec3d const & );
        
        bp::def( 
            "componentDivide"
            , componentDivide_function_type( &::osg::componentDivide )
            , ( bp::arg("lhs"), bp::arg("rhs") )
            , " divide rhs components by rhs vector components." );
    
    }

    { //::osg::componentDivide
    
        typedef ::osg::Vec3f ( *componentDivide_function_type )( ::osg::Vec3f const &,::osg::Vec3f const & );
        
        bp::def( 
            "componentDivide"
            , componentDivide_function_type( &::osg::componentDivide )
            , ( bp::arg("lhs"), bp::arg("rhs") )
            , " divide rhs components by rhs vector components." );
    
    }

    { //::osg::componentDivide
    
        typedef ::osg::Vec2d ( *componentDivide_function_type )( ::osg::Vec2d const &,::osg::Vec2d const & );
        
        bp::def( 
            "componentDivide"
            , componentDivide_function_type( &::osg::componentDivide )
            , ( bp::arg("lhs"), bp::arg("rhs") )
            , " divide rhs components by rhs vector components." );
    
    }

    { //::osg::componentDivide
    
        typedef ::osg::Vec2f ( *componentDivide_function_type )( ::osg::Vec2f const &,::osg::Vec2f const & );
        
        bp::def( 
            "componentDivide"
            , componentDivide_function_type( &::osg::componentDivide )
            , ( bp::arg("lhs"), bp::arg("rhs") )
            , " divide rhs components by rhs vector components." );
    
    }

    { //::osg::componentMultiply
    
        typedef ::osg::Vec4us ( *componentMultiply_function_type )( ::osg::Vec4us const &,::osg::Vec4us const & );
        
        bp::def( 
            "componentMultiply"
            , componentMultiply_function_type( &::osg::componentMultiply )
            , ( bp::arg("lhs"), bp::arg("rhs") )
            , " multiply by vector components." );
    
    }

    { //::osg::componentMultiply
    
        typedef ::osg::Vec3us ( *componentMultiply_function_type )( ::osg::Vec3us const &,::osg::Vec3us const & );
        
        bp::def( 
            "componentMultiply"
            , componentMultiply_function_type( &::osg::componentMultiply )
            , ( bp::arg("lhs"), bp::arg("rhs") )
            , " multiply by vector components." );
    
    }

    { //::osg::componentMultiply
    
        typedef ::osg::Vec2us ( *componentMultiply_function_type )( ::osg::Vec2us const &,::osg::Vec2us const & );
        
        bp::def( 
            "componentMultiply"
            , componentMultiply_function_type( &::osg::componentMultiply )
            , ( bp::arg("lhs"), bp::arg("rhs") )
            , " multiply by vector components." );
    
    }

    { //::osg::componentMultiply
    
        typedef ::osg::Vec3ub ( *componentMultiply_function_type )( ::osg::Vec3ub const &,::osg::Vec3ub const & );
        
        bp::def( 
            "componentMultiply"
            , componentMultiply_function_type( &::osg::componentMultiply )
            , ( bp::arg("lhs"), bp::arg("rhs") )
            , " multiply by vector components." );
    
    }

    { //::osg::componentMultiply
    
        typedef ::osg::Vec2ub ( *componentMultiply_function_type )( ::osg::Vec2ub const &,::osg::Vec2ub const & );
        
        bp::def( 
            "componentMultiply"
            , componentMultiply_function_type( &::osg::componentMultiply )
            , ( bp::arg("lhs"), bp::arg("rhs") )
            , " multiply by vector components." );
    
    }

    { //::osg::componentMultiply
    
        typedef ::osg::Vec4s ( *componentMultiply_function_type )( ::osg::Vec4s const &,::osg::Vec4s const & );
        
        bp::def( 
            "componentMultiply"
            , componentMultiply_function_type( &::osg::componentMultiply )
            , ( bp::arg("lhs"), bp::arg("rhs") )
            , " multiply by vector components." );
    
    }

    { //::osg::componentMultiply
    
        typedef ::osg::Vec3s ( *componentMultiply_function_type )( ::osg::Vec3s const &,::osg::Vec3s const & );
        
        bp::def( 
            "componentMultiply"
            , componentMultiply_function_type( &::osg::componentMultiply )
            , ( bp::arg("lhs"), bp::arg("rhs") )
            , " multiply by vector components." );
    
    }

    { //::osg::componentMultiply
    
        typedef ::osg::Vec2s ( *componentMultiply_function_type )( ::osg::Vec2s const &,::osg::Vec2s const & );
        
        bp::def( 
            "componentMultiply"
            , componentMultiply_function_type( &::osg::componentMultiply )
            , ( bp::arg("lhs"), bp::arg("rhs") )
            , " multiply by vector components." );
    
    }

    { //::osg::componentMultiply
    
        typedef ::osg::Vec4d ( *componentMultiply_function_type )( ::osg::Vec4d const &,::osg::Vec4d const & );
        
        bp::def( 
            "componentMultiply"
            , componentMultiply_function_type( &::osg::componentMultiply )
            , ( bp::arg("lhs"), bp::arg("rhs") )
            , " multiply by vector components." );
    
    }

    { //::osg::componentMultiply
    
        typedef ::osg::Vec4f ( *componentMultiply_function_type )( ::osg::Vec4f const &,::osg::Vec4f const & );
        
        bp::def( 
            "componentMultiply"
            , componentMultiply_function_type( &::osg::componentMultiply )
            , ( bp::arg("lhs"), bp::arg("rhs") )
            , " multiply by vector components." );
    
    }

    { //::osg::componentMultiply
    
        typedef ::osg::Vec3d ( *componentMultiply_function_type )( ::osg::Vec3d const &,::osg::Vec3d const & );
        
        bp::def( 
            "componentMultiply"
            , componentMultiply_function_type( &::osg::componentMultiply )
            , ( bp::arg("lhs"), bp::arg("rhs") )
            , " multiply by vector components." );
    
    }

    { //::osg::componentMultiply
    
        typedef ::osg::Vec3f ( *componentMultiply_function_type )( ::osg::Vec3f const &,::osg::Vec3f const & );
        
        bp::def( 
            "componentMultiply"
            , componentMultiply_function_type( &::osg::componentMultiply )
            , ( bp::arg("lhs"), bp::arg("rhs") )
            , " multiply by vector components." );
    
    }

    { //::osg::componentMultiply
    
        typedef ::osg::Vec2d ( *componentMultiply_function_type )( ::osg::Vec2d const &,::osg::Vec2d const & );
        
        bp::def( 
            "componentMultiply"
            , componentMultiply_function_type( &::osg::componentMultiply )
            , ( bp::arg("lhs"), bp::arg("rhs") )
            , " multiply by vector components." );
    
    }

    { //::osg::componentMultiply
    
        typedef ::osg::Vec2f ( *componentMultiply_function_type )( ::osg::Vec2f const &,::osg::Vec2f const & );
        
        bp::def( 
            "componentMultiply"
            , componentMultiply_function_type( &::osg::componentMultiply )
            , ( bp::arg("lhs"), bp::arg("rhs") )
            , " multiply by vector components." );
    
    }

    { //::osg::computeEyeToLocal
    
        typedef ::osg::Matrix ( *computeEyeToLocal_function_type )( ::osg::Matrix const &,::osg::NodePath const &,bool );
        
        bp::def( 
            "computeEyeToLocal"
            , computeEyeToLocal_function_type( &::osg::computeEyeToLocal )
            , ( bp::arg("modelview"), bp::arg("nodePath"), bp::arg("ignoreCameras")=(bool)(true) )
            , " Compute the matrix which transforms objects in eye coords to local coords,\n by accumulating the Transform world to local matrices along the specified node path\n and multiplying by the inverse of the supplied initial camera modelview." );
    
    }

    { //::osg::computeLocalToEye
    
        typedef ::osg::Matrix ( *computeLocalToEye_function_type )( ::osg::Matrix const &,::osg::NodePath const &,bool );
        
        bp::def( 
            "computeLocalToEye"
            , computeLocalToEye_function_type( &::osg::computeLocalToEye )
            , ( bp::arg("modelview"), bp::arg("nodePath"), bp::arg("ignoreCameras")=(bool)(true) )
            , " Compute the matrix which transforms objects in local coords to eye coords,\n by accumulating the Transform local to world matrices along the specified node path\n and multiplying by the supplied initial camera modelview." );
    
    }

    { //::osg::computeLocalToWorld
    
        typedef ::osg::Matrix ( *computeLocalToWorld_function_type )( ::osg::NodePath const &,bool );
        
        bp::def( 
            "computeLocalToWorld"
            , computeLocalToWorld_function_type( &::osg::computeLocalToWorld )
            , ( bp::arg("nodePath"), bp::arg("ignoreCameras")=(bool)(true) )
            , " Compute the matrix which transforms objects in local coords to world coords,\n by accumulating the Transform local to world matrices along the specified node path." );
    
    }

    { //::osg::computeMinMax
    
        typedef bool ( *computeMinMax_function_type )( ::osg::Image const *,::osg::Vec4 &,::osg::Vec4 & );
        
        bp::def( 
            "computeMinMax"
            , computeMinMax_function_type( &::osg::computeMinMax )
            , ( bp::arg("image"), bp::arg("min"), bp::arg("max") )
            , " Compute the min max colour values in the image." );
    
    }

    { //::osg::computeWorldToLocal
    
        typedef ::osg::Matrix ( *computeWorldToLocal_function_type )( ::osg::NodePath const &,bool );
        
        bp::def( 
            "computeWorldToLocal"
            , computeWorldToLocal_function_type( &::osg::computeWorldToLocal )
            , ( bp::arg("nodePath"), bp::arg("ignoreCameras")=(bool)(true) )
            , " Compute the matrix which transforms objects in world coords to local coords,\n by accumulating the Transform world to local matrices along the specified node path." );
    
    }

    { //::osg::copyImage
    
        typedef bool ( *copyImage_function_type )( ::osg::Image const *,int,int,int,int,int,int,::osg::Image *,int,int,int,bool );
        
        bp::def( 
            "copyImage"
            , copyImage_function_type( &::osg::copyImage )
            , ( bp::arg("srcImage"), bp::arg("src_s"), bp::arg("src_t"), bp::arg("src_r"), bp::arg("width"), bp::arg("height"), bp::arg("depth"), bp::arg("destImage"), bp::arg("dest_s"), bp::arg("dest_t"), bp::arg("dest_r"), bp::arg("doRescale")=(bool)(false) )
            , " Compute source image to destination image." );
    
    }

    { //::osg::createGeodeForImage
    
        typedef ::osg::Geode * ( *createGeodeForImage_function_type )( ::osg::Image *,float,float );
        
        bp::def( 
            "createGeodeForImage"
            , createGeodeForImage_function_type( &::osg::createGeodeForImage )
            , ( bp::arg("image"), bp::arg("s"), bp::arg("t") )
            , bp::return_value_policy< bp::reference_existing_object >()
            , " Convenience function to be used by image loaders to generate a valid geode\n to return for readNode().\n Use the specified s and t values to scale the dimensions of the image." );
    
    }

    { //::osg::createGeodeForImage
    
        typedef ::osg::Geode * ( *createGeodeForImage_function_type )( ::osg::Image * );
        
        bp::def( 
            "createGeodeForImage"
            , createGeodeForImage_function_type( &::osg::createGeodeForImage )
            , ( bp::arg("image") )
            , bp::return_value_policy< bp::reference_existing_object >()
            , " Convenience function to be used by image loaders to generate a valid geode\n to return for readNode().\n Use the images s and t values to scale the dimensions of the image." );
    
    }

    { //::osg::createImage3D
    
        typedef ::osg::Image * ( *createImage3D_function_type )( ::osg::ImageList const &,::GLenum,int,int,int,bool );
        
        bp::def( 
            "createImage3D"
            , createImage3D_function_type( &::osg::createImage3D )
            , ( bp::arg("imageList"), bp::arg("desiredPixelFormat"), bp::arg("s_maximumImageSize")=(int)(1024), bp::arg("t_maximumImageSize")=(int)(1024), bp::arg("r_maximumImageSize")=(int)(1024), bp::arg("resizeToPowerOfTwo")=(bool)(false) )
            , bp::return_value_policy< bp::reference_existing_object >()
            , " create a 3D osg::Image from a list of osg::Image." );
    
    }

    { //::osg::createImage3DWithAlpha
    
        typedef ::osg::Image * ( *createImage3DWithAlpha_function_type )( ::osg::ImageList const &,int,int,int,bool );
        
        bp::def( 
            "createImage3DWithAlpha"
            , createImage3DWithAlpha_function_type( &::osg::createImage3DWithAlpha )
            , ( bp::arg("imageList"), bp::arg("s_maximumImageSize")=(int)(1024), bp::arg("t_maximumImageSize")=(int)(1024), bp::arg("r_maximumImageSize")=(int)(1024), bp::arg("resizeToPowerOfTwo")=(bool)(false) )
            , bp::return_value_policy< bp::reference_existing_object >()
            , " create a 3D osg::Image from a list of osg::Image." );
    
    }

    { //::osg::createSpotLightImage
    
        typedef ::osg::Image * ( *createSpotLightImage_function_type )( ::osg::Vec4 const &,::osg::Vec4 const &,unsigned int,float );
        
        bp::def( 
            "createSpotLightImage"
            , createSpotLightImage_function_type( &::osg::createSpotLightImage )
            , ( bp::arg("centerColour"), bp::arg("backgroudColour"), bp::arg("size"), bp::arg("power") )
            , bp::return_value_policy< bp::reference_existing_object >()
            , " create a 2D osg::Image that provides a point at the center of the image.\n  The colour across th image is computed from a balance between the center color and the background color controlled by the power of the radius from the center." );
    
    }

    { //::osg::createTexturedQuadGeometry
    
        typedef ::osg::Geometry * ( *createTexturedQuadGeometry_function_type )( ::osg::Vec3 const &,::osg::Vec3 const &,::osg::Vec3 const &,float,float );
        
        bp::def( 
            "createTexturedQuadGeometry"
            , createTexturedQuadGeometry_function_type( &::osg::createTexturedQuadGeometry )
            , ( bp::arg("corner"), bp::arg("widthVec"), bp::arg("heightVec"), bp::arg("s")=1.0e+0f, bp::arg("t")=1.0e+0f )
            , bp::return_value_policy< bp::reference_existing_object >()
            , " Convenience function to be used for creating quad geometry with texture coords.\n Tex coords go from bottom left (0,0) to top right (s,t)." );
    
    }

    { //::osg::createTexturedQuadGeometry
    
        typedef ::osg::Geometry * ( *createTexturedQuadGeometry_function_type )( ::osg::Vec3 const &,::osg::Vec3 const &,::osg::Vec3 const &,float,float,float,float );
        
        bp::def( 
            "createTexturedQuadGeometry"
            , createTexturedQuadGeometry_function_type( &::osg::createTexturedQuadGeometry )
            , ( bp::arg("corner"), bp::arg("widthVec"), bp::arg("heightVec"), bp::arg("l"), bp::arg("b"), bp::arg("r"), bp::arg("t") )
            , bp::return_value_policy< bp::reference_existing_object >()
            , " Convenience function to be used for creating quad geometry with texture coords.\n Tex coords go from left bottom (l,b) to right top (r,t)." );
    
    }

    { //::osg::deleteAllGLObjects
    
        typedef void ( *deleteAllGLObjects_function_type )( unsigned int );
        
        bp::def( 
            "deleteAllGLObjects"
            , deleteAllGLObjects_function_type( &::osg::deleteAllGLObjects )
            , ( bp::arg("contextID") )
            , " Do a GL delete all OpenGL objects.\n Note, must be called from a thread which has current the graphics context associated with contextID." );
    
    }

    { //::osg::discardAllGLObjects
    
        typedef void ( *discardAllGLObjects_function_type )( unsigned int );
        
        bp::def( 
            "discardAllGLObjects"
            , discardAllGLObjects_function_type( &::osg::discardAllGLObjects )
            , ( bp::arg("contextID") )
            , " Discard all OpenGL objects.\n Note, unlike deleteAllGLjects discard does not\n do any OpenGL calls so can be called from any thread, but as a consequence it\n also doesnt remove the associated OpenGL resource so discard should only be\n called when the associated graphics context is being/has been closed." );
    
    }

    { //::osg::equivalent
    
        typedef bool ( *equivalent_function_type )( double,double,double );
        
        bp::def( 
            "equivalent"
            , equivalent_function_type( &::osg::equivalent )
            , ( bp::arg("lhs"), bp::arg("rhs"), bp::arg("epsilon")=9.99999999999999954748111825886258685613938723690807819366e-7 )
            , " return true if double lhs and rhs are equivalent,\n meaning that the difference between them is less than an epsilon value\n which defaults to 1e-6." );
    
    }

    { //::osg::equivalent
    
        typedef bool ( *equivalent_function_type )( float,float,float );
        
        bp::def( 
            "equivalent"
            , equivalent_function_type( &::osg::equivalent )
            , ( bp::arg("lhs"), bp::arg("rhs"), bp::arg("epsilon")=9.99999999999999954748111825886258685613938723690807819366e-7 )
            , " return true if float lhs and rhs are equivalent,\n meaning that the difference between them is less than an epsilon value\n which defaults to 1e-6." );
    
    }

    { //::osg::findAsciiToDouble
    
        typedef double ( *findAsciiToDouble_function_type )( char const * );
        
        bp::def( 
            "findAsciiToDouble"
            , findAsciiToDouble_function_type( &::osg::findAsciiToDouble )
            , ( bp::arg("str") )
            , " Detect first ascii POSITIVE number in string and convert to double." );
    
    }

    { //::osg::findAsciiToFloat
    
        typedef float ( *findAsciiToFloat_function_type )( char const * );
        
        bp::def( 
            "findAsciiToFloat"
            , findAsciiToFloat_function_type( &::osg::findAsciiToFloat )
            , ( bp::arg("str") )
            , " Detect first ascii POSITIVE number in string and convert to double." );
    
    }

    { //::osg::flushAllDeletedGLObjects
    
        typedef void ( *flushAllDeletedGLObjects_function_type )( unsigned int );
        
        bp::def( 
            "flushAllDeletedGLObjects"
            , flushAllDeletedGLObjects_function_type( &::osg::flushAllDeletedGLObjects )
            , ( bp::arg("contextID") )
            , " Flush all deleted OpenGL objects.\n Note, must be called from a thread which has current the graphics context associated with contextID." );
    
    }

    { //::osg::flushDeletedGLObjects
    
        typedef void ( *flushDeletedGLObjects_function_type )( unsigned int,double,double & );
        
        bp::def( 
            "flushDeletedGLObjects"
            , flushDeletedGLObjects_function_type( &::osg::flushDeletedGLObjects )
            , ( bp::arg("contextID"), bp::arg("currentTime"), bp::arg("availableTime") )
            , " Flush all deleted OpenGL objects within the specified availableTime.\n Note, must be called from a thread which has current the graphics context associated with contextID." );
    
    }

    { //::osg::getBinding
    
        typedef ::osg::Array::Binding ( *getBinding_function_type )( ::osg::Array const * );
        
        bp::def( 
            "getBinding"
            , getBinding_function_type( &::osg::getBinding )
            , ( bp::arg("array") )
            , " convinience function for getting the binding of array via a ptr that may be null." );
    
    }

    { //::osg::getCpuByteOrder
    
        typedef ::osg::Endian ( *getCpuByteOrder_function_type )(  );
        
        bp::def( 
            "getCpuByteOrder"
            , getCpuByteOrder_function_type( &::osg::getCpuByteOrder ) );
    
    }

    { //::osg::getGLExtensionDisableString
    
        typedef ::std::string & ( *getGLExtensionDisableString_function_type )(  );
        
        bp::def( 
            "getGLExtensionDisableString"
            , getGLExtensionDisableString_function_type( &::osg::getGLExtensionDisableString )
            , bp::return_value_policy< bp::copy_non_const_reference >()
            , " Get the list of extensions that are disabled for various OpenGL renderers." );
    
    }

    { //::osg::getGLExtensionFuncPtr
    
        typedef void * ( *getGLExtensionFuncPtr_function_type )( char const *,char const *,char const * );
        
        bp::def( 
            "getGLExtensionFuncPtr"
            , getGLExtensionFuncPtr_function_type( &::osg::getGLExtensionFuncPtr )
            , ( bp::arg("funcName1"), bp::arg("funcName2"), bp::arg("funcName3") )
            , bp::return_value_policy< bp::return_opaque_pointer >()
            , " Return the address of the specified OpenGL function. If not found then\n check a second function name, if this fails then return NULL as function is\n not supported by OpenGL library. This is used for checking something\n like glActiveTexture (which is in OGL1.3) or glActiveTextureARB." );
    
    }

    { //::osg::getGLExtensionFuncPtr
    
        typedef void * ( *getGLExtensionFuncPtr_function_type )( char const *,char const * );
        
        bp::def( 
            "getGLExtensionFuncPtr"
            , getGLExtensionFuncPtr_function_type( &::osg::getGLExtensionFuncPtr )
            , ( bp::arg("funcName"), bp::arg("fallbackFuncName") )
            , bp::return_value_policy< bp::return_opaque_pointer >()
            , " Return the address of the specified OpenGL function. If not found then\n check a second function name, if this fails then return NULL as function is\n not supported by OpenGL library. This is used for checking something\n like glActiveTexture (which is in OGL1.3) or glActiveTextureARB." );
    
    }

    { //::osg::getGLExtensionFuncPtr
    
        typedef void * ( *getGLExtensionFuncPtr_function_type )( char const * );
        
        bp::def( 
            "getGLExtensionFuncPtr"
            , getGLExtensionFuncPtr_function_type( &::osg::getGLExtensionFuncPtr )
            , ( bp::arg("funcName") )
            , bp::return_value_policy< bp::return_opaque_pointer >()
            , " Return the address of the specified OpenGL function.\n Return NULL if function not supported by OpenGL library.\n Note, glGLExtensionFuncPtr is declared inline so that the code\n is compiled locally to the calling code.  This should get by Windows\n dumb implementation of having different GL function ptrs for each\n library when linked to it." );
    
    }

    { //::osg::getGLVersionNumber
    
        typedef float ( *getGLVersionNumber_function_type )(  );
        
        bp::def( 
            "getGLVersionNumber"
            , getGLVersionNumber_function_type( &::osg::getGLVersionNumber )
            , " Return floating-point OpenGL version number.\n Note: Must only be called within a valid OpenGL context,\n undefined behavior may occur otherwise." );
    
    }

    { //::osg::getNormalize
    
        typedef bool ( *getNormalize_function_type )( ::osg::Array const * );
        
        bp::def( 
            "getNormalize"
            , getNormalize_function_type( &::osg::getNormalize )
            , ( bp::arg("array") )
            , " convinience function for getting the binding of array via a ptr that may be null." );
    
    }

    { //::osg::getNotifyHandler
    
        typedef ::osg::NotifyHandler * ( *getNotifyHandler_function_type )(  );
        
        bp::def( 
            "getNotifyHandler"
            , getNotifyHandler_function_type( &::osg::getNotifyHandler )
            , bp::return_value_policy< bp::reference_existing_object >()
            , " Get currrent notification handler." );
    
    }

    { //::osg::getNotifyLevel
    
        typedef ::osg::NotifySeverity ( *getNotifyLevel_function_type )(  );
        
        bp::def( 
            "getNotifyLevel"
            , getNotifyLevel_function_type( &::osg::getNotifyLevel )
            , " get the notify level." );
    
    }

    { //::osg::gluBuild1DMipmapLevels
    
        typedef ::GLint ( *gluBuild1DMipmapLevels_function_type )( ::GLenum,::GLint,::GLsizei,::GLenum,::GLenum,::GLint,::GLint,::GLint,void const * );
        
        bp::def( 
            "gluBuild1DMipmapLevels"
            , gluBuild1DMipmapLevels_function_type( &::osg::gluBuild1DMipmapLevels )
            , ( bp::arg("target"), bp::arg("internalFormat"), bp::arg("width"), bp::arg("format"), bp::arg("type"), bp::arg("level"), bp::arg("base"), bp::arg("max"), bp::arg("data") ) );
    
    }

    { //::osg::gluBuild1DMipmaps
    
        typedef ::GLint ( *gluBuild1DMipmaps_function_type )( ::GLenum,::GLint,::GLsizei,::GLenum,::GLenum,void const * );
        
        bp::def( 
            "gluBuild1DMipmaps"
            , gluBuild1DMipmaps_function_type( &::osg::gluBuild1DMipmaps )
            , ( bp::arg("target"), bp::arg("internalFormat"), bp::arg("width"), bp::arg("format"), bp::arg("type"), bp::arg("data") ) );
    
    }

    { //::osg::gluBuild2DMipmapLevels
    
        typedef ::GLint ( *gluBuild2DMipmapLevels_function_type )( ::GLenum,::GLint,::GLsizei,::GLsizei,::GLenum,::GLenum,::GLint,::GLint,::GLint,void const * );
        
        bp::def( 
            "gluBuild2DMipmapLevels"
            , gluBuild2DMipmapLevels_function_type( &::osg::gluBuild2DMipmapLevels )
            , ( bp::arg("target"), bp::arg("internalFormat"), bp::arg("width"), bp::arg("height"), bp::arg("format"), bp::arg("type"), bp::arg("level"), bp::arg("base"), bp::arg("max"), bp::arg("data") ) );
    
    }

    { //::osg::gluBuild2DMipmaps
    
        typedef ::GLint ( *gluBuild2DMipmaps_function_type )( ::GLenum,::GLint,::GLsizei,::GLsizei,::GLenum,::GLenum,void const * );
        
        bp::def( 
            "gluBuild2DMipmaps"
            , gluBuild2DMipmaps_function_type( &::osg::gluBuild2DMipmaps )
            , ( bp::arg("target"), bp::arg("internalFormat"), bp::arg("width"), bp::arg("height"), bp::arg("format"), bp::arg("type"), bp::arg("data") ) );
    
    }

    { //::osg::gluScaleImage
    
        typedef ::GLint ( *gluScaleImage_function_type )( ::GLenum,::GLsizei,::GLsizei,::GLenum,void const *,::GLsizei,::GLsizei,::GLenum,::GLvoid * );
        
        bp::def( 
            "gluScaleImage"
            , gluScaleImage_function_type( &::osg::gluScaleImage )
            , ( bp::arg("format"), bp::arg("wIn"), bp::arg("hIn"), bp::arg("typeIn"), bp::arg("dataIn"), bp::arg("wOut"), bp::arg("hOut"), bp::arg("typeOut"), bp::arg("dataOut") )
            , " Traditional GLU gluScaleImage function that sets up the PixelStoreModes automatically by doing glGets.;\n The use of glGets means that you can only call this function from a thread with a valid graphics context.\n The use of glGets will also result in lower performance due to the round trip to the OpenGL driver." );
    
    }

    { //::osg::gluScaleImage
    
        typedef ::GLint ( *gluScaleImage_function_type )( ::osg::PixelStorageModes *,::GLenum,::GLsizei,::GLsizei,::GLenum,void const *,::GLsizei,::GLsizei,::GLenum,::GLvoid * );
        
        bp::def( 
            "gluScaleImage"
            , gluScaleImage_function_type( &::osg::gluScaleImage )
            , ( bp::arg("psm"), bp::arg("format"), bp::arg("wIn"), bp::arg("hIn"), bp::arg("typeIn"), bp::arg("dataIn"), bp::arg("wOut"), bp::arg("hOut"), bp::arg("typeOut"), bp::arg("dataOut") )
            , " OSG specific gluScaleImage function that allows you to pass in the PixelStoreModes, which\n enables the code to avoid glGets that are associated with the conventional gluScaleImage function.\n Avoiding glGets allows this gluScaleImage function to be called at any time, from any thread, there\n is no need to have a graphics context current." );
    
    }

    { //::osg::inDegrees
    
        typedef double ( *inDegrees_function_type )( double );
        
        bp::def( 
            "inDegrees"
            , inDegrees_function_type( &::osg::inDegrees )
            , ( bp::arg("angle") ) );
    
    }

    { //::osg::inDegrees
    
        typedef float ( *inDegrees_function_type )( float );
        
        bp::def( 
            "inDegrees"
            , inDegrees_function_type( &::osg::inDegrees )
            , ( bp::arg("angle") ) );
    
    }

    { //::osg::initNotifyLevel
    
        typedef bool ( *initNotifyLevel_function_type )(  );
        
        bp::def( 
            "initNotifyLevel"
            , initNotifyLevel_function_type( &::osg::initNotifyLevel )
            , " initialize notify level." );
    
    }

    { //::osg::intrusive_ptr_add_ref
    
        typedef void ( *intrusive_ptr_add_ref_function_type )( ::osg::Referenced * );
        
        bp::def( 
            "intrusive_ptr_add_ref"
            , intrusive_ptr_add_ref_function_type( &::osg::intrusive_ptr_add_ref )
            , ( bp::arg("p") ) );
    
    }

    { //::osg::intrusive_ptr_release
    
        typedef void ( *intrusive_ptr_release_function_type )( ::osg::Referenced * );
        
        bp::def( 
            "intrusive_ptr_release"
            , intrusive_ptr_release_function_type( &::osg::intrusive_ptr_release )
            , ( bp::arg("p") ) );
    
    }

    { //::osg::isExtensionInExtensionString
    
        typedef bool ( *isExtensionInExtensionString_function_type )( char const *,char const * );
        
        bp::def( 
            "isExtensionInExtensionString"
            , isExtensionInExtensionString_function_type( &::osg::isExtensionInExtensionString )
            , ( bp::arg("extension"), bp::arg("extensionString") )
            , " Return true if extension is contained in extensionString." );
    
    }

    { //::osg::isGLExtensionOrVersionSupported
    
        typedef bool ( *isGLExtensionOrVersionSupported_function_type )( unsigned int,char const *,float );
        
        bp::def( 
            "isGLExtensionOrVersionSupported"
            , isGLExtensionOrVersionSupported_function_type( &::osg::isGLExtensionOrVersionSupported )
            , ( bp::arg("contextID"), bp::arg("extension"), bp::arg("requiredGlVersion") )
            , " Return true if OpenGL extension or minimum OpenGL version number is supported.\n Note: Must only be called within a valid OpenGL context,\n undefined behavior may occur otherwise." );
    
    }

    { //::osg::isGLExtensionSupported
    
        typedef bool ( *isGLExtensionSupported_function_type )( unsigned int,char const * );
        
        bp::def( 
            "isGLExtensionSupported"
            , isGLExtensionSupported_function_type( &::osg::isGLExtensionSupported )
            , ( bp::arg("contextID"), bp::arg("extension") )
            , " Return true if OpenGL extension is supported.\n Note: Must only be called within a valid OpenGL context,\n undefined behavior may occur otherwise." );
    
    }

    { //::osg::isNaN
    
        typedef bool ( *isNaN_function_type )( double );
        
        bp::def( 
            "isNaN"
            , isNaN_function_type( &::osg::isNaN )
            , ( bp::arg("v") ) );
    
    }

    { //::osg::isNaN
    
        typedef bool ( *isNaN_function_type )( float );
        
        bp::def( 
            "isNaN"
            , isNaN_function_type( &::osg::isNaN )
            , ( bp::arg("v") ) );
    
    }

    { //::osg::isNotifyEnabled
    
        typedef bool ( *isNotifyEnabled_function_type )( ::osg::NotifySeverity );
        
        bp::def( 
            "isNotifyEnabled"
            , isNotifyEnabled_function_type( &::osg::isNotifyEnabled )
            , ( bp::arg("severity") )
            , " is notification enabled, given the current setNotifyLevel() setting?" );
    
    }

    { //::osg::isTextureMode
    
        typedef bool ( *isTextureMode_function_type )( ::GLenum );
        
        bp::def( 
            "isTextureMode"
            , isTextureMode_function_type( &::osg::isTextureMode )
            , ( bp::arg("mode") ) );
    
    }

    { //::osg::maximimNumOfComponents
    
        typedef unsigned int ( *maximimNumOfComponents_function_type )( ::osg::ImageList const & );
        
        bp::def( 
            "maximimNumOfComponents"
            , maximimNumOfComponents_function_type( &::osg::maximimNumOfComponents )
            , ( bp::arg("imageList") )
            , " Search through the list of Images and find the maximum number of components used amoung the images." );
    
    }

    { //::osg::maximum
    
        typedef int ( *maximum_function_type )( int,int );
        
        bp::def( 
            "maximum"
            , maximum_function_type( &::osg::maximum )
            , ( bp::arg("lhs"), bp::arg("rhs") )
            , " return the maximum of two values, equivalent to std::max.\n std::max not used because of STL implementation under IRIX not containing\n std::max." );
    
    }

    { //::osg::notify
    
        typedef ::std::ostream & ( *notify_function_type )(  );
        
        bp::def( 
            "notify"
            , notify_function_type( &::osg::notify )
            , bp::return_value_policy< bp::reference_existing_object >() );
    
    }

    { //::osg::notify
    
        typedef ::std::ostream & ( *notify_function_type )( ::osg::NotifySeverity const );
        
        bp::def( 
            "notify"
            , notify_function_type( &::osg::notify )
            , ( bp::arg("severity") )
            , bp::return_value_policy< bp::reference_existing_object >()
            , " notify messaging function for providing fatal through to verbose\n debugging messages.  Level of messages sent to the console can\n be controlled by setting the NotifyLevel either within your\n application or via the an environmental variable i.e.\n - setenv OSGNOTIFYLEVEL DEBUG (for tsh)\n - export OSGNOTIFYLEVEL=DEBUG (for bourne shell)\n - set OSGNOTIFYLEVEL=DEBUG (for Windows)\n\n All tell the osg to redirect all debugging and more important messages\n to the notification stream (useful for debugging) setting ALWAYS will force\n all messages to be absorbed, which might be appropriate for final\n applications.  Default NotifyLevel is NOTICE.  Check the enum\n #NotifySeverity for full range of possibilities.  To use the notify\n with your code simply use the notify function as a normal file\n stream (like std::cout) i.e\n [Code]\n osg::notify(osg::DEBUG) << Hello Bugs! << std::endl;\n E:ndcode\n aee setNotifyLevel, setNotifyHandler" );
    
    }

    { //::osg::offsetAndScaleImage
    
        typedef bool ( *offsetAndScaleImage_function_type )( ::osg::Image *,::osg::Vec4 const &,::osg::Vec4 const & );
        
        bp::def( 
            "offsetAndScaleImage"
            , offsetAndScaleImage_function_type( &::osg::offsetAndScaleImage )
            , ( bp::arg("image"), bp::arg("offset"), bp::arg("scale") )
            , " Compute the min max colour values in the image." );
    
    }

    { //::osgGetLibraryName
    
        typedef char const * ( *osgGetLibraryName_function_type )(  );
        
        bp::def( 
            "osgGetLibraryName"
            , osgGetLibraryName_function_type( &::osgGetLibraryName )
            , " The osgGetLibraryName() method returns the library name in human-friendly form." );
    
    }

    { //::osgGetSOVersion
    
        typedef char const * ( *osgGetSOVersion_function_type )(  );
        
        bp::def( 
            "osgGetSOVersion"
            , osgGetSOVersion_function_type( &::osgGetSOVersion )
            , " The osgGetSOVersion() method returns the OpenSceneGraph shared object version number." );
    
    }

    { //::osgGetVersion
    
        typedef char const * ( *osgGetVersion_function_type )(  );
        
        bp::def( 
            "osgGetVersion"
            , osgGetVersion_function_type( &::osgGetVersion )
            , " osgGetVersion() returns the library version number.\n Numbering convention : OpenSceneGraph-1.0 will return 1.0 from osgGetVersion.\n\n This C function can be also used to check for the existence of the OpenSceneGraph\n library using autoconf and its m4 macro AC_CHECK_LIB.\n\n Here is the code to add to your configure.in:\n Verbatim:\n #\n # Check for the OpenSceneGraph (OSG) library\n #\n AC_CHECK_LIB(osg, osgGetVersion, ,\n    [AC_MSG_ERROR(OpenSceneGraph library not found. See http://www.openscenegraph.org)],)\n E:ndverbatim" );
    
    }

    { //::osg::round
    
        typedef double ( *round_function_type )( double );
        
        bp::def( 
            "round"
            , round_function_type( &::osg::round )
            , ( bp::arg("v") ) );
    
    }

    { //::osg::round
    
        typedef float ( *round_function_type )( float );
        
        bp::def( 
            "round"
            , round_function_type( &::osg::round )
            , ( bp::arg("v") ) );
    
    }

    { //::osg::setGLExtensionDisableString
    
        typedef void ( *setGLExtensionDisableString_function_type )( ::std::string const & );
        
        bp::def( 
            "setGLExtensionDisableString"
            , setGLExtensionDisableString_function_type( &::osg::setGLExtensionDisableString )
            , ( bp::arg("disableString") )
            , " Set a list of extensions to disable for different OpenGL renderers. This allows\n OSG applications to work around OpenGL drivers bugs which are due to problematic extension support.\n The format of the string is:\n GLRendererString : ExtensionName, ExtensionName; GLRenderString2 : ExtensionName;\n An example of is : SUN_XVR1000:GL_EXT_texture_filter_anisotropic\n The default setting of GLExtensionDisableString is obtained from the OSG_GL_EXTENSION_DISABLE\n environmental variable." );
    
    }

    { //::osg::setNotifyHandler
    
        typedef void ( *setNotifyHandler_function_type )( ::osg::NotifyHandler * );
        
        bp::def( 
            "setNotifyHandler"
            , setNotifyHandler_function_type( &::osg::setNotifyHandler )
            , ( bp::arg("handler") )
            , " Set notification handler, by default StandardNotifyHandler is used.\n aee NotifyHandler" );
    
    }

    { //::osg::setNotifyLevel
    
        typedef void ( *setNotifyLevel_function_type )( ::osg::NotifySeverity );
        
        bp::def( 
            "setNotifyLevel"
            , setNotifyLevel_function_type( &::osg::setNotifyLevel )
            , ( bp::arg("severity") )
            , " set the notify level, overriding the default or the value set by\n the environmental variable OSGNOTIFYLEVEL or OSG_NOTIFY_LEVEL." );
    
    }

    { //::osg::swapBytes
    
        typedef void ( *swapBytes_function_type )( char *,unsigned int );
        
        bp::def( 
            "swapBytes"
            , swapBytes_function_type( &::osg::swapBytes )
            , ( bp::arg("in"), bp::arg("size") ) );
    
    }

    { //::osg::swapBytes16
    
        typedef void ( *swapBytes16_function_type )( char * );
        
        bp::def( 
            "swapBytes16"
            , swapBytes16_function_type( &::osg::swapBytes16 )
            , ( bp::arg("in") ) );
    
    }

    { //::osg::swapBytes2
    
        typedef void ( *swapBytes2_function_type )( char * );
        
        bp::def( 
            "swapBytes2"
            , swapBytes2_function_type( &::osg::swapBytes2 )
            , ( bp::arg("in") ) );
    
    }

    { //::osg::swapBytes4
    
        typedef void ( *swapBytes4_function_type )( char * );
        
        bp::def( 
            "swapBytes4"
            , swapBytes4_function_type( &::osg::swapBytes4 )
            , ( bp::arg("in") ) );
    
    }

    { //::osg::swapBytes8
    
        typedef void ( *swapBytes8_function_type )( char * );
        
        bp::def( 
            "swapBytes8"
            , swapBytes8_function_type( &::osg::swapBytes8 )
            , ( bp::arg("in") ) );
    
    }

}
