// This file has been generated by Py++.

#include "boost/python.hpp"
#include "wrap_osg.h"
#include "wrap_referenced.h"
#include "Group.pypp.hpp"

namespace bp = boost::python;

struct Group_wrapper : osg::Group, bp::wrapper< osg::Group > {

    Group_wrapper( )
    : osg::Group( )
      , bp::wrapper< osg::Group >(){
        // null constructor
    
    }

    virtual void accept( ::osg::NodeVisitor & nv ) {
        if( bp::override func_accept = this->get_override( "accept" ) )
            func_accept( boost::ref(nv) );
        else{
            this->osg::Group::accept( boost::ref(nv) );
        }
    }
    
    void default_accept( ::osg::NodeVisitor & nv ) {
        osg::Group::accept( boost::ref(nv) );
    }

    virtual bool addChild( ::osg::Node * child ) {
        if( bp::override func_addChild = this->get_override( "addChild" ) )
            return func_addChild( boost::python::ptr(child) );
        else{
            return this->osg::Group::addChild( boost::python::ptr(child) );
        }
    }
    
    bool default_addChild( ::osg::Node * child ) {
        return osg::Group::addChild( boost::python::ptr(child) );
    }

    virtual ::osg::Group * asGroup(  ) {
        if( bp::override func_asGroup = this->get_override( "asGroup" ) )
            return func_asGroup(  );
        else{
            return this->osg::Group::asGroup(  );
        }
    }
    
    ::osg::Group * default_asGroup(  ) {
        return osg::Group::asGroup( );
    }

    virtual ::osg::Group const * asGroup(  ) const  {
        if( bp::override func_asGroup = this->get_override( "asGroup" ) )
            return func_asGroup(  );
        else{
            return this->osg::Group::asGroup(  );
        }
    }
    
    ::osg::Group const * default_asGroup(  ) const  {
        return osg::Group::asGroup( );
    }

    virtual char const * className(  ) const  {
        if( bp::override func_className = this->get_override( "className" ) )
            return func_className(  );
        else{
            return this->osg::Group::className(  );
        }
    }
    
    char const * default_className(  ) const  {
        return osg::Group::className( );
    }

    virtual ::osg::Object * clone( ::osg::CopyOp const & copyop ) const  {
        if( bp::override func_clone = this->get_override( "clone" ) )
            return func_clone( boost::ref(copyop) );
        else{
            return this->osg::Group::clone( boost::ref(copyop) );
        }
    }
    
    ::osg::Object * default_clone( ::osg::CopyOp const & copyop ) const  {
        return osg::Group::clone( boost::ref(copyop) );
    }

    virtual ::osg::Object * cloneType(  ) const  {
        if( bp::override func_cloneType = this->get_override( "cloneType" ) )
            return func_cloneType(  );
        else{
            return this->osg::Group::cloneType(  );
        }
    }
    
    ::osg::Object * default_cloneType(  ) const  {
        return osg::Group::cloneType( );
    }

    virtual ::osg::BoundingSphere computeBound(  ) const  {
        if( bp::override func_computeBound = this->get_override( "computeBound" ) )
            return func_computeBound(  );
        else{
            return this->osg::Group::computeBound(  );
        }
    }
    
    ::osg::BoundingSphere default_computeBound(  ) const  {
        return osg::Group::computeBound( );
    }

    virtual bool insertChild( unsigned int index, ::osg::Node * child ) {
        if( bp::override func_insertChild = this->get_override( "insertChild" ) )
            return func_insertChild( index, boost::python::ptr(child) );
        else{
            return this->osg::Group::insertChild( index, boost::python::ptr(child) );
        }
    }
    
    bool default_insertChild( unsigned int index, ::osg::Node * child ) {
        return osg::Group::insertChild( index, boost::python::ptr(child) );
    }

    virtual bool isSameKindAs( ::osg::Object const * obj ) const  {
        if( bp::override func_isSameKindAs = this->get_override( "isSameKindAs" ) )
            return func_isSameKindAs( boost::python::ptr(obj) );
        else{
            return this->osg::Group::isSameKindAs( boost::python::ptr(obj) );
        }
    }
    
    bool default_isSameKindAs( ::osg::Object const * obj ) const  {
        return osg::Group::isSameKindAs( boost::python::ptr(obj) );
    }

    virtual char const * libraryName(  ) const  {
        if( bp::override func_libraryName = this->get_override( "libraryName" ) )
            return func_libraryName(  );
        else{
            return this->osg::Group::libraryName(  );
        }
    }
    
    char const * default_libraryName(  ) const  {
        return osg::Group::libraryName( );
    }

    virtual bool removeChildren( unsigned int pos, unsigned int numChildrenToRemove ) {
        if( bp::override func_removeChildren = this->get_override( "removeChildren" ) )
            return func_removeChildren( pos, numChildrenToRemove );
        else{
            return this->osg::Group::removeChildren( pos, numChildrenToRemove );
        }
    }
    
    bool default_removeChildren( unsigned int pos, unsigned int numChildrenToRemove ) {
        return osg::Group::removeChildren( pos, numChildrenToRemove );
    }

    virtual bool replaceChild( ::osg::Node * origChild, ::osg::Node * newChild ) {
        if( bp::override func_replaceChild = this->get_override( "replaceChild" ) )
            return func_replaceChild( boost::python::ptr(origChild), boost::python::ptr(newChild) );
        else{
            return this->osg::Group::replaceChild( boost::python::ptr(origChild), boost::python::ptr(newChild) );
        }
    }
    
    bool default_replaceChild( ::osg::Node * origChild, ::osg::Node * newChild ) {
        return osg::Group::replaceChild( boost::python::ptr(origChild), boost::python::ptr(newChild) );
    }

    virtual void resizeGLObjectBuffers( unsigned int maxSize ) {
        if( bp::override func_resizeGLObjectBuffers = this->get_override( "resizeGLObjectBuffers" ) )
            func_resizeGLObjectBuffers( maxSize );
        else{
            this->osg::Group::resizeGLObjectBuffers( maxSize );
        }
    }
    
    void default_resizeGLObjectBuffers( unsigned int maxSize ) {
        osg::Group::resizeGLObjectBuffers( maxSize );
    }

    virtual bool setChild( unsigned int i, ::osg::Node * node ) {
        if( bp::override func_setChild = this->get_override( "setChild" ) )
            return func_setChild( i, boost::python::ptr(node) );
        else{
            return this->osg::Group::setChild( i, boost::python::ptr(node) );
        }
    }
    
    bool default_setChild( unsigned int i, ::osg::Node * node ) {
        return osg::Group::setChild( i, boost::python::ptr(node) );
    }

    virtual void setThreadSafeRefUnref( bool threadSafe ) {
        if( bp::override func_setThreadSafeRefUnref = this->get_override( "setThreadSafeRefUnref" ) )
            func_setThreadSafeRefUnref( threadSafe );
        else{
            this->osg::Group::setThreadSafeRefUnref( threadSafe );
        }
    }
    
    void default_setThreadSafeRefUnref( bool threadSafe ) {
        osg::Group::setThreadSafeRefUnref( threadSafe );
    }

    virtual void traverse( ::osg::NodeVisitor & nv ) {
        if( bp::override func_traverse = this->get_override( "traverse" ) )
            func_traverse( boost::ref(nv) );
        else{
            this->osg::Group::traverse( boost::ref(nv) );
        }
    }
    
    void default_traverse( ::osg::NodeVisitor & nv ) {
        osg::Group::traverse( boost::ref(nv) );
    }

    virtual ::osg::Camera * asCamera(  ) {
        if( bp::override func_asCamera = this->get_override( "asCamera" ) )
            return func_asCamera(  );
        else{
            return this->osg::Node::asCamera(  );
        }
    }
    
    ::osg::Camera * default_asCamera(  ) {
        return osg::Node::asCamera( );
    }

    virtual ::osg::Camera const * asCamera(  ) const  {
        if( bp::override func_asCamera = this->get_override( "asCamera" ) )
            return func_asCamera(  );
        else{
            return this->osg::Node::asCamera(  );
        }
    }
    
    ::osg::Camera const * default_asCamera(  ) const  {
        return osg::Node::asCamera( );
    }

    virtual ::osg::Geode * asGeode(  ) {
        if( bp::override func_asGeode = this->get_override( "asGeode" ) )
            return func_asGeode(  );
        else{
            return this->osg::Node::asGeode(  );
        }
    }
    
    ::osg::Geode * default_asGeode(  ) {
        return osg::Node::asGeode( );
    }

    virtual ::osg::Geode const * asGeode(  ) const  {
        if( bp::override func_asGeode = this->get_override( "asGeode" ) )
            return func_asGeode(  );
        else{
            return this->osg::Node::asGeode(  );
        }
    }
    
    ::osg::Geode const * default_asGeode(  ) const  {
        return osg::Node::asGeode( );
    }

    virtual ::osg::Switch * asSwitch(  ) {
        if( bp::override func_asSwitch = this->get_override( "asSwitch" ) )
            return func_asSwitch(  );
        else{
            return this->osg::Node::asSwitch(  );
        }
    }
    
    ::osg::Switch * default_asSwitch(  ) {
        return osg::Node::asSwitch( );
    }

    virtual ::osg::Switch const * asSwitch(  ) const  {
        if( bp::override func_asSwitch = this->get_override( "asSwitch" ) )
            return func_asSwitch(  );
        else{
            return this->osg::Node::asSwitch(  );
        }
    }
    
    ::osg::Switch const * default_asSwitch(  ) const  {
        return osg::Node::asSwitch( );
    }

    virtual ::osg::Transform * asTransform(  ) {
        if( bp::override func_asTransform = this->get_override( "asTransform" ) )
            return func_asTransform(  );
        else{
            return this->osg::Node::asTransform(  );
        }
    }
    
    ::osg::Transform * default_asTransform(  ) {
        return osg::Node::asTransform( );
    }

    virtual ::osg::Transform const * asTransform(  ) const  {
        if( bp::override func_asTransform = this->get_override( "asTransform" ) )
            return func_asTransform(  );
        else{
            return this->osg::Node::asTransform(  );
        }
    }
    
    ::osg::Transform const * default_asTransform(  ) const  {
        return osg::Node::asTransform( );
    }

    virtual void ascend( ::osg::NodeVisitor & nv ) {
        if( bp::override func_ascend = this->get_override( "ascend" ) )
            func_ascend( boost::ref(nv) );
        else{
            this->osg::Node::ascend( boost::ref(nv) );
        }
    }
    
    void default_ascend( ::osg::NodeVisitor & nv ) {
        osg::Node::ascend( boost::ref(nv) );
    }

};

void register_Group_class(){

    bp::class_< Group_wrapper, bp::bases< osg::Node >, osg::ref_ptr< ::osg::Group >, boost::noncopyable >( "Group", "\n General group node which maintains a list of children.\n Children are reference counted. This allows children to be shared\n with memory management handled automatically via osg::Referenced.\n", bp::no_init )    
        .def( bp::init< >("\n General group node which maintains a list of children.\n Children are reference counted. This allows children to be shared\n with memory management handled automatically via osg::Referenced.\n") )    
        .def( 
            "accept"
            , (void ( ::osg::Group::* )( ::osg::NodeVisitor & ) )(&::osg::Group::accept)
            , (void ( Group_wrapper::* )( ::osg::NodeVisitor & ) )(&Group_wrapper::default_accept)
            , ( bp::arg("nv") ) )    
        .def( 
            "addChild"
            , (bool ( ::osg::Group::* )( ::osg::Node * ) )(&::osg::Group::addChild)
            , (bool ( Group_wrapper::* )( ::osg::Node * ) )(&Group_wrapper::default_addChild)
            , ( bp::arg("child") ) )    
        .def( 
            "asGroup"
            , (::osg::Group * ( ::osg::Group::* )(  ) )(&::osg::Group::asGroup)
            , (::osg::Group * ( Group_wrapper::* )(  ) )(&Group_wrapper::default_asGroup)
            , bp::return_internal_reference< >() )    
        .def( 
            "asGroup"
            , (::osg::Group const * ( ::osg::Group::* )(  ) const)(&::osg::Group::asGroup)
            , (::osg::Group const * ( Group_wrapper::* )(  ) const)(&Group_wrapper::default_asGroup)
            , bp::return_internal_reference< >() )    
        .def( 
            "className"
            , (char const * ( ::osg::Group::* )(  ) const)(&::osg::Group::className)
            , (char const * ( Group_wrapper::* )(  ) const)(&Group_wrapper::default_className) )    
        .def( 
            "clone"
            , (::osg::Object * ( ::osg::Group::* )( ::osg::CopyOp const & ) const)(&::osg::Group::clone)
            , (::osg::Object * ( Group_wrapper::* )( ::osg::CopyOp const & ) const)(&Group_wrapper::default_clone)
            , ( bp::arg("copyop") )
            , bp::return_value_policy< bp::reference_existing_object >() )    
        .def( 
            "cloneType"
            , (::osg::Object * ( ::osg::Group::* )(  ) const)(&::osg::Group::cloneType)
            , (::osg::Object * ( Group_wrapper::* )(  ) const)(&Group_wrapper::default_cloneType)
            , bp::return_value_policy< bp::reference_existing_object >() )    
        .def( 
            "computeBound"
            , (::osg::BoundingSphere ( ::osg::Group::* )(  ) const)(&::osg::Group::computeBound)
            , (::osg::BoundingSphere ( Group_wrapper::* )(  ) const)(&Group_wrapper::default_computeBound) )    
        .def( 
            "containsNode"
            , (bool ( ::osg::Group::* )( ::osg::Node const * ) const)( &::osg::Group::containsNode )
            , ( bp::arg("node") )
            , " Return true if node is contained within Group." )    
        .def( 
            "getChild"
            , (::osg::Node * ( ::osg::Group::* )( unsigned int ) )( &::osg::Group::getChild )
            , ( bp::arg("i") )
            , bp::return_internal_reference< >()
            , " Return child node at position i." )    
        .def( 
            "getChild"
            , (::osg::Node const * ( ::osg::Group::* )( unsigned int ) const)( &::osg::Group::getChild )
            , ( bp::arg("i") )
            , bp::return_internal_reference< >()
            , " Return child node at position i." )    
        .def( 
            "getChildIndex"
            , (unsigned int ( ::osg::Group::* )( ::osg::Node const * ) const)( &::osg::Group::getChildIndex )
            , ( bp::arg("node") )
            , " Get the index number of child, return a value between\n 0 and _children.size()-1 if found, if not found then\n return _children.size()." )    
        .def( 
            "getNumChildren"
            , (unsigned int ( ::osg::Group::* )(  ) const)( &::osg::Group::getNumChildren )
            , " Return the number of children nodes." )    
        .def( 
            "insertChild"
            , (bool ( ::osg::Group::* )( unsigned int,::osg::Node * ) )(&::osg::Group::insertChild)
            , (bool ( Group_wrapper::* )( unsigned int,::osg::Node * ) )(&Group_wrapper::default_insertChild)
            , ( bp::arg("index"), bp::arg("child") ) )    
        .def( 
            "isSameKindAs"
            , (bool ( ::osg::Group::* )( ::osg::Object const * ) const)(&::osg::Group::isSameKindAs)
            , (bool ( Group_wrapper::* )( ::osg::Object const * ) const)(&Group_wrapper::default_isSameKindAs)
            , ( bp::arg("obj") ) )    
        .def( 
            "libraryName"
            , (char const * ( ::osg::Group::* )(  ) const)(&::osg::Group::libraryName)
            , (char const * ( Group_wrapper::* )(  ) const)(&Group_wrapper::default_libraryName) )    
        .def( 
            "removeChild"
            , (bool ( ::osg::Group::* )( ::osg::Node * ) )( &::osg::Group::removeChild )
            , ( bp::arg("child") )
            , " Remove Node from Group.\n If Node is contained in Group then remove it from the child\n list, decrement its reference count, and dirty the\n bounding sphere to force it to recompute on next getBound() and\n return true for success. If Node is not found then return false\n and do not change the reference count of the Node.\n Note, do not override, only override removeChildren(,) is required." )    
        .def( 
            "removeChild"
            , (bool ( ::osg::Group::* )( unsigned int,unsigned int ) )( &::osg::Group::removeChild )
            , ( bp::arg("pos"), bp::arg("numChildrenToRemove")=(unsigned int)(1) )
            , " Remove Node from Group.\n If Node is contained in Group then remove it from the child\n list, decrement its reference count, and dirty the\n bounding sphere to force it to recompute on next getBound() and\n return true for success. If Node is not found then return false\n and do not change the reference count of the Node.\n Note, do not override, only override removeChildren(,) is required." )    
        .def( 
            "removeChildren"
            , (bool ( ::osg::Group::* )( unsigned int,unsigned int ) )(&::osg::Group::removeChildren)
            , (bool ( Group_wrapper::* )( unsigned int,unsigned int ) )(&Group_wrapper::default_removeChildren)
            , ( bp::arg("pos"), bp::arg("numChildrenToRemove") ) )    
        .def( 
            "replaceChild"
            , (bool ( ::osg::Group::* )( ::osg::Node *,::osg::Node * ) )(&::osg::Group::replaceChild)
            , (bool ( Group_wrapper::* )( ::osg::Node *,::osg::Node * ) )(&Group_wrapper::default_replaceChild)
            , ( bp::arg("origChild"), bp::arg("newChild") ) )    
        .def( 
            "resizeGLObjectBuffers"
            , (void ( ::osg::Group::* )( unsigned int ) )(&::osg::Group::resizeGLObjectBuffers)
            , (void ( Group_wrapper::* )( unsigned int ) )(&Group_wrapper::default_resizeGLObjectBuffers)
            , ( bp::arg("maxSize") ) )    
        .def( 
            "setChild"
            , (bool ( ::osg::Group::* )( unsigned int,::osg::Node * ) )(&::osg::Group::setChild)
            , (bool ( Group_wrapper::* )( unsigned int,::osg::Node * ) )(&Group_wrapper::default_setChild)
            , ( bp::arg("i"), bp::arg("node") ) )    
        .def( 
            "setThreadSafeRefUnref"
            , (void ( ::osg::Group::* )( bool ) )(&::osg::Group::setThreadSafeRefUnref)
            , (void ( Group_wrapper::* )( bool ) )(&Group_wrapper::default_setThreadSafeRefUnref)
            , ( bp::arg("threadSafe") ) )    
        .def( 
            "traverse"
            , (void ( ::osg::Group::* )( ::osg::NodeVisitor & ) )(&::osg::Group::traverse)
            , (void ( Group_wrapper::* )( ::osg::NodeVisitor & ) )(&Group_wrapper::default_traverse)
            , ( bp::arg("nv") ) )    
        .def( 
            "asCamera"
            , (::osg::Camera * ( ::osg::Node::* )(  ) )(&::osg::Node::asCamera)
            , (::osg::Camera * ( Group_wrapper::* )(  ) )(&Group_wrapper::default_asCamera)
            , bp::return_internal_reference< >() )    
        .def( 
            "asCamera"
            , (::osg::Camera const * ( ::osg::Node::* )(  ) const)(&::osg::Node::asCamera)
            , (::osg::Camera const * ( Group_wrapper::* )(  ) const)(&Group_wrapper::default_asCamera)
            , bp::return_internal_reference< >() )    
        .def( 
            "asGeode"
            , (::osg::Geode * ( ::osg::Node::* )(  ) )(&::osg::Node::asGeode)
            , (::osg::Geode * ( Group_wrapper::* )(  ) )(&Group_wrapper::default_asGeode)
            , bp::return_internal_reference< >() )    
        .def( 
            "asGeode"
            , (::osg::Geode const * ( ::osg::Node::* )(  ) const)(&::osg::Node::asGeode)
            , (::osg::Geode const * ( Group_wrapper::* )(  ) const)(&Group_wrapper::default_asGeode)
            , bp::return_internal_reference< >() )    
        .def( 
            "asSwitch"
            , (::osg::Switch * ( ::osg::Node::* )(  ) )(&::osg::Node::asSwitch)
            , (::osg::Switch * ( Group_wrapper::* )(  ) )(&Group_wrapper::default_asSwitch)
            , bp::return_internal_reference< >() )    
        .def( 
            "asSwitch"
            , (::osg::Switch const * ( ::osg::Node::* )(  ) const)(&::osg::Node::asSwitch)
            , (::osg::Switch const * ( Group_wrapper::* )(  ) const)(&Group_wrapper::default_asSwitch)
            , bp::return_internal_reference< >() )    
        .def( 
            "asTransform"
            , (::osg::Transform * ( ::osg::Node::* )(  ) )(&::osg::Node::asTransform)
            , (::osg::Transform * ( Group_wrapper::* )(  ) )(&Group_wrapper::default_asTransform)
            , bp::return_internal_reference< >() )    
        .def( 
            "asTransform"
            , (::osg::Transform const * ( ::osg::Node::* )(  ) const)(&::osg::Node::asTransform)
            , (::osg::Transform const * ( Group_wrapper::* )(  ) const)(&Group_wrapper::default_asTransform)
            , bp::return_internal_reference< >() )    
        .def( 
            "ascend"
            , (void ( ::osg::Node::* )( ::osg::NodeVisitor & ) )(&::osg::Node::ascend)
            , (void ( Group_wrapper::* )( ::osg::NodeVisitor & ) )(&Group_wrapper::default_ascend)
            , ( bp::arg("nv") ) );

}
