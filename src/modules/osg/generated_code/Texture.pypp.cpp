// This file has been generated by Py++.

#include "boost/python.hpp"
#include "wrap_osg.h"
#include "wrap_referenced.h"
#include "Texture.pypp.hpp"

namespace bp = boost::python;

struct Texture_wrapper : osg::Texture, bp::wrapper< osg::Texture > {

    virtual void apply( ::osg::State & state ) const {
        bp::override func_apply = this->get_override( "apply" );
        func_apply( boost::ref(state) );
    }

    virtual ::osg::Texture * asTexture(  ) {
        if( bp::override func_asTexture = this->get_override( "asTexture" ) )
            return func_asTexture(  );
        else{
            return this->osg::Texture::asTexture(  );
        }
    }
    
    ::osg::Texture * default_asTexture(  ) {
        return osg::Texture::asTexture( );
    }

    virtual ::osg::Texture const * asTexture(  ) const  {
        if( bp::override func_asTexture = this->get_override( "asTexture" ) )
            return func_asTexture(  );
        else{
            return this->osg::Texture::asTexture(  );
        }
    }
    
    ::osg::Texture const * default_asTexture(  ) const  {
        return osg::Texture::asTexture( );
    }

    virtual char const * className(  ) const  {
        if( bp::override func_className = this->get_override( "className" ) )
            return func_className(  );
        else{
            return this->osg::Texture::className(  );
        }
    }
    
    char const * default_className(  ) const  {
        return osg::Texture::className( );
    }

    virtual ::osg::Object * clone( ::osg::CopyOp const & copyop ) const {
        bp::override func_clone = this->get_override( "clone" );
        return func_clone( boost::ref(copyop) );
    }

    virtual ::osg::Object * cloneType(  ) const {
        bp::override func_cloneType = this->get_override( "cloneType" );
        return func_cloneType(  );
    }

    virtual void compileGLObjects( ::osg::State & state ) const  {
        if( bp::override func_compileGLObjects = this->get_override( "compileGLObjects" ) )
            func_compileGLObjects( boost::ref(state) );
        else{
            this->osg::Texture::compileGLObjects( boost::ref(state) );
        }
    }
    
    void default_compileGLObjects( ::osg::State & state ) const  {
        osg::Texture::compileGLObjects( boost::ref(state) );
    }

    virtual ::osg::Image * getImage( unsigned int face ){
        bp::override func_getImage = this->get_override( "getImage" );
        return func_getImage( face );
    }

    virtual ::osg::Image const * getImage( unsigned int face ) const {
        bp::override func_getImage = this->get_override( "getImage" );
        return func_getImage( face );
    }

    virtual bool getModeUsage( ::osg::StateAttribute::ModeUsage & usage ) const  {
        if( bp::override func_getModeUsage = this->get_override( "getModeUsage" ) )
            return func_getModeUsage( boost::ref(usage) );
        else{
            return this->osg::Texture::getModeUsage( boost::ref(usage) );
        }
    }
    
    bool default_getModeUsage( ::osg::StateAttribute::ModeUsage & usage ) const  {
        return osg::Texture::getModeUsage( boost::ref(usage) );
    }

    virtual unsigned int getNumImages(  ) const {
        bp::override func_getNumImages = this->get_override( "getNumImages" );
        return func_getNumImages(  );
    }

    virtual int getTextureDepth(  ) const  {
        if( bp::override func_getTextureDepth = this->get_override( "getTextureDepth" ) )
            return func_getTextureDepth(  );
        else{
            return this->osg::Texture::getTextureDepth(  );
        }
    }
    
    int default_getTextureDepth(  ) const  {
        return osg::Texture::getTextureDepth( );
    }

    virtual int getTextureHeight(  ) const  {
        if( bp::override func_getTextureHeight = this->get_override( "getTextureHeight" ) )
            return func_getTextureHeight(  );
        else{
            return this->osg::Texture::getTextureHeight(  );
        }
    }
    
    int default_getTextureHeight(  ) const  {
        return osg::Texture::getTextureHeight( );
    }

    virtual ::GLenum getTextureTarget(  ) const {
        bp::override func_getTextureTarget = this->get_override( "getTextureTarget" );
        return func_getTextureTarget(  );
    }

    virtual int getTextureWidth(  ) const  {
        if( bp::override func_getTextureWidth = this->get_override( "getTextureWidth" ) )
            return func_getTextureWidth(  );
        else{
            return this->osg::Texture::getTextureWidth(  );
        }
    }
    
    int default_getTextureWidth(  ) const  {
        return osg::Texture::getTextureWidth( );
    }

    virtual ::osg::StateAttribute::Type getType(  ) const  {
        if( bp::override func_getType = this->get_override( "getType" ) )
            return func_getType(  );
        else{
            return this->osg::Texture::getType(  );
        }
    }
    
    ::osg::StateAttribute::Type default_getType(  ) const  {
        return osg::Texture::getType( );
    }

    virtual bool isSameKindAs( ::osg::Object const * obj ) const  {
        if( bp::override func_isSameKindAs = this->get_override( "isSameKindAs" ) )
            return func_isSameKindAs( boost::python::ptr(obj) );
        else{
            return this->osg::Texture::isSameKindAs( boost::python::ptr(obj) );
        }
    }
    
    bool default_isSameKindAs( ::osg::Object const * obj ) const  {
        return osg::Texture::isSameKindAs( boost::python::ptr(obj) );
    }

    virtual bool isTextureAttribute(  ) const  {
        if( bp::override func_isTextureAttribute = this->get_override( "isTextureAttribute" ) )
            return func_isTextureAttribute(  );
        else{
            return this->osg::Texture::isTextureAttribute(  );
        }
    }
    
    bool default_isTextureAttribute(  ) const  {
        return osg::Texture::isTextureAttribute( );
    }

    virtual char const * libraryName(  ) const  {
        if( bp::override func_libraryName = this->get_override( "libraryName" ) )
            return func_libraryName(  );
        else{
            return this->osg::Texture::libraryName(  );
        }
    }
    
    char const * default_libraryName(  ) const  {
        return osg::Texture::libraryName( );
    }

    virtual void resizeGLObjectBuffers( unsigned int maxSize ) {
        if( bp::override func_resizeGLObjectBuffers = this->get_override( "resizeGLObjectBuffers" ) )
            func_resizeGLObjectBuffers( maxSize );
        else{
            this->osg::Texture::resizeGLObjectBuffers( maxSize );
        }
    }
    
    void default_resizeGLObjectBuffers( unsigned int maxSize ) {
        osg::Texture::resizeGLObjectBuffers( maxSize );
    }

    virtual void setImage( unsigned int face, ::osg::Image * image ){
        bp::override func_setImage = this->get_override( "setImage" );
        func_setImage( face, boost::python::ptr(image) );
    }

    virtual bool checkValidityOfAssociatedModes( ::osg::State & arg0 ) const  {
        if( bp::override func_checkValidityOfAssociatedModes = this->get_override( "checkValidityOfAssociatedModes" ) )
            return func_checkValidityOfAssociatedModes( boost::ref(arg0) );
        else{
            return this->osg::StateAttribute::checkValidityOfAssociatedModes( boost::ref(arg0) );
        }
    }
    
    bool default_checkValidityOfAssociatedModes( ::osg::State & arg0 ) const  {
        return osg::StateAttribute::checkValidityOfAssociatedModes( boost::ref(arg0) );
    }

    virtual void computeDataVariance(  ) {
        if( bp::override func_computeDataVariance = this->get_override( "computeDataVariance" ) )
            func_computeDataVariance(  );
        else{
            this->osg::Object::computeDataVariance(  );
        }
    }
    
    void default_computeDataVariance(  ) {
        osg::Object::computeDataVariance( );
    }

    virtual unsigned int getMember(  ) const  {
        if( bp::override func_getMember = this->get_override( "getMember" ) )
            return func_getMember(  );
        else{
            return this->osg::StateAttribute::getMember(  );
        }
    }
    
    unsigned int default_getMember(  ) const  {
        return osg::StateAttribute::getMember( );
    }

    virtual ::osg::Referenced * getUserData(  ) {
        if( bp::override func_getUserData = this->get_override( "getUserData" ) )
            return func_getUserData(  );
        else{
            return this->osg::Object::getUserData(  );
        }
    }
    
    ::osg::Referenced * default_getUserData(  ) {
        return osg::Object::getUserData( );
    }

    virtual ::osg::Referenced const * getUserData(  ) const  {
        if( bp::override func_getUserData = this->get_override( "getUserData" ) )
            return func_getUserData(  );
        else{
            return this->osg::Object::getUserData(  );
        }
    }
    
    ::osg::Referenced const * default_getUserData(  ) const  {
        return osg::Object::getUserData( );
    }

    virtual void setName( ::std::string const & name ) {
        if( bp::override func_setName = this->get_override( "setName" ) )
            func_setName( name );
        else{
            this->osg::Object::setName( name );
        }
    }
    
    void default_setName( ::std::string const & name ) {
        osg::Object::setName( name );
    }

    virtual void setThreadSafeRefUnref( bool threadSafe ) {
        if( bp::override func_setThreadSafeRefUnref = this->get_override( "setThreadSafeRefUnref" ) )
            func_setThreadSafeRefUnref( threadSafe );
        else{
            this->osg::Object::setThreadSafeRefUnref( threadSafe );
        }
    }
    
    void default_setThreadSafeRefUnref( bool threadSafe ) {
        osg::Object::setThreadSafeRefUnref( threadSafe );
    }

    virtual void setUserData( ::osg::Referenced * obj ) {
        if( bp::override func_setUserData = this->get_override( "setUserData" ) )
            func_setUserData( boost::python::ptr(obj) );
        else{
            this->osg::Object::setUserData( boost::python::ptr(obj) );
        }
    }
    
    void default_setUserData( ::osg::Referenced * obj ) {
        osg::Object::setUserData( boost::python::ptr(obj) );
    }

};

void register_Texture_class(){

    { //::osg::Texture
        typedef bp::class_< Texture_wrapper, bp::bases< osg::StateAttribute >, osg::ref_ptr< ::osg::Texture >, boost::noncopyable > Texture_exposer_t;
        Texture_exposer_t Texture_exposer = Texture_exposer_t( "Texture", "\n Texture pure virtual base class that encapsulates OpenGL texture\n functionality common to the various types of OSG textures.\n", bp::no_init );
        bp::scope Texture_scope( Texture_exposer );
        bp::enum_< osg::Texture::FilterMode>("FilterMode")
            .value("LINEAR", osg::Texture::LINEAR)
            .value("LINEAR_MIPMAP_LINEAR", osg::Texture::LINEAR_MIPMAP_LINEAR)
            .value("LINEAR_MIPMAP_NEAREST", osg::Texture::LINEAR_MIPMAP_NEAREST)
            .value("NEAREST", osg::Texture::NEAREST)
            .value("NEAREST_MIPMAP_LINEAR", osg::Texture::NEAREST_MIPMAP_LINEAR)
            .value("NEAREST_MIPMAP_NEAREST", osg::Texture::NEAREST_MIPMAP_NEAREST)
            .export_values()
            ;
        bp::enum_< osg::Texture::FilterParameter>("FilterParameter")
            .value("MIN_FILTER", osg::Texture::MIN_FILTER)
            .value("MAG_FILTER", osg::Texture::MAG_FILTER)
            .export_values()
            ;
        bp::enum_< osg::Texture::GenerateMipmapMode>("GenerateMipmapMode")
            .value("GENERATE_MIPMAP_NONE", osg::Texture::GENERATE_MIPMAP_NONE)
            .value("GENERATE_MIPMAP", osg::Texture::GENERATE_MIPMAP)
            .value("GENERATE_MIPMAP_TEX_PARAMETER", osg::Texture::GENERATE_MIPMAP_TEX_PARAMETER)
            .export_values()
            ;
        bp::enum_< osg::Texture::ImageAccess>("ImageAccess")
            .value("NOT_USED", osg::Texture::NOT_USED)
            .value("READ_ONLY", osg::Texture::READ_ONLY)
            .value("WRITE_ONLY", osg::Texture::WRITE_ONLY)
            .value("READ_WRITE", osg::Texture::READ_WRITE)
            .export_values()
            ;
        bp::enum_< osg::Texture::InternalFormatMode>("InternalFormatMode")
            .value("USE_IMAGE_DATA_FORMAT", osg::Texture::USE_IMAGE_DATA_FORMAT)
            .value("USE_USER_DEFINED_FORMAT", osg::Texture::USE_USER_DEFINED_FORMAT)
            .value("USE_ARB_COMPRESSION", osg::Texture::USE_ARB_COMPRESSION)
            .value("USE_S3TC_DXT1_COMPRESSION", osg::Texture::USE_S3TC_DXT1_COMPRESSION)
            .value("USE_S3TC_DXT3_COMPRESSION", osg::Texture::USE_S3TC_DXT3_COMPRESSION)
            .value("USE_S3TC_DXT5_COMPRESSION", osg::Texture::USE_S3TC_DXT5_COMPRESSION)
            .value("USE_PVRTC_2BPP_COMPRESSION", osg::Texture::USE_PVRTC_2BPP_COMPRESSION)
            .value("USE_PVRTC_4BPP_COMPRESSION", osg::Texture::USE_PVRTC_4BPP_COMPRESSION)
            .value("USE_ETC_COMPRESSION", osg::Texture::USE_ETC_COMPRESSION)
            .value("USE_RGTC1_COMPRESSION", osg::Texture::USE_RGTC1_COMPRESSION)
            .value("USE_RGTC2_COMPRESSION", osg::Texture::USE_RGTC2_COMPRESSION)
            .value("USE_S3TC_DXT1c_COMPRESSION", osg::Texture::USE_S3TC_DXT1c_COMPRESSION)
            .value("USE_S3TC_DXT1a_COMPRESSION", osg::Texture::USE_S3TC_DXT1a_COMPRESSION)
            .export_values()
            ;
        bp::enum_< osg::Texture::InternalFormatType>("InternalFormatType")
            .value("NORMALIZED", osg::Texture::NORMALIZED)
            .value("FLOAT", osg::Texture::FLOAT)
            .value("SIGNED_INTEGER", osg::Texture::SIGNED_INTEGER)
            .value("UNSIGNED_INTEGER", osg::Texture::UNSIGNED_INTEGER)
            .export_values()
            ;
        bp::enum_< osg::Texture::ShadowCompareFunc>("ShadowCompareFunc")
            .value("NEVER", osg::Texture::NEVER)
            .value("LESS", osg::Texture::LESS)
            .value("EQUAL", osg::Texture::EQUAL)
            .value("LEQUAL", osg::Texture::LEQUAL)
            .value("GREATER", osg::Texture::GREATER)
            .value("NOTEQUAL", osg::Texture::NOTEQUAL)
            .value("GEQUAL", osg::Texture::GEQUAL)
            .value("ALWAYS", osg::Texture::ALWAYS)
            .export_values()
            ;
        bp::enum_< osg::Texture::ShadowTextureMode>("ShadowTextureMode")
            .value("LUMINANCE", osg::Texture::LUMINANCE)
            .value("INTENSITY", osg::Texture::INTENSITY)
            .value("ALPHA", osg::Texture::ALPHA)
            .export_values()
            ;
        bp::enum_< osg::Texture::WrapMode>("WrapMode")
            .value("CLAMP", osg::Texture::CLAMP)
            .value("CLAMP_TO_EDGE", osg::Texture::CLAMP_TO_EDGE)
            .value("CLAMP_TO_BORDER", osg::Texture::CLAMP_TO_BORDER)
            .value("REPEAT", osg::Texture::REPEAT)
            .value("MIRROR", osg::Texture::MIRROR)
            .export_values()
            ;
        bp::enum_< osg::Texture::WrapParameter>("WrapParameter")
            .value("WRAP_S", osg::Texture::WRAP_S)
            .value("WRAP_T", osg::Texture::WRAP_T)
            .value("WRAP_R", osg::Texture::WRAP_R)
            .export_values()
            ;
        bp::class_< osg::Texture::Extensions, bp::bases< osg::Referenced >, osg::ref_ptr< ::osg::Texture::Extensions >, boost::noncopyable >( "Extensions", " Encapsulates queries of extension availability, obtains extension\n function pointers, and provides convenience wrappers for\n calling extension functions.", bp::no_init )    
            .def( 
                "getPreferGenerateMipmapSGISForPowerOfTwo"
                , (bool ( ::osg::Texture::Extensions::* )(  ) const)( &::osg::Texture::Extensions::getPreferGenerateMipmapSGISForPowerOfTwo ) )    
            .def( 
                "glBindImageTexture"
                , (void ( ::osg::Texture::Extensions::* )( ::GLuint,::GLuint,::GLint,::GLboolean,::GLint,::GLenum,::GLenum ) const)( &::osg::Texture::Extensions::glBindImageTexture )
                , ( bp::arg("unit"), bp::arg("texture"), bp::arg("level"), bp::arg("layered"), bp::arg("layer"), bp::arg("access"), bp::arg("format") ) )    
            .def( 
                "glCompressedTexImage2D"
                , (void ( ::osg::Texture::Extensions::* )( ::GLenum,::GLint,::GLenum,::GLsizei,::GLsizei,::GLint,::GLsizei,::GLvoid const * ) const)( &::osg::Texture::Extensions::glCompressedTexImage2D )
                , ( bp::arg("target"), bp::arg("level"), bp::arg("internalformat"), bp::arg("width"), bp::arg("height"), bp::arg("border"), bp::arg("imageSize"), bp::arg("data") ) )    
            .def( 
                "glCompressedTexSubImage2D"
                , (void ( ::osg::Texture::Extensions::* )( ::GLenum,::GLint,::GLint,::GLint,::GLsizei,::GLsizei,::GLenum,::GLsizei,::GLvoid const * ) const)( &::osg::Texture::Extensions::glCompressedTexSubImage2D )
                , ( bp::arg("target"), bp::arg("level"), bp::arg("xoffset"), bp::arg("yoffset"), bp::arg("width"), bp::arg("height"), bp::arg("format"), bp::arg("imageSize"), bp::arg("data") ) )    
            .def( 
                "glGetCompressedTexImage"
                , (void ( ::osg::Texture::Extensions::* )( ::GLenum,::GLint,::GLvoid * ) const)( &::osg::Texture::Extensions::glGetCompressedTexImage )
                , ( bp::arg("target"), bp::arg("level"), bp::arg("data") ) )    
            .def( 
                "glTexImage2DMultisample"
                , (void ( ::osg::Texture::Extensions::* )( ::GLenum,::GLsizei,::GLint,::GLsizei,::GLsizei,::GLboolean ) const)( &::osg::Texture::Extensions::glTexImage2DMultisample )
                , ( bp::arg("target"), bp::arg("samples"), bp::arg("internalformat"), bp::arg("width"), bp::arg("height"), bp::arg("fixedsamplelocations") ) )    
            .def( 
                "glTexParameterIiv"
                , (void ( ::osg::Texture::Extensions::* )( ::GLenum,::GLenum,::GLint const * ) const)( &::osg::Texture::Extensions::glTexParameterIiv )
                , ( bp::arg("target"), bp::arg("pname"), bp::arg("data") ) )    
            .def( 
                "glTexParameterIuiv"
                , (void ( ::osg::Texture::Extensions::* )( ::GLenum,::GLenum,::GLuint const * ) const)( &::osg::Texture::Extensions::glTexParameterIuiv )
                , ( bp::arg("target"), bp::arg("pname"), bp::arg("data") ) )    
            .def( 
                "isBindImageTextureSupported"
                , (bool ( ::osg::Texture::Extensions::* )(  ) const)( &::osg::Texture::Extensions::isBindImageTextureSupported ) )    
            .def( 
                "isClientStorageSupported"
                , (bool ( ::osg::Texture::Extensions::* )(  ) const)( &::osg::Texture::Extensions::isClientStorageSupported ) )    
            .def( 
                "isCompressedTexImage2DSupported"
                , (bool ( ::osg::Texture::Extensions::* )(  ) const)( &::osg::Texture::Extensions::isCompressedTexImage2DSupported ) )    
            .def( 
                "isCompressedTexSubImage2DSupported"
                , (bool ( ::osg::Texture::Extensions::* )(  ) const)( &::osg::Texture::Extensions::isCompressedTexSubImage2DSupported ) )    
            .def( 
                "isGenerateMipMapSupported"
                , (bool ( ::osg::Texture::Extensions::* )(  ) const)( &::osg::Texture::Extensions::isGenerateMipMapSupported ) )    
            .def( 
                "isMultiTexturingSupported"
                , (bool ( ::osg::Texture::Extensions::* )(  ) const)( &::osg::Texture::Extensions::isMultiTexturingSupported ) )    
            .def( 
                "isNonPowerOfTwoTextureSupported"
                , (bool ( ::osg::Texture::Extensions::* )( ::GLenum ) const)( &::osg::Texture::Extensions::isNonPowerOfTwoTextureSupported )
                , ( bp::arg("filter") ) )    
            .def( 
                "isShadowAmbientSupported"
                , (bool ( ::osg::Texture::Extensions::* )(  ) const)( &::osg::Texture::Extensions::isShadowAmbientSupported ) )    
            .def( 
                "isShadowSupported"
                , (bool ( ::osg::Texture::Extensions::* )(  ) const)( &::osg::Texture::Extensions::isShadowSupported ) )    
            .def( 
                "isTextureBorderClampSupported"
                , (bool ( ::osg::Texture::Extensions::* )(  ) const)( &::osg::Texture::Extensions::isTextureBorderClampSupported ) )    
            .def( 
                "isTextureCompressionARBSupported"
                , (bool ( ::osg::Texture::Extensions::* )(  ) const)( &::osg::Texture::Extensions::isTextureCompressionARBSupported ) )    
            .def( 
                "isTextureCompressionETCSupported"
                , (bool ( ::osg::Texture::Extensions::* )(  ) const)( &::osg::Texture::Extensions::isTextureCompressionETCSupported ) )    
            .def( 
                "isTextureCompressionPVRTC2BPPSupported"
                , (bool ( ::osg::Texture::Extensions::* )(  ) const)( &::osg::Texture::Extensions::isTextureCompressionPVRTC2BPPSupported ) )    
            .def( 
                "isTextureCompressionPVRTC4BPPSupported"
                , (bool ( ::osg::Texture::Extensions::* )(  ) const)( &::osg::Texture::Extensions::isTextureCompressionPVRTC4BPPSupported ) )    
            .def( 
                "isTextureCompressionPVRTCSupported"
                , (bool ( ::osg::Texture::Extensions::* )(  ) const)( &::osg::Texture::Extensions::isTextureCompressionPVRTCSupported ) )    
            .def( 
                "isTextureCompressionRGTCSupported"
                , (bool ( ::osg::Texture::Extensions::* )(  ) const)( &::osg::Texture::Extensions::isTextureCompressionRGTCSupported ) )    
            .def( 
                "isTextureCompressionS3TCSupported"
                , (bool ( ::osg::Texture::Extensions::* )(  ) const)( &::osg::Texture::Extensions::isTextureCompressionS3TCSupported ) )    
            .def( 
                "isTextureEdgeClampSupported"
                , (bool ( ::osg::Texture::Extensions::* )(  ) const)( &::osg::Texture::Extensions::isTextureEdgeClampSupported ) )    
            .def( 
                "isTextureFilterAnisotropicSupported"
                , (bool ( ::osg::Texture::Extensions::* )(  ) const)( &::osg::Texture::Extensions::isTextureFilterAnisotropicSupported ) )    
            .def( 
                "isTextureIntegerSupported"
                , (bool ( ::osg::Texture::Extensions::* )(  ) const)( &::osg::Texture::Extensions::isTextureIntegerSupported ) )    
            .def( 
                "isTextureMaxLevelSupported"
                , (bool ( ::osg::Texture::Extensions::* )(  ) const)( &::osg::Texture::Extensions::isTextureMaxLevelSupported ) )    
            .def( 
                "isTextureMirroredRepeatSupported"
                , (bool ( ::osg::Texture::Extensions::* )(  ) const)( &::osg::Texture::Extensions::isTextureMirroredRepeatSupported ) )    
            .def( 
                "isTextureMultisampledSupported"
                , (bool ( ::osg::Texture::Extensions::* )(  ) const)( &::osg::Texture::Extensions::isTextureMultisampledSupported ) )    
            .def( 
                "isTextureSwizzleSupported"
                , (bool ( ::osg::Texture::Extensions::* )(  ) const)( &::osg::Texture::Extensions::isTextureSwizzleSupported ) )    
            .def( 
                "maxTextureSize"
                , (::GLint ( ::osg::Texture::Extensions::* )(  ) const)( &::osg::Texture::Extensions::maxTextureSize ) )    
            .def( 
                "numTextureUnits"
                , (::GLint ( ::osg::Texture::Extensions::* )(  ) const)( &::osg::Texture::Extensions::numTextureUnits ) )    
            .def( 
                "setGenerateMipMapSupported"
                , (void ( ::osg::Texture::Extensions::* )( bool ) )( &::osg::Texture::Extensions::setGenerateMipMapSupported )
                , ( bp::arg("flag") ) )    
            .def( 
                "setMaxTextureSize"
                , (void ( ::osg::Texture::Extensions::* )( ::GLint ) )( &::osg::Texture::Extensions::setMaxTextureSize )
                , ( bp::arg("maxsize") ) )    
            .def( 
                "setMultiTexturingSupported"
                , (void ( ::osg::Texture::Extensions::* )( bool ) )( &::osg::Texture::Extensions::setMultiTexturingSupported )
                , ( bp::arg("flag") ) )    
            .def( 
                "setNumTextureUnits"
                , (void ( ::osg::Texture::Extensions::* )( ::GLint ) )( &::osg::Texture::Extensions::setNumTextureUnits )
                , ( bp::arg("nunits") ) )    
            .def( 
                "setPreferGenerateMipmapSGISForPowerOfTwo"
                , (void ( ::osg::Texture::Extensions::* )( bool ) )( &::osg::Texture::Extensions::setPreferGenerateMipmapSGISForPowerOfTwo )
                , ( bp::arg("flag") ) )    
            .def( 
                "setShadowAmbientSupported"
                , (void ( ::osg::Texture::Extensions::* )( bool ) )( &::osg::Texture::Extensions::setShadowAmbientSupported )
                , ( bp::arg("flag") ) )    
            .def( 
                "setShadowSupported"
                , (void ( ::osg::Texture::Extensions::* )( bool ) )( &::osg::Texture::Extensions::setShadowSupported )
                , ( bp::arg("flag") ) )    
            .def( 
                "setTextureBorderClampSupported"
                , (void ( ::osg::Texture::Extensions::* )( bool ) )( &::osg::Texture::Extensions::setTextureBorderClampSupported )
                , ( bp::arg("flag") ) )    
            .def( 
                "setTextureCompressionARBSupported"
                , (void ( ::osg::Texture::Extensions::* )( bool ) )( &::osg::Texture::Extensions::setTextureCompressionARBSupported )
                , ( bp::arg("flag") ) )    
            .def( 
                "setTextureCompressionETCSupported"
                , (void ( ::osg::Texture::Extensions::* )( bool ) )( &::osg::Texture::Extensions::setTextureCompressionETCSupported )
                , ( bp::arg("flag") ) )    
            .def( 
                "setTextureCompressionPVRTC2BPPSupported"
                , (void ( ::osg::Texture::Extensions::* )( bool ) )( &::osg::Texture::Extensions::setTextureCompressionPVRTC2BPPSupported )
                , ( bp::arg("flag") ) )    
            .def( 
                "setTextureCompressionPVRTC4BPPSupported"
                , (void ( ::osg::Texture::Extensions::* )( bool ) )( &::osg::Texture::Extensions::setTextureCompressionPVRTC4BPPSupported )
                , ( bp::arg("flag") ) )    
            .def( 
                "setTextureCompressionPVRTCSupported"
                , (void ( ::osg::Texture::Extensions::* )( bool ) )( &::osg::Texture::Extensions::setTextureCompressionPVRTCSupported )
                , ( bp::arg("flag") ) )    
            .def( 
                "setTextureCompressionRGTCSupported"
                , (void ( ::osg::Texture::Extensions::* )( bool ) )( &::osg::Texture::Extensions::setTextureCompressionRGTCSupported )
                , ( bp::arg("flag") ) )    
            .def( 
                "setTextureCompressionS3TCSupported"
                , (void ( ::osg::Texture::Extensions::* )( bool ) )( &::osg::Texture::Extensions::setTextureCompressionS3TCSupported )
                , ( bp::arg("flag") ) )    
            .def( 
                "setTextureEdgeClampSupported"
                , (void ( ::osg::Texture::Extensions::* )( bool ) )( &::osg::Texture::Extensions::setTextureEdgeClampSupported )
                , ( bp::arg("flag") ) )    
            .def( 
                "setTextureFilterAnisotropicSupported"
                , (void ( ::osg::Texture::Extensions::* )( bool ) )( &::osg::Texture::Extensions::setTextureFilterAnisotropicSupported )
                , ( bp::arg("flag") ) )    
            .def( 
                "setTextureIntegerSupported"
                , (void ( ::osg::Texture::Extensions::* )( bool ) )( &::osg::Texture::Extensions::setTextureIntegerSupported )
                , ( bp::arg("flag") ) )    
            .def( 
                "setTextureMaxLevelSupported"
                , (void ( ::osg::Texture::Extensions::* )( bool ) )( &::osg::Texture::Extensions::setTextureMaxLevelSupported )
                , ( bp::arg("flag") ) )    
            .def( 
                "setTextureMirroredRepeatSupported"
                , (void ( ::osg::Texture::Extensions::* )( bool ) )( &::osg::Texture::Extensions::setTextureMirroredRepeatSupported )
                , ( bp::arg("flag") ) )    
            .def( 
                "setTextureMultisampledSupported"
                , (void ( ::osg::Texture::Extensions::* )( bool ) )( &::osg::Texture::Extensions::setTextureMultisampledSupported )
                , ( bp::arg("flag") ) )    
            .def( 
                "setTextureSwizzleSupported"
                , (void ( ::osg::Texture::Extensions::* )( bool ) )( &::osg::Texture::Extensions::setTextureSwizzleSupported )
                , ( bp::arg("flag") ) );
        bp::class_< osg::Texture::ImageAttachment >( "ImageAttachment", " Encapsulates texture image load/store attributes" )    
            .def_readwrite( "access", &osg::Texture::ImageAttachment::access )    
            .def_readwrite( "format", &osg::Texture::ImageAttachment::format )    
            .def_readwrite( "layer", &osg::Texture::ImageAttachment::layer )    
            .def_readwrite( "layered", &osg::Texture::ImageAttachment::layered )    
            .def_readwrite( "level", &osg::Texture::ImageAttachment::level )    
            .def_readwrite( "unit", &osg::Texture::ImageAttachment::unit, " Encapsulates texture image load/store attributes" );
        bp::class_< osg::Texture::TextureObjectManager, bp::bases< osg::Referenced >, osg::ref_ptr< ::osg::Texture::TextureObjectManager >, boost::noncopyable >( "TextureObjectManager", bp::no_init )    
            .def( 
                "checkConsistency"
                , (bool ( ::osg::Texture::TextureObjectManager::* )(  ) const)( &::osg::Texture::TextureObjectManager::checkConsistency ) )    
            .def( 
                "deleteAllTextureObjects"
                , (void ( ::osg::Texture::TextureObjectManager::* )(  ) )( &::osg::Texture::TextureObjectManager::deleteAllTextureObjects ) )    
            .def( 
                "discardAllDeletedTextureObjects"
                , (void ( ::osg::Texture::TextureObjectManager::* )(  ) )( &::osg::Texture::TextureObjectManager::discardAllDeletedTextureObjects ) )    
            .def( 
                "discardAllTextureObjects"
                , (void ( ::osg::Texture::TextureObjectManager::* )(  ) )( &::osg::Texture::TextureObjectManager::discardAllTextureObjects ) )    
            .def( 
                "flushAllDeletedTextureObjects"
                , (void ( ::osg::Texture::TextureObjectManager::* )(  ) )( &::osg::Texture::TextureObjectManager::flushAllDeletedTextureObjects ) )    
            .def( 
                "flushDeletedTextureObjects"
                , (void ( ::osg::Texture::TextureObjectManager::* )( double,double & ) )( &::osg::Texture::TextureObjectManager::flushDeletedTextureObjects )
                , ( bp::arg("currentTime"), bp::arg("availableTime") ) )    
            .def( 
                "generateTextureObject"
                , (::osg::Texture::TextureObject * ( ::osg::Texture::TextureObjectManager::* )( ::osg::Texture const *,::GLenum ) )( &::osg::Texture::TextureObjectManager::generateTextureObject )
                , ( bp::arg("texture"), bp::arg("target") )
                , bp::return_internal_reference< >() )    
            .def( 
                "generateTextureObject"
                , (::osg::Texture::TextureObject * ( ::osg::Texture::TextureObjectManager::* )( ::osg::Texture const *,::GLenum,::GLint,::GLenum,::GLsizei,::GLsizei,::GLsizei,::GLint ) )( &::osg::Texture::TextureObjectManager::generateTextureObject )
                , ( bp::arg("texture"), bp::arg("target"), bp::arg("numMipmapLevels"), bp::arg("internalFormat"), bp::arg("width"), bp::arg("height"), bp::arg("depth"), bp::arg("border") )
                , bp::return_internal_reference< >() )    
            .def( 
                "getApplyTime"
                , (double & ( ::osg::Texture::TextureObjectManager::* )(  ) )( &::osg::Texture::TextureObjectManager::getApplyTime )
                , bp::return_value_policy< bp::copy_non_const_reference >() )    
            .def( 
                "getContextID"
                , (unsigned int ( ::osg::Texture::TextureObjectManager::* )(  ) const)( &::osg::Texture::TextureObjectManager::getContextID ) )    
            .def( 
                "getCurrTexturePoolSize"
                , (unsigned int & ( ::osg::Texture::TextureObjectManager::* )(  ) )( &::osg::Texture::TextureObjectManager::getCurrTexturePoolSize )
                , bp::return_value_policy< bp::copy_non_const_reference >() )    
            .def( 
                "getCurrTexturePoolSize"
                , (unsigned int ( ::osg::Texture::TextureObjectManager::* )(  ) const)( &::osg::Texture::TextureObjectManager::getCurrTexturePoolSize ) )    
            .def( 
                "getDeleteTime"
                , (double & ( ::osg::Texture::TextureObjectManager::* )(  ) )( &::osg::Texture::TextureObjectManager::getDeleteTime )
                , bp::return_value_policy< bp::copy_non_const_reference >() )    
            .def( 
                "getFrameNumber"
                , (unsigned int & ( ::osg::Texture::TextureObjectManager::* )(  ) )( &::osg::Texture::TextureObjectManager::getFrameNumber )
                , bp::return_value_policy< bp::copy_non_const_reference >() )    
            .def( 
                "getGenerateTime"
                , (double & ( ::osg::Texture::TextureObjectManager::* )(  ) )( &::osg::Texture::TextureObjectManager::getGenerateTime )
                , bp::return_value_policy< bp::copy_non_const_reference >() )    
            .def( 
                "getMaxTexturePoolSize"
                , (unsigned int ( ::osg::Texture::TextureObjectManager::* )(  ) const)( &::osg::Texture::TextureObjectManager::getMaxTexturePoolSize ) )    
            .def( 
                "getNumberActiveTextureObjects"
                , (unsigned int & ( ::osg::Texture::TextureObjectManager::* )(  ) )( &::osg::Texture::TextureObjectManager::getNumberActiveTextureObjects )
                , bp::return_value_policy< bp::copy_non_const_reference >() )    
            .def( 
                "getNumberActiveTextureObjects"
                , (unsigned int ( ::osg::Texture::TextureObjectManager::* )(  ) const)( &::osg::Texture::TextureObjectManager::getNumberActiveTextureObjects ) )    
            .def( 
                "getNumberApplied"
                , (unsigned int & ( ::osg::Texture::TextureObjectManager::* )(  ) )( &::osg::Texture::TextureObjectManager::getNumberApplied )
                , bp::return_value_policy< bp::copy_non_const_reference >() )    
            .def( 
                "getNumberDeleted"
                , (unsigned int & ( ::osg::Texture::TextureObjectManager::* )(  ) )( &::osg::Texture::TextureObjectManager::getNumberDeleted )
                , bp::return_value_policy< bp::copy_non_const_reference >() )    
            .def( 
                "getNumberFrames"
                , (unsigned int & ( ::osg::Texture::TextureObjectManager::* )(  ) )( &::osg::Texture::TextureObjectManager::getNumberFrames )
                , bp::return_value_policy< bp::copy_non_const_reference >() )    
            .def( 
                "getNumberGenerated"
                , (unsigned int & ( ::osg::Texture::TextureObjectManager::* )(  ) )( &::osg::Texture::TextureObjectManager::getNumberGenerated )
                , bp::return_value_policy< bp::copy_non_const_reference >() )    
            .def( 
                "getNumberOrphanedTextureObjects"
                , (unsigned int & ( ::osg::Texture::TextureObjectManager::* )(  ) )( &::osg::Texture::TextureObjectManager::getNumberOrphanedTextureObjects )
                , bp::return_value_policy< bp::copy_non_const_reference >() )    
            .def( 
                "getNumberOrphanedTextureObjects"
                , (unsigned int ( ::osg::Texture::TextureObjectManager::* )(  ) const)( &::osg::Texture::TextureObjectManager::getNumberOrphanedTextureObjects ) )    
            .def( 
                "getTextureObjectSet"
                , (::osg::Texture::TextureObjectSet * ( ::osg::Texture::TextureObjectManager::* )( ::osg::Texture::TextureProfile const & ) )( &::osg::Texture::TextureObjectManager::getTextureObjectSet )
                , ( bp::arg("profile") )
                , bp::return_internal_reference< >() )    
            .def( 
                "handlePendingOrphandedTextureObjects"
                , (void ( ::osg::Texture::TextureObjectManager::* )(  ) )( &::osg::Texture::TextureObjectManager::handlePendingOrphandedTextureObjects ) )    
            .def( 
                "hasSpace"
                , (bool ( ::osg::Texture::TextureObjectManager::* )( unsigned int ) const)( &::osg::Texture::TextureObjectManager::hasSpace )
                , ( bp::arg("size") ) )    
            .def( 
                "makeSpace"
                , (bool ( ::osg::Texture::TextureObjectManager::* )( unsigned int ) )( &::osg::Texture::TextureObjectManager::makeSpace )
                , ( bp::arg("size") ) )    
            .def( 
                "newFrame"
                , (void ( ::osg::Texture::TextureObjectManager::* )( ::osg::FrameStamp * ) )( &::osg::Texture::TextureObjectManager::newFrame )
                , ( bp::arg("fs") ) )    
            .def( 
                "recomputeStats"
                , (void ( ::osg::Texture::TextureObjectManager::* )( ::std::ostream & ) const)( &::osg::Texture::TextureObjectManager::recomputeStats )
                , ( bp::arg("out") ) )    
            .def( 
                "releaseTextureObject"
                , (void ( ::osg::Texture::TextureObjectManager::* )( ::osg::Texture::TextureObject * ) )( &::osg::Texture::TextureObjectManager::releaseTextureObject )
                , ( bp::arg("to") ) )    
            .def( 
                "reportStats"
                , (void ( ::osg::Texture::TextureObjectManager::* )( ::std::ostream & ) )( &::osg::Texture::TextureObjectManager::reportStats )
                , ( bp::arg("out") ) )    
            .def( 
                "resetStats"
                , (void ( ::osg::Texture::TextureObjectManager::* )(  ) )( &::osg::Texture::TextureObjectManager::resetStats ) )    
            .def( 
                "setCurrTexturePoolSize"
                , (void ( ::osg::Texture::TextureObjectManager::* )( unsigned int ) )( &::osg::Texture::TextureObjectManager::setCurrTexturePoolSize )
                , ( bp::arg("size") ) )    
            .def( 
                "setMaxTexturePoolSize"
                , (void ( ::osg::Texture::TextureObjectManager::* )( unsigned int ) )( &::osg::Texture::TextureObjectManager::setMaxTexturePoolSize )
                , ( bp::arg("size") ) )    
            .def( 
                "setNumberActiveTextureObjects"
                , (void ( ::osg::Texture::TextureObjectManager::* )( unsigned int ) )( &::osg::Texture::TextureObjectManager::setNumberActiveTextureObjects )
                , ( bp::arg("size") ) )    
            .def( 
                "setNumberOrphanedTextureObjects"
                , (void ( ::osg::Texture::TextureObjectManager::* )( unsigned int ) )( &::osg::Texture::TextureObjectManager::setNumberOrphanedTextureObjects )
                , ( bp::arg("size") ) );
        bp::class_< osg::Texture::TextureObjectSet, bp::bases< osg::Referenced >, osg::ref_ptr< ::osg::Texture::TextureObjectSet >, boost::noncopyable >( "TextureObjectSet", bp::no_init )    
            .def( 
                "addToBack"
                , (void ( ::osg::Texture::TextureObjectSet::* )( ::osg::Texture::TextureObject * ) )( &::osg::Texture::TextureObjectSet::addToBack )
                , ( bp::arg("to") ) )    
            .def( 
                "checkConsistency"
                , (bool ( ::osg::Texture::TextureObjectSet::* )(  ) const)( &::osg::Texture::TextureObjectSet::checkConsistency ) )    
            .def( 
                "computeNumTextureObjectsInList"
                , (unsigned int ( ::osg::Texture::TextureObjectSet::* )(  ) const)( &::osg::Texture::TextureObjectSet::computeNumTextureObjectsInList ) )    
            .def( 
                "deleteAllTextureObjects"
                , (void ( ::osg::Texture::TextureObjectSet::* )(  ) )( &::osg::Texture::TextureObjectSet::deleteAllTextureObjects ) )    
            .def( 
                "discardAllDeletedTextureObjects"
                , (void ( ::osg::Texture::TextureObjectSet::* )(  ) )( &::osg::Texture::TextureObjectSet::discardAllDeletedTextureObjects ) )    
            .def( 
                "discardAllTextureObjects"
                , (void ( ::osg::Texture::TextureObjectSet::* )(  ) )( &::osg::Texture::TextureObjectSet::discardAllTextureObjects ) )    
            .def( 
                "flushAllDeletedTextureObjects"
                , (void ( ::osg::Texture::TextureObjectSet::* )(  ) )( &::osg::Texture::TextureObjectSet::flushAllDeletedTextureObjects ) )    
            .def( 
                "flushDeletedTextureObjects"
                , (void ( ::osg::Texture::TextureObjectSet::* )( double,double & ) )( &::osg::Texture::TextureObjectSet::flushDeletedTextureObjects )
                , ( bp::arg("currentTime"), bp::arg("availableTime") ) )    
            .def( 
                "getNumOfTextureObjects"
                , (unsigned int ( ::osg::Texture::TextureObjectSet::* )(  ) const)( &::osg::Texture::TextureObjectSet::getNumOfTextureObjects ) )    
            .def( 
                "getNumOrphans"
                , (unsigned int ( ::osg::Texture::TextureObjectSet::* )(  ) const)( &::osg::Texture::TextureObjectSet::getNumOrphans ) )    
            .def( 
                "getNumPendingOrphans"
                , (unsigned int ( ::osg::Texture::TextureObjectSet::* )(  ) const)( &::osg::Texture::TextureObjectSet::getNumPendingOrphans ) )    
            .def( 
                "getParent"
                , (::osg::Texture::TextureObjectManager * ( ::osg::Texture::TextureObjectSet::* )(  ) )( &::osg::Texture::TextureObjectSet::getParent )
                , bp::return_internal_reference< >() )    
            .def( 
                "getProfile"
                , (::osg::Texture::TextureProfile const & ( ::osg::Texture::TextureObjectSet::* )(  ) const)( &::osg::Texture::TextureObjectSet::getProfile )
                , bp::return_internal_reference< >() )    
            .def( 
                "handlePendingOrphandedTextureObjects"
                , (void ( ::osg::Texture::TextureObjectSet::* )(  ) )( &::osg::Texture::TextureObjectSet::handlePendingOrphandedTextureObjects ) )    
            .def( 
                "makeSpace"
                , (bool ( ::osg::Texture::TextureObjectSet::* )( unsigned int & ) )( &::osg::Texture::TextureObjectSet::makeSpace )
                , ( bp::arg("size") ) )    
            .def( 
                "moveToBack"
                , (void ( ::osg::Texture::TextureObjectSet::* )( ::osg::Texture::TextureObject * ) )( &::osg::Texture::TextureObjectSet::moveToBack )
                , ( bp::arg("to") ) )    
            .def( 
                "moveToSet"
                , (void ( ::osg::Texture::TextureObjectSet::* )( ::osg::Texture::TextureObject *,::osg::Texture::TextureObjectSet * ) )( &::osg::Texture::TextureObjectSet::moveToSet )
                , ( bp::arg("to"), bp::arg("set") ) )    
            .def( 
                "orphan"
                , (void ( ::osg::Texture::TextureObjectSet::* )( ::osg::Texture::TextureObject * ) )( &::osg::Texture::TextureObjectSet::orphan )
                , ( bp::arg("to") ) )    
            .def( 
                "remove"
                , (void ( ::osg::Texture::TextureObjectSet::* )( ::osg::Texture::TextureObject * ) )( &::osg::Texture::TextureObjectSet::remove )
                , ( bp::arg("to") ) )    
            .def( 
                "size"
                , (unsigned int ( ::osg::Texture::TextureObjectSet::* )(  ) const)( &::osg::Texture::TextureObjectSet::size ) )    
            .def( 
                "takeFromOrphans"
                , (::osg::Texture::TextureObject * ( ::osg::Texture::TextureObjectSet::* )( ::osg::Texture * ) )( &::osg::Texture::TextureObjectSet::takeFromOrphans )
                , ( bp::arg("texture") )
                , bp::return_internal_reference< >() )    
            .def( 
                "takeOrGenerate"
                , (::osg::Texture::TextureObject * ( ::osg::Texture::TextureObjectSet::* )( ::osg::Texture * ) )( &::osg::Texture::TextureObjectSet::takeOrGenerate )
                , ( bp::arg("texture") )
                , bp::return_internal_reference< >() );
        bp::class_< osg::Texture::TextureProfile >( "TextureProfile", bp::no_init )    
            .def( 
                "computeSize"
                , (void ( ::osg::Texture::TextureProfile::* )(  ) )( &::osg::Texture::TextureProfile::computeSize ) )    
            .def( 
                "match"
                , (bool ( ::osg::Texture::TextureProfile::* )( ::GLenum,::GLint,::GLenum,::GLsizei,::GLsizei,::GLsizei,::GLint ) )( &::osg::Texture::TextureProfile::match )
                , ( bp::arg("target"), bp::arg("numMipmapLevels"), bp::arg("internalFormat"), bp::arg("width"), bp::arg("height"), bp::arg("depth"), bp::arg("border") ) )    
            .def( 
                "set"
                , (void ( ::osg::Texture::TextureProfile::* )( ::GLint,::GLenum,::GLsizei,::GLsizei,::GLsizei,::GLint ) )( &::osg::Texture::TextureProfile::set )
                , ( bp::arg("numMipmapLevels"), bp::arg("internalFormat"), bp::arg("width"), bp::arg("height"), bp::arg("depth"), bp::arg("border") ) )    
            .def_readwrite( "_border", &osg::Texture::TextureProfile::_border )    
            .def_readwrite( "_depth", &osg::Texture::TextureProfile::_depth )    
            .def_readwrite( "_height", &osg::Texture::TextureProfile::_height )    
            .def_readwrite( "_internalFormat", &osg::Texture::TextureProfile::_internalFormat )    
            .def_readwrite( "_numMipmapLevels", &osg::Texture::TextureProfile::_numMipmapLevels )    
            .def_readwrite( "_size", &osg::Texture::TextureProfile::_size )    
            .def_readwrite( "_target", &osg::Texture::TextureProfile::_target )    
            .def_readwrite( "_width", &osg::Texture::TextureProfile::_width );
        { //::osg::Texture::allocateMipmapLevels
        
            typedef void ( ::osg::Texture::*allocateMipmapLevels_function_type )(  ) ;
            
            Texture_exposer.def( 
                "allocateMipmapLevels"
                , allocateMipmapLevels_function_type( &::osg::Texture::allocateMipmapLevels )
                , " Force a manual allocation of the mipmap levels on the next apply() call.\n User is responsible for filling the mipmap levels with valid data.\n The OpenGLs glGenerateMipmapEXT function is used to generate the mipmap levels.\n If glGenerateMipmapEXT is not supported or textures internal format is not supported\n by the glGenerateMipmapEXT, then empty mipmap levels will\n be allocated manually. The mipmap levels are also allocated if a non-mipmapped\n min filter is used." );
        
        }
        { //::osg::Texture::apply
        
            typedef void ( ::osg::Texture::*apply_function_type )( ::osg::State & ) const;
            
            Texture_exposer.def( 
                "apply"
                , bp::pure_virtual( apply_function_type(&::osg::Texture::apply) )
                , ( bp::arg("state") )
                , "\n Texture is a pure virtual base class, apply must be overridden.\n" );
        
        }
        { //::osg::Texture::applyTexImage2D_load
        
            typedef void ( ::osg::Texture::*applyTexImage2D_load_function_type )( ::osg::State &,::GLenum,::osg::Image const *,::GLsizei,::GLsizei,::GLsizei ) const;
            
            Texture_exposer.def( 
                "applyTexImage2D_load"
                , applyTexImage2D_load_function_type( &::osg::Texture::applyTexImage2D_load )
                , ( bp::arg("state"), bp::arg("target"), bp::arg("image"), bp::arg("width"), bp::arg("height"), bp::arg("numMipmapLevels") )
                , " Helper method. Creates the texture, but doesnt set or use a\n texture binding. Note: Dont call this method directly unless\n youre implementing a subload callback." );
        
        }
        { //::osg::Texture::applyTexImage2D_subload
        
            typedef void ( ::osg::Texture::*applyTexImage2D_subload_function_type )( ::osg::State &,::GLenum,::osg::Image const *,::GLsizei,::GLsizei,::GLint,::GLsizei ) const;
            
            Texture_exposer.def( 
                "applyTexImage2D_subload"
                , applyTexImage2D_subload_function_type( &::osg::Texture::applyTexImage2D_subload )
                , ( bp::arg("state"), bp::arg("target"), bp::arg("image"), bp::arg("width"), bp::arg("height"), bp::arg("inInternalFormat"), bp::arg("numMipmapLevels") )
                , " Helper method. Subloads images into the texture, but doesnt set\n or use a texture binding. Note: Dont call this method directly\n unless youre implementing a subload callback." );
        
        }
        { //::osg::Texture::areAllTextureObjectsLoaded
        
            typedef bool ( ::osg::Texture::*areAllTextureObjectsLoaded_function_type )(  ) const;
            
            Texture_exposer.def( 
                "areAllTextureObjectsLoaded"
                , areAllTextureObjectsLoaded_function_type( &::osg::Texture::areAllTextureObjectsLoaded )
                , " Returns true if the texture objects for all the required graphics\n contexts are loaded." );
        
        }
        { //::osg::Texture::asTexture
        
            typedef ::osg::Texture * ( ::osg::Texture::*asTexture_function_type )(  ) ;
            typedef ::osg::Texture * ( Texture_wrapper::*default_asTexture_function_type )(  ) ;
            
            Texture_exposer.def( 
                "asTexture"
                , asTexture_function_type(&::osg::Texture::asTexture)
                , default_asTexture_function_type(&Texture_wrapper::default_asTexture)
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::Texture::asTexture
        
            typedef ::osg::Texture const * ( ::osg::Texture::*asTexture_function_type )(  ) const;
            typedef ::osg::Texture const * ( Texture_wrapper::*default_asTexture_function_type )(  ) const;
            
            Texture_exposer.def( 
                "asTexture"
                , asTexture_function_type(&::osg::Texture::asTexture)
                , default_asTexture_function_type(&Texture_wrapper::default_asTexture)
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::Texture::bindToImageUnit
        
            typedef void ( ::osg::Texture::*bindToImageUnit_function_type )( unsigned int,::GLenum,::GLenum,int,bool,int ) ;
            
            Texture_exposer.def( 
                "bindToImageUnit"
                , bindToImageUnit_function_type( &::osg::Texture::bindToImageUnit )
                , ( bp::arg("unit"), bp::arg("access"), bp::arg("format")=(::GLenum)(0), bp::arg("level")=(int)(0), bp::arg("layered")=(bool)(false), bp::arg("layer")=(int)(0) )
                , " Bind texture to an image unit (available only if GL version is 4.2 or greater)\n The format parameter for the image unit need not exactly match the texture internal format,\n but if it is set to 0, the texture internal format will be used.\n See http://www.opengl.org/registry/specs/ARB/shader_image_load_store.txt" );
        
        }
        { //::osg::Texture::className
        
            typedef char const * ( ::osg::Texture::*className_function_type )(  ) const;
            typedef char const * ( Texture_wrapper::*default_className_function_type )(  ) const;
            
            Texture_exposer.def( 
                "className"
                , className_function_type(&::osg::Texture::className)
                , default_className_function_type(&Texture_wrapper::default_className) );
        
        }
        { //::osg::Texture::clone
        
            typedef ::osg::Object * ( ::osg::Texture::*clone_function_type )( ::osg::CopyOp const & ) const;
            
            Texture_exposer.def( 
                "clone"
                , bp::pure_virtual( clone_function_type(&::osg::Texture::clone) )
                , ( bp::arg("copyop") )
                , bp::return_value_policy< bp::reference_existing_object >() );
        
        }
        { //::osg::Texture::cloneType
        
            typedef ::osg::Object * ( ::osg::Texture::*cloneType_function_type )(  ) const;
            
            Texture_exposer.def( 
                "cloneType"
                , bp::pure_virtual( cloneType_function_type(&::osg::Texture::cloneType) )
                , bp::return_value_policy< bp::reference_existing_object >() );
        
        }
        { //::osg::Texture::compileGLObjects
        
            typedef void ( ::osg::Texture::*compileGLObjects_function_type )( ::osg::State & ) const;
            typedef void ( Texture_wrapper::*default_compileGLObjects_function_type )( ::osg::State & ) const;
            
            Texture_exposer.def( 
                "compileGLObjects"
                , compileGLObjects_function_type(&::osg::Texture::compileGLObjects)
                , default_compileGLObjects_function_type(&Texture_wrapper::default_compileGLObjects)
                , ( bp::arg("state") ) );
        
        }
        { //::osg::Texture::deleteAllTextureObjects
        
            typedef void ( *deleteAllTextureObjects_function_type )( unsigned int );
            
            Texture_exposer.def( 
                "deleteAllTextureObjects"
                , deleteAllTextureObjects_function_type( &::osg::Texture::deleteAllTextureObjects )
                , ( bp::arg("contextID") ) );
        
        }
        { //::osg::Texture::dirtyTextureObject
        
            typedef void ( ::osg::Texture::*dirtyTextureObject_function_type )(  ) ;
            
            Texture_exposer.def( 
                "dirtyTextureObject"
                , dirtyTextureObject_function_type( &::osg::Texture::dirtyTextureObject )
                , " Forces a recompile on next apply() of associated OpenGL texture\n objects." );
        
        }
        { //::osg::Texture::dirtyTextureParameters
        
            typedef void ( ::osg::Texture::*dirtyTextureParameters_function_type )(  ) ;
            
            Texture_exposer.def( 
                "dirtyTextureParameters"
                , dirtyTextureParameters_function_type( &::osg::Texture::dirtyTextureParameters )
                , " Force a reset on next apply() of associated OpenGL texture\n parameters." );
        
        }
        { //::osg::Texture::discardAllDeletedTextureObjects
        
            typedef void ( *discardAllDeletedTextureObjects_function_type )( unsigned int );
            
            Texture_exposer.def( 
                "discardAllDeletedTextureObjects"
                , discardAllDeletedTextureObjects_function_type( &::osg::Texture::discardAllDeletedTextureObjects )
                , ( bp::arg("contextID") ) );
        
        }
        { //::osg::Texture::discardAllTextureObjects
        
            typedef void ( *discardAllTextureObjects_function_type )( unsigned int );
            
            Texture_exposer.def( 
                "discardAllTextureObjects"
                , discardAllTextureObjects_function_type( &::osg::Texture::discardAllTextureObjects )
                , ( bp::arg("contextID") ) );
        
        }
        { //::osg::Texture::flushAllDeletedTextureObjects
        
            typedef void ( *flushAllDeletedTextureObjects_function_type )( unsigned int );
            
            Texture_exposer.def( 
                "flushAllDeletedTextureObjects"
                , flushAllDeletedTextureObjects_function_type( &::osg::Texture::flushAllDeletedTextureObjects )
                , ( bp::arg("contextID") ) );
        
        }
        { //::osg::Texture::flushDeletedTextureObjects
        
            typedef void ( *flushDeletedTextureObjects_function_type )( unsigned int,double,double & );
            
            Texture_exposer.def( 
                "flushDeletedTextureObjects"
                , flushDeletedTextureObjects_function_type( &::osg::Texture::flushDeletedTextureObjects )
                , ( bp::arg("contextID"), bp::arg("currentTime"), bp::arg("availableTime") ) );
        
        }
        { //::osg::Texture::generateTextureObject
        
            typedef ::osg::Texture::TextureObject * ( *generateTextureObject_function_type )( ::osg::Texture const *,unsigned int,::GLenum );
            
            Texture_exposer.def( 
                "generateTextureObject"
                , generateTextureObject_function_type( &::osg::Texture::generateTextureObject )
                , ( bp::arg("texture"), bp::arg("contextID"), bp::arg("target") )
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::Texture::generateTextureObject
        
            typedef ::osg::Texture::TextureObject * ( *generateTextureObject_function_type )( ::osg::Texture const *,unsigned int,::GLenum,::GLint,::GLenum,::GLsizei,::GLsizei,::GLsizei,::GLint );
            
            Texture_exposer.def( 
                "generateTextureObject"
                , generateTextureObject_function_type( &::osg::Texture::generateTextureObject )
                , ( bp::arg("texture"), bp::arg("contextID"), bp::arg("target"), bp::arg("numMipmapLevels"), bp::arg("internalFormat"), bp::arg("width"), bp::arg("height"), bp::arg("depth"), bp::arg("border") )
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::Texture::getBorderColor
        
            typedef ::osg::Vec4d const & ( ::osg::Texture::*getBorderColor_function_type )(  ) const;
            
            Texture_exposer.def( 
                "getBorderColor"
                , getBorderColor_function_type( &::osg::Texture::getBorderColor )
                , bp::return_internal_reference< >()
                , " Gets the border color." );
        
        }
        { //::osg::Texture::getBorderWidth
        
            typedef ::GLint ( ::osg::Texture::*getBorderWidth_function_type )(  ) const;
            
            Texture_exposer.def( 
                "getBorderWidth"
                , getBorderWidth_function_type( &::osg::Texture::getBorderWidth ) );
        
        }
        { //::osg::Texture::getClientStorageHint
        
            typedef bool ( ::osg::Texture::*getClientStorageHint_function_type )(  ) const;
            
            Texture_exposer.def( 
                "getClientStorageHint"
                , getClientStorageHint_function_type( &::osg::Texture::getClientStorageHint )
                , " Gets whether to use client storage for the texture." );
        
        }
        { //::osg::Texture::getCompressedSize
        
            typedef void ( *getCompressedSize_function_type )( ::GLenum,::GLint,::GLint,::GLint,::GLint &,::GLint & );
            
            Texture_exposer.def( 
                "getCompressedSize"
                , getCompressedSize_function_type( &::osg::Texture::getCompressedSize )
                , ( bp::arg("internalFormat"), bp::arg("width"), bp::arg("height"), bp::arg("depth"), bp::arg("blockSize"), bp::arg("size") )
                , " Determine the size of a compressed image, given the internalFormat,\n the width, the height, and the depth of the image. The block size\n and the size are output parameters." );
        
        }
        { //::osg::Texture::getExtensions
        
            typedef ::osg::Texture::Extensions * ( *getExtensions_function_type )( unsigned int,bool );
            
            Texture_exposer.def( 
                "getExtensions"
                , getExtensions_function_type( &::osg::Texture::getExtensions )
                , ( bp::arg("contextID"), bp::arg("createIfNotInitalized") )
                , bp::return_internal_reference< >()
                , " Gets the extension for the specified context. Creates the\n Extensions object for that context if it doesnt exist.\n Returns NULL if the Extensions object for the context doesnt\n exist and the createIfNotInitalized flag is false." );
        
        }
        { //::osg::Texture::getFilter
        
            typedef ::osg::Texture::FilterMode ( ::osg::Texture::*getFilter_function_type )( ::osg::Texture::FilterParameter ) const;
            
            Texture_exposer.def( 
                "getFilter"
                , getFilter_function_type( &::osg::Texture::getFilter )
                , ( bp::arg("which") )
                , " Gets the texture filter mode." );
        
        }
        { //::osg::Texture::getImage
        
            typedef ::osg::Image * ( ::osg::Texture::*getImage_function_type )( unsigned int ) ;
            
            Texture_exposer.def( 
                "getImage"
                , bp::pure_virtual( getImage_function_type(&::osg::Texture::getImage) )
                , ( bp::arg("face") )
                , bp::return_internal_reference< >()
                , "\n Gets the texture image for the specified face.\n" );
        
        }
        { //::osg::Texture::getImage
        
            typedef ::osg::Image const * ( ::osg::Texture::*getImage_function_type )( unsigned int ) const;
            
            Texture_exposer.def( 
                "getImage"
                , bp::pure_virtual( getImage_function_type(&::osg::Texture::getImage) )
                , ( bp::arg("face") )
                , bp::return_internal_reference< >()
                , "\n Gets the const texture image for specified face.\n" );
        
        }
        { //::osg::Texture::getImageAttachment
        
            typedef ::osg::Texture::ImageAttachment & ( ::osg::Texture::*getImageAttachment_function_type )(  ) ;
            
            Texture_exposer.def( 
                "getImageAttachment"
                , getImageAttachment_function_type( &::osg::Texture::getImageAttachment )
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::Texture::getImageAttachment
        
            typedef ::osg::Texture::ImageAttachment const & ( ::osg::Texture::*getImageAttachment_function_type )(  ) const;
            
            Texture_exposer.def( 
                "getImageAttachment"
                , getImageAttachment_function_type( &::osg::Texture::getImageAttachment )
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::Texture::getInternalFormat
        
            typedef ::GLint ( ::osg::Texture::*getInternalFormat_function_type )(  ) const;
            
            Texture_exposer.def( 
                "getInternalFormat"
                , getInternalFormat_function_type( &::osg::Texture::getInternalFormat )
                , " Gets the internal texture format." );
        
        }
        { //::osg::Texture::getInternalFormatMode
        
            typedef ::osg::Texture::InternalFormatMode ( ::osg::Texture::*getInternalFormatMode_function_type )(  ) const;
            
            Texture_exposer.def( 
                "getInternalFormatMode"
                , getInternalFormatMode_function_type( &::osg::Texture::getInternalFormatMode )
                , " Gets the internal texture format mode." );
        
        }
        { //::osg::Texture::getInternalFormatType
        
            typedef ::osg::Texture::InternalFormatType ( ::osg::Texture::*getInternalFormatType_function_type )(  ) const;
            
            Texture_exposer.def( 
                "getInternalFormatType"
                , getInternalFormatType_function_type( &::osg::Texture::getInternalFormatType )
                , " Get the internal texture format type." );
        
        }
        { //::osg::Texture::getMaxAnisotropy
        
            typedef float ( ::osg::Texture::*getMaxAnisotropy_function_type )(  ) const;
            
            Texture_exposer.def( 
                "getMaxAnisotropy"
                , getMaxAnisotropy_function_type( &::osg::Texture::getMaxAnisotropy )
                , " Gets the maximum anisotropy value." );
        
        }
        { //::osg::Texture::getModeUsage
        
            typedef bool ( ::osg::Texture::*getModeUsage_function_type )( ::osg::StateAttribute::ModeUsage & ) const;
            typedef bool ( Texture_wrapper::*default_getModeUsage_function_type )( ::osg::StateAttribute::ModeUsage & ) const;
            
            Texture_exposer.def( 
                "getModeUsage"
                , getModeUsage_function_type(&::osg::Texture::getModeUsage)
                , default_getModeUsage_function_type(&Texture_wrapper::default_getModeUsage)
                , ( bp::arg("usage") ) );
        
        }
        { //::osg::Texture::getNumImages
        
            typedef unsigned int ( ::osg::Texture::*getNumImages_function_type )(  ) const;
            
            Texture_exposer.def( 
                "getNumImages"
                , bp::pure_virtual( getNumImages_function_type(&::osg::Texture::getNumImages) )
                , "\n Gets the number of images that can be assigned to this Texture.\n" );
        
        }
        { //::osg::Texture::getReadPBuffer
        
            typedef ::osg::GraphicsContext * ( ::osg::Texture::*getReadPBuffer_function_type )(  ) ;
            
            Texture_exposer.def( 
                "getReadPBuffer"
                , getReadPBuffer_function_type( &::osg::Texture::getReadPBuffer )
                , bp::return_internal_reference< >()
                , " Get the PBuffer graphics context to read from when using PBuffers for RenderToTexture." );
        
        }
        { //::osg::Texture::getReadPBuffer
        
            typedef ::osg::GraphicsContext const * ( ::osg::Texture::*getReadPBuffer_function_type )(  ) const;
            
            Texture_exposer.def( 
                "getReadPBuffer"
                , getReadPBuffer_function_type( &::osg::Texture::getReadPBuffer )
                , bp::return_internal_reference< >()
                , " Get the const PBuffer graphics context to read from when using PBuffers for RenderToTexture." );
        
        }
        { //::osg::Texture::getResizeNonPowerOfTwoHint
        
            typedef bool ( ::osg::Texture::*getResizeNonPowerOfTwoHint_function_type )(  ) const;
            
            Texture_exposer.def( 
                "getResizeNonPowerOfTwoHint"
                , getResizeNonPowerOfTwoHint_function_type( &::osg::Texture::getResizeNonPowerOfTwoHint )
                , " Gets whether texture will force non power to two images to be resized." );
        
        }
        { //::osg::Texture::getShadowAmbient
        
            typedef float ( ::osg::Texture::*getShadowAmbient_function_type )(  ) const;
            
            Texture_exposer.def( 
                "getShadowAmbient"
                , getShadowAmbient_function_type( &::osg::Texture::getShadowAmbient ) );
        
        }
        { //::osg::Texture::getShadowCompareFunc
        
            typedef ::osg::Texture::ShadowCompareFunc ( ::osg::Texture::*getShadowCompareFunc_function_type )(  ) const;
            
            Texture_exposer.def( 
                "getShadowCompareFunc"
                , getShadowCompareFunc_function_type( &::osg::Texture::getShadowCompareFunc ) );
        
        }
        { //::osg::Texture::getShadowComparison
        
            typedef bool ( ::osg::Texture::*getShadowComparison_function_type )(  ) const;
            
            Texture_exposer.def( 
                "getShadowComparison"
                , getShadowComparison_function_type( &::osg::Texture::getShadowComparison ) );
        
        }
        { //::osg::Texture::getShadowTextureMode
        
            typedef ::osg::Texture::ShadowTextureMode ( ::osg::Texture::*getShadowTextureMode_function_type )(  ) const;
            
            Texture_exposer.def( 
                "getShadowTextureMode"
                , getShadowTextureMode_function_type( &::osg::Texture::getShadowTextureMode ) );
        
        }
        { //::osg::Texture::getSourceFormat
        
            typedef ::GLenum ( ::osg::Texture::*getSourceFormat_function_type )(  ) const;
            
            Texture_exposer.def( 
                "getSourceFormat"
                , getSourceFormat_function_type( &::osg::Texture::getSourceFormat )
                , " Gets the external source image format." );
        
        }
        { //::osg::Texture::getSourceType
        
            typedef ::GLenum ( ::osg::Texture::*getSourceType_function_type )(  ) const;
            
            Texture_exposer.def( 
                "getSourceType"
                , getSourceType_function_type( &::osg::Texture::getSourceType )
                , " Gets the external source data type." );
        
        }
        { //::osg::Texture::getSwizzle
        
            typedef ::osg::Vec4i const & ( ::osg::Texture::*getSwizzle_function_type )(  ) const;
            
            Texture_exposer.def( 
                "getSwizzle"
                , getSwizzle_function_type( &::osg::Texture::getSwizzle )
                , bp::return_internal_reference< >()
                , " Gets the source of texture swizzling for all channels" );
        
        }
        { //::osg::Texture::getTextureDepth
        
            typedef int ( ::osg::Texture::*getTextureDepth_function_type )(  ) const;
            typedef int ( Texture_wrapper::*default_getTextureDepth_function_type )(  ) const;
            
            Texture_exposer.def( 
                "getTextureDepth"
                , getTextureDepth_function_type(&::osg::Texture::getTextureDepth)
                , default_getTextureDepth_function_type(&Texture_wrapper::default_getTextureDepth) );
        
        }
        { //::osg::Texture::getTextureHeight
        
            typedef int ( ::osg::Texture::*getTextureHeight_function_type )(  ) const;
            typedef int ( Texture_wrapper::*default_getTextureHeight_function_type )(  ) const;
            
            Texture_exposer.def( 
                "getTextureHeight"
                , getTextureHeight_function_type(&::osg::Texture::getTextureHeight)
                , default_getTextureHeight_function_type(&Texture_wrapper::default_getTextureHeight) );
        
        }
        { //::osg::Texture::getTextureObject
        
            typedef ::osg::Texture::TextureObject * ( ::osg::Texture::*getTextureObject_function_type )( unsigned int ) const;
            
            Texture_exposer.def( 
                "getTextureObject"
                , getTextureObject_function_type( &::osg::Texture::getTextureObject )
                , ( bp::arg("contextID") )
                , bp::return_internal_reference< >()
                , " Returns a pointer to the TextureObject for the current context." );
        
        }
        { //::osg::Texture::getTextureObjectManager
        
            typedef ::osg::ref_ptr< osg::Texture::TextureObjectManager > & ( *getTextureObjectManager_function_type )( unsigned int );
            
            Texture_exposer.def( 
                "getTextureObjectManager"
                , getTextureObjectManager_function_type( &::osg::Texture::getTextureObjectManager )
                , ( bp::arg("contextID") )
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::Texture::getTextureParameterDirty
        
            typedef unsigned int & ( ::osg::Texture::*getTextureParameterDirty_function_type )( unsigned int ) const;
            
            Texture_exposer.def( 
                "getTextureParameterDirty"
                , getTextureParameterDirty_function_type( &::osg::Texture::getTextureParameterDirty )
                , ( bp::arg("contextID") )
                , bp::return_value_policy< bp::copy_non_const_reference >()
                , " Gets the dirty flag for the current contextID." );
        
        }
        { //::osg::Texture::getTextureTarget
        
            typedef ::GLenum ( ::osg::Texture::*getTextureTarget_function_type )(  ) const;
            
            Texture_exposer.def( 
                "getTextureTarget"
                , bp::pure_virtual( getTextureTarget_function_type(&::osg::Texture::getTextureTarget) ) );
        
        }
        { //::osg::Texture::getTextureWidth
        
            typedef int ( ::osg::Texture::*getTextureWidth_function_type )(  ) const;
            typedef int ( Texture_wrapper::*default_getTextureWidth_function_type )(  ) const;
            
            Texture_exposer.def( 
                "getTextureWidth"
                , getTextureWidth_function_type(&::osg::Texture::getTextureWidth)
                , default_getTextureWidth_function_type(&Texture_wrapper::default_getTextureWidth) );
        
        }
        { //::osg::Texture::getType
        
            typedef ::osg::StateAttribute::Type ( ::osg::Texture::*getType_function_type )(  ) const;
            typedef ::osg::StateAttribute::Type ( Texture_wrapper::*default_getType_function_type )(  ) const;
            
            Texture_exposer.def( 
                "getType"
                , getType_function_type(&::osg::Texture::getType)
                , default_getType_function_type(&Texture_wrapper::default_getType) );
        
        }
        { //::osg::Texture::getUnRefImageDataAfterApply
        
            typedef bool ( ::osg::Texture::*getUnRefImageDataAfterApply_function_type )(  ) const;
            
            Texture_exposer.def( 
                "getUnRefImageDataAfterApply"
                , getUnRefImageDataAfterApply_function_type( &::osg::Texture::getUnRefImageDataAfterApply )
                , " Gets whether or not apply() unreferences image data." );
        
        }
        { //::osg::Texture::getUseHardwareMipMapGeneration
        
            typedef bool ( ::osg::Texture::*getUseHardwareMipMapGeneration_function_type )(  ) const;
            
            Texture_exposer.def( 
                "getUseHardwareMipMapGeneration"
                , getUseHardwareMipMapGeneration_function_type( &::osg::Texture::getUseHardwareMipMapGeneration )
                , " Gets the hardware mipmap generation hint." );
        
        }
        { //::osg::Texture::getWrap
        
            typedef ::osg::Texture::WrapMode ( ::osg::Texture::*getWrap_function_type )( ::osg::Texture::WrapParameter ) const;
            
            Texture_exposer.def( 
                "getWrap"
                , getWrap_function_type( &::osg::Texture::getWrap )
                , ( bp::arg("which") )
                , " Gets the texture wrap mode." );
        
        }
        { //::osg::Texture::isCompressedInternalFormat
        
            typedef bool ( ::osg::Texture::*isCompressedInternalFormat_function_type )(  ) const;
            
            Texture_exposer.def( 
                "isCompressedInternalFormat"
                , isCompressedInternalFormat_function_type( &::osg::Texture::isCompressedInternalFormat )
                , " Return true if the internal format is one of the compressed formats." );
        
        }
        { //::osg::Texture::isCompressedInternalFormat
        
            typedef bool ( *isCompressedInternalFormat_function_type )( ::GLint );
            
            Texture_exposer.def( 
                "isCompressedInternalFormat"
                , isCompressedInternalFormat_function_type( &::osg::Texture::isCompressedInternalFormat )
                , ( bp::arg("internalFormat") )
                , " Determine whether the given internalFormat is a compressed\n image format." );
        
        }
        { //::osg::Texture::isSameKindAs
        
            typedef bool ( ::osg::Texture::*isSameKindAs_function_type )( ::osg::Object const * ) const;
            typedef bool ( Texture_wrapper::*default_isSameKindAs_function_type )( ::osg::Object const * ) const;
            
            Texture_exposer.def( 
                "isSameKindAs"
                , isSameKindAs_function_type(&::osg::Texture::isSameKindAs)
                , default_isSameKindAs_function_type(&Texture_wrapper::default_isSameKindAs)
                , ( bp::arg("obj") ) );
        
        }
        { //::osg::Texture::isTextureAttribute
        
            typedef bool ( ::osg::Texture::*isTextureAttribute_function_type )(  ) const;
            typedef bool ( Texture_wrapper::*default_isTextureAttribute_function_type )(  ) const;
            
            Texture_exposer.def( 
                "isTextureAttribute"
                , isTextureAttribute_function_type(&::osg::Texture::isTextureAttribute)
                , default_isTextureAttribute_function_type(&Texture_wrapper::default_isTextureAttribute) );
        
        }
        { //::osg::Texture::libraryName
        
            typedef char const * ( ::osg::Texture::*libraryName_function_type )(  ) const;
            typedef char const * ( Texture_wrapper::*default_libraryName_function_type )(  ) const;
            
            Texture_exposer.def( 
                "libraryName"
                , libraryName_function_type(&::osg::Texture::libraryName)
                , default_libraryName_function_type(&Texture_wrapper::default_libraryName) );
        
        }
        { //::osg::Texture::releaseTextureObject
        
            typedef void ( *releaseTextureObject_function_type )( unsigned int,::osg::Texture::TextureObject * );
            
            Texture_exposer.def( 
                "releaseTextureObject"
                , releaseTextureObject_function_type( &::osg::Texture::releaseTextureObject )
                , ( bp::arg("contextID"), bp::arg("to") ) );
        
        }
        { //::osg::Texture::resizeGLObjectBuffers
        
            typedef void ( ::osg::Texture::*resizeGLObjectBuffers_function_type )( unsigned int ) ;
            typedef void ( Texture_wrapper::*default_resizeGLObjectBuffers_function_type )( unsigned int ) ;
            
            Texture_exposer.def( 
                "resizeGLObjectBuffers"
                , resizeGLObjectBuffers_function_type(&::osg::Texture::resizeGLObjectBuffers)
                , default_resizeGLObjectBuffers_function_type(&Texture_wrapper::default_resizeGLObjectBuffers)
                , ( bp::arg("maxSize") ) );
        
        }
        { //::osg::Texture::setBorderColor
        
            typedef void ( ::osg::Texture::*setBorderColor_function_type )( ::osg::Vec4d const & ) ;
            
            Texture_exposer.def( 
                "setBorderColor"
                , setBorderColor_function_type( &::osg::Texture::setBorderColor )
                , ( bp::arg("color") )
                , " Sets the border color. Only used when wrap mode is CLAMP_TO_BORDER.\n The border color will be casted to the appropriate type to match the\n internal pixel format of the texture." );
        
        }
        { //::osg::Texture::setBorderWidth
        
            typedef void ( ::osg::Texture::*setBorderWidth_function_type )( ::GLint ) ;
            
            Texture_exposer.def( 
                "setBorderWidth"
                , setBorderWidth_function_type( &::osg::Texture::setBorderWidth )
                , ( bp::arg("width") )
                , " Sets the border width." );
        
        }
        { //::osg::Texture::setClientStorageHint
        
            typedef void ( ::osg::Texture::*setClientStorageHint_function_type )( bool ) ;
            
            Texture_exposer.def( 
                "setClientStorageHint"
                , setClientStorageHint_function_type( &::osg::Texture::setClientStorageHint )
                , ( bp::arg("flag") )
                , " Sets whether to use client storage for the texture, if supported\n by the graphics system. Note: If enabled, and the graphics system\n supports it, the osg::Image(s) associated with this texture cannot\n be deleted, so the UnRefImageDataAfterApply flag would be ignored." );
        
        }
        { //::osg::Texture::setExtensions
        
            typedef void ( *setExtensions_function_type )( unsigned int,::osg::Texture::Extensions * );
            
            Texture_exposer.def( 
                "setExtensions"
                , setExtensions_function_type( &::osg::Texture::setExtensions )
                , ( bp::arg("contextID"), bp::arg("extensions") )
                , " Overrides Extensions objects across graphics contexts. Typically\n used to ensure the same lowest common denominator of extensions\n on systems with different graphics pipes." );
        
        }
        { //::osg::Texture::setFilter
        
            typedef void ( ::osg::Texture::*setFilter_function_type )( ::osg::Texture::FilterParameter,::osg::Texture::FilterMode ) ;
            
            Texture_exposer.def( 
                "setFilter"
                , setFilter_function_type( &::osg::Texture::setFilter )
                , ( bp::arg("which"), bp::arg("filter") )
                , " Sets the texture filter mode." );
        
        }
        { //::osg::Texture::setImage
        
            typedef void ( ::osg::Texture::*setImage_function_type )( unsigned int,::osg::Image * ) ;
            
            Texture_exposer.def( 
                "setImage"
                , bp::pure_virtual( setImage_function_type(&::osg::Texture::setImage) )
                , ( bp::arg("face"), bp::arg("image") )
                , "\n Sets the texture image for the specified face.\n" );
        
        }
        { //::osg::Texture::setInternalFormat
        
            typedef void ( ::osg::Texture::*setInternalFormat_function_type )( ::GLint ) ;
            
            Texture_exposer.def( 
                "setInternalFormat"
                , setInternalFormat_function_type( &::osg::Texture::setInternalFormat )
                , ( bp::arg("internalFormat") )
                , " Sets the internal texture format. Implicitly sets the\n internalFormatMode to USE_USER_DEFINED_FORMAT.\n The corresponding internal format type will be computed." );
        
        }
        { //::osg::Texture::setInternalFormatMode
        
            typedef void ( ::osg::Texture::*setInternalFormatMode_function_type )( ::osg::Texture::InternalFormatMode ) ;
            
            Texture_exposer.def( 
                "setInternalFormatMode"
                , setInternalFormatMode_function_type( &::osg::Texture::setInternalFormatMode )
                , ( bp::arg("mode") )
                , " Sets the internal texture format mode. Note: If the texture format is\n USE_IMAGE_DATA_FORMAT, USE_ARB_COMPRESSION, or USE_S3TC_COMPRESSION,\n the internal format mode is set automatically and will overwrite the\n previous _internalFormat." );
        
        }
        { //::osg::Texture::setMaxAnisotropy
        
            typedef void ( ::osg::Texture::*setMaxAnisotropy_function_type )( float ) ;
            
            Texture_exposer.def( 
                "setMaxAnisotropy"
                , setMaxAnisotropy_function_type( &::osg::Texture::setMaxAnisotropy )
                , ( bp::arg("anis") )
                , " Sets the maximum anisotropy value, default value is 1.0 for no\n anisotropic filtering. If hardware does not support anisotropic\n filtering, use normal filtering (equivalent to a max anisotropy\n value of 1.0. Valid range is 1.0f upwards.  The maximum value\n depends on the graphics system." );
        
        }
        { //::osg::Texture::setReadPBuffer
        
            typedef void ( ::osg::Texture::*setReadPBuffer_function_type )( ::osg::GraphicsContext * ) ;
            
            Texture_exposer.def( 
                "setReadPBuffer"
                , setReadPBuffer_function_type( &::osg::Texture::setReadPBuffer )
                , ( bp::arg("context") )
                , " Set the PBuffer graphics context to read from when using PBuffers for RenderToTexture." );
        
        }
        { //::osg::Texture::setResizeNonPowerOfTwoHint
        
            typedef void ( ::osg::Texture::*setResizeNonPowerOfTwoHint_function_type )( bool ) ;
            
            Texture_exposer.def( 
                "setResizeNonPowerOfTwoHint"
                , setResizeNonPowerOfTwoHint_function_type( &::osg::Texture::setResizeNonPowerOfTwoHint )
                , ( bp::arg("flag") )
                , " Sets whether to force the texture to resize images that have dimensions\n that are not a power of two. If enabled, NPOT images will be resized,\n whether or not NPOT textures are supported by the hardware. If disabled,\n NPOT images will not be resized if supported by hardware." );
        
        }
        { //::osg::Texture::setShadowAmbient
        
            typedef void ( ::osg::Texture::*setShadowAmbient_function_type )( float ) ;
            
            Texture_exposer.def( 
                "setShadowAmbient"
                , setShadowAmbient_function_type( &::osg::Texture::setShadowAmbient )
                , ( bp::arg("shadow_ambient") )
                , " Sets the TEXTURE_COMPARE_FAIL_VALUE_ARB texture parameter. See\n http://oss.sgi.com/projects/ogl-sample/registry/ARB/shadow_ambient.txt." );
        
        }
        { //::osg::Texture::setShadowCompareFunc
        
            typedef void ( ::osg::Texture::*setShadowCompareFunc_function_type )( ::osg::Texture::ShadowCompareFunc ) ;
            
            Texture_exposer.def( 
                "setShadowCompareFunc"
                , setShadowCompareFunc_function_type( &::osg::Texture::setShadowCompareFunc )
                , ( bp::arg("func") )
                , " Sets shadow texture comparison function." );
        
        }
        { //::osg::Texture::setShadowComparison
        
            typedef void ( ::osg::Texture::*setShadowComparison_function_type )( bool ) ;
            
            Texture_exposer.def( 
                "setShadowComparison"
                , setShadowComparison_function_type( &::osg::Texture::setShadowComparison )
                , ( bp::arg("flag") )
                , " Sets GL_TEXTURE_COMPARE_MODE_ARB to GL_COMPARE_R_TO_TEXTURE_ARB\n See http://oss.sgi.com/projects/ogl-sample/registry/ARB/shadow.txt." );
        
        }
        { //::osg::Texture::setShadowTextureMode
        
            typedef void ( ::osg::Texture::*setShadowTextureMode_function_type )( ::osg::Texture::ShadowTextureMode ) ;
            
            Texture_exposer.def( 
                "setShadowTextureMode"
                , setShadowTextureMode_function_type( &::osg::Texture::setShadowTextureMode )
                , ( bp::arg("mode") )
                , " Sets shadow texture mode after comparison." );
        
        }
        { //::osg::Texture::setSourceFormat
        
            typedef void ( ::osg::Texture::*setSourceFormat_function_type )( ::GLenum ) ;
            
            Texture_exposer.def( 
                "setSourceFormat"
                , setSourceFormat_function_type( &::osg::Texture::setSourceFormat )
                , ( bp::arg("sourceFormat") )
                , " Sets the external source image format, used as a fallback when no osg::Image is attached to provide the source image format." );
        
        }
        { //::osg::Texture::setSourceType
        
            typedef void ( ::osg::Texture::*setSourceType_function_type )( ::GLenum ) ;
            
            Texture_exposer.def( 
                "setSourceType"
                , setSourceType_function_type( &::osg::Texture::setSourceType )
                , ( bp::arg("sourceType") )
                , " Sets the external source data type, used as a fallback when no osg::Image is attached to provide the source image format." );
        
        }
        { //::osg::Texture::setSwizzle
        
            typedef void ( ::osg::Texture::*setSwizzle_function_type )( ::osg::Vec4i const & ) ;
            
            Texture_exposer.def( 
                "setSwizzle"
                , setSwizzle_function_type( &::osg::Texture::setSwizzle )
                , ( bp::arg("swizzle") )
                , " Configure the source of texture swizzling for all channels" );
        
        }
        { //::osg::Texture::setTextureObject
        
            typedef void ( ::osg::Texture::*setTextureObject_function_type )( unsigned int,::osg::Texture::TextureObject * ) ;
            
            Texture_exposer.def( 
                "setTextureObject"
                , setTextureObject_function_type( &::osg::Texture::setTextureObject )
                , ( bp::arg("contextID"), bp::arg("to") ) );
        
        }
        { //::osg::Texture::setUnRefImageDataAfterApply
        
            typedef void ( ::osg::Texture::*setUnRefImageDataAfterApply_function_type )( bool ) ;
            
            Texture_exposer.def( 
                "setUnRefImageDataAfterApply"
                , setUnRefImageDataAfterApply_function_type( &::osg::Texture::setUnRefImageDataAfterApply )
                , ( bp::arg("flag") )
                , " Sets whether or not the apply() function will unreference the image\n data. If enabled, and the image data is only referenced by this\n Texture, apply() will delete the image data." );
        
        }
        { //::osg::Texture::setUseHardwareMipMapGeneration
        
            typedef void ( ::osg::Texture::*setUseHardwareMipMapGeneration_function_type )( bool ) ;
            
            Texture_exposer.def( 
                "setUseHardwareMipMapGeneration"
                , setUseHardwareMipMapGeneration_function_type( &::osg::Texture::setUseHardwareMipMapGeneration )
                , ( bp::arg("useHardwareMipMapGeneration") )
                , " Sets the hardware mipmap generation hint. If enabled, it will\n only be used if supported in the graphics system." );
        
        }
        { //::osg::Texture::setWrap
        
            typedef void ( ::osg::Texture::*setWrap_function_type )( ::osg::Texture::WrapParameter,::osg::Texture::WrapMode ) ;
            
            Texture_exposer.def( 
                "setWrap"
                , setWrap_function_type( &::osg::Texture::setWrap )
                , ( bp::arg("which"), bp::arg("wrap") )
                , " Sets the texture wrap mode." );
        
        }
        { //::osg::StateAttribute::checkValidityOfAssociatedModes
        
            typedef bool ( ::osg::StateAttribute::*checkValidityOfAssociatedModes_function_type )( ::osg::State & ) const;
            typedef bool ( Texture_wrapper::*default_checkValidityOfAssociatedModes_function_type )( ::osg::State & ) const;
            
            Texture_exposer.def( 
                "checkValidityOfAssociatedModes"
                , checkValidityOfAssociatedModes_function_type(&::osg::StateAttribute::checkValidityOfAssociatedModes)
                , default_checkValidityOfAssociatedModes_function_type(&Texture_wrapper::default_checkValidityOfAssociatedModes)
                , ( bp::arg("arg0") ) );
        
        }
        { //::osg::Object::computeDataVariance
        
            typedef void ( ::osg::Object::*computeDataVariance_function_type )(  ) ;
            typedef void ( Texture_wrapper::*default_computeDataVariance_function_type )(  ) ;
            
            Texture_exposer.def( 
                "computeDataVariance"
                , computeDataVariance_function_type(&::osg::Object::computeDataVariance)
                , default_computeDataVariance_function_type(&Texture_wrapper::default_computeDataVariance) );
        
        }
        { //::osg::StateAttribute::getMember
        
            typedef unsigned int ( ::osg::StateAttribute::*getMember_function_type )(  ) const;
            typedef unsigned int ( Texture_wrapper::*default_getMember_function_type )(  ) const;
            
            Texture_exposer.def( 
                "getMember"
                , getMember_function_type(&::osg::StateAttribute::getMember)
                , default_getMember_function_type(&Texture_wrapper::default_getMember) );
        
        }
        { //::osg::Object::getUserData
        
            typedef ::osg::Referenced * ( ::osg::Object::*getUserData_function_type )(  ) ;
            typedef ::osg::Referenced * ( Texture_wrapper::*default_getUserData_function_type )(  ) ;
            
            Texture_exposer.def( 
                "getUserData"
                , getUserData_function_type(&::osg::Object::getUserData)
                , default_getUserData_function_type(&Texture_wrapper::default_getUserData)
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::Object::getUserData
        
            typedef ::osg::Referenced const * ( ::osg::Object::*getUserData_function_type )(  ) const;
            typedef ::osg::Referenced const * ( Texture_wrapper::*default_getUserData_function_type )(  ) const;
            
            Texture_exposer.def( 
                "getUserData"
                , getUserData_function_type(&::osg::Object::getUserData)
                , default_getUserData_function_type(&Texture_wrapper::default_getUserData)
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::Object::setName
        
            typedef void ( ::osg::Object::*setName_function_type )( ::std::string const & ) ;
            typedef void ( Texture_wrapper::*default_setName_function_type )( ::std::string const & ) ;
            
            Texture_exposer.def( 
                "setName"
                , setName_function_type(&::osg::Object::setName)
                , default_setName_function_type(&Texture_wrapper::default_setName)
                , ( bp::arg("name") ) );
        
        }
        { //::osg::Object::setName
        
            typedef void ( ::osg::Object::*setName_function_type )( char const * ) ;
            
            Texture_exposer.def( 
                "setName"
                , setName_function_type( &::osg::Object::setName )
                , ( bp::arg("name") )
                , " Set the name of object using a C style string." );
        
        }
        { //::osg::Object::setThreadSafeRefUnref
        
            typedef void ( ::osg::Object::*setThreadSafeRefUnref_function_type )( bool ) ;
            typedef void ( Texture_wrapper::*default_setThreadSafeRefUnref_function_type )( bool ) ;
            
            Texture_exposer.def( 
                "setThreadSafeRefUnref"
                , setThreadSafeRefUnref_function_type(&::osg::Object::setThreadSafeRefUnref)
                , default_setThreadSafeRefUnref_function_type(&Texture_wrapper::default_setThreadSafeRefUnref)
                , ( bp::arg("threadSafe") ) );
        
        }
        { //::osg::Object::setUserData
        
            typedef void ( ::osg::Object::*setUserData_function_type )( ::osg::Referenced * ) ;
            typedef void ( Texture_wrapper::*default_setUserData_function_type )( ::osg::Referenced * ) ;
            
            Texture_exposer.def( 
                "setUserData"
                , setUserData_function_type(&::osg::Object::setUserData)
                , default_setUserData_function_type(&Texture_wrapper::default_setUserData)
                , ( bp::arg("obj") ) );
        
        }
        Texture_exposer.staticmethod( "deleteAllTextureObjects" );
        Texture_exposer.staticmethod( "discardAllDeletedTextureObjects" );
        Texture_exposer.staticmethod( "discardAllTextureObjects" );
        Texture_exposer.staticmethod( "flushAllDeletedTextureObjects" );
        Texture_exposer.staticmethod( "flushDeletedTextureObjects" );
        Texture_exposer.staticmethod( "generateTextureObject" );
        Texture_exposer.staticmethod( "getCompressedSize" );
        Texture_exposer.staticmethod( "getExtensions" );
        Texture_exposer.staticmethod( "getTextureObjectManager" );
        Texture_exposer.staticmethod( "isCompressedInternalFormat" );
        Texture_exposer.staticmethod( "releaseTextureObject" );
        Texture_exposer.staticmethod( "setExtensions" );
    }

}
