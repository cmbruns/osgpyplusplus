// This file has been generated by Py++.

#include "boost/python.hpp"
#include "wrap_osg.h"
#include "wrap_referenced.h"
#include "Transform.pypp.hpp"

namespace bp = boost::python;

struct Transform_wrapper : osg::Transform, bp::wrapper< osg::Transform > {

    Transform_wrapper( )
    : osg::Transform( )
      , bp::wrapper< osg::Transform >(){
        // null constructor
    
    }

    virtual void accept( ::osg::NodeVisitor & nv ) {
        if( bp::override func_accept = this->get_override( "accept" ) )
            func_accept( boost::ref(nv) );
        else{
            this->osg::Transform::accept( boost::ref(nv) );
        }
    }
    
    void default_accept( ::osg::NodeVisitor & nv ) {
        osg::Transform::accept( boost::ref(nv) );
    }

    virtual ::osg::MatrixTransform * asMatrixTransform(  ) {
        if( bp::override func_asMatrixTransform = this->get_override( "asMatrixTransform" ) )
            return func_asMatrixTransform(  );
        else{
            return this->osg::Transform::asMatrixTransform(  );
        }
    }
    
    ::osg::MatrixTransform * default_asMatrixTransform(  ) {
        return osg::Transform::asMatrixTransform( );
    }

    virtual ::osg::MatrixTransform const * asMatrixTransform(  ) const  {
        if( bp::override func_asMatrixTransform = this->get_override( "asMatrixTransform" ) )
            return func_asMatrixTransform(  );
        else{
            return this->osg::Transform::asMatrixTransform(  );
        }
    }
    
    ::osg::MatrixTransform const * default_asMatrixTransform(  ) const  {
        return osg::Transform::asMatrixTransform( );
    }

    virtual ::osg::PositionAttitudeTransform * asPositionAttitudeTransform(  ) {
        if( bp::override func_asPositionAttitudeTransform = this->get_override( "asPositionAttitudeTransform" ) )
            return func_asPositionAttitudeTransform(  );
        else{
            return this->osg::Transform::asPositionAttitudeTransform(  );
        }
    }
    
    ::osg::PositionAttitudeTransform * default_asPositionAttitudeTransform(  ) {
        return osg::Transform::asPositionAttitudeTransform( );
    }

    virtual ::osg::PositionAttitudeTransform const * asPositionAttitudeTransform(  ) const  {
        if( bp::override func_asPositionAttitudeTransform = this->get_override( "asPositionAttitudeTransform" ) )
            return func_asPositionAttitudeTransform(  );
        else{
            return this->osg::Transform::asPositionAttitudeTransform(  );
        }
    }
    
    ::osg::PositionAttitudeTransform const * default_asPositionAttitudeTransform(  ) const  {
        return osg::Transform::asPositionAttitudeTransform( );
    }

    virtual ::osg::Transform * asTransform(  ) {
        if( bp::override func_asTransform = this->get_override( "asTransform" ) )
            return func_asTransform(  );
        else{
            return this->osg::Transform::asTransform(  );
        }
    }
    
    ::osg::Transform * default_asTransform(  ) {
        return osg::Transform::asTransform( );
    }

    virtual ::osg::Transform const * asTransform(  ) const  {
        if( bp::override func_asTransform = this->get_override( "asTransform" ) )
            return func_asTransform(  );
        else{
            return this->osg::Transform::asTransform(  );
        }
    }
    
    ::osg::Transform const * default_asTransform(  ) const  {
        return osg::Transform::asTransform( );
    }

    virtual char const * className(  ) const  {
        if( bp::override func_className = this->get_override( "className" ) )
            return func_className(  );
        else{
            return this->osg::Transform::className(  );
        }
    }
    
    char const * default_className(  ) const  {
        return osg::Transform::className( );
    }

    virtual ::osg::Object * clone( ::osg::CopyOp const & copyop ) const  {
        if( bp::override func_clone = this->get_override( "clone" ) )
            return func_clone( boost::ref(copyop) );
        else{
            return this->osg::Transform::clone( boost::ref(copyop) );
        }
    }
    
    ::osg::Object * default_clone( ::osg::CopyOp const & copyop ) const  {
        return osg::Transform::clone( boost::ref(copyop) );
    }

    virtual ::osg::Object * cloneType(  ) const  {
        if( bp::override func_cloneType = this->get_override( "cloneType" ) )
            return func_cloneType(  );
        else{
            return this->osg::Transform::cloneType(  );
        }
    }
    
    ::osg::Object * default_cloneType(  ) const  {
        return osg::Transform::cloneType( );
    }

    virtual ::osg::BoundingSphere computeBound(  ) const  {
        if( bp::override func_computeBound = this->get_override( "computeBound" ) )
            return func_computeBound(  );
        else{
            return this->osg::Transform::computeBound(  );
        }
    }
    
    ::osg::BoundingSphere default_computeBound(  ) const  {
        return osg::Transform::computeBound( );
    }

    virtual bool computeLocalToWorldMatrix( ::osg::Matrix & matrix, ::osg::NodeVisitor * arg1 ) const  {
        if( bp::override func_computeLocalToWorldMatrix = this->get_override( "computeLocalToWorldMatrix" ) )
            return func_computeLocalToWorldMatrix( boost::ref(matrix), boost::python::ptr(arg1) );
        else{
            return this->osg::Transform::computeLocalToWorldMatrix( boost::ref(matrix), boost::python::ptr(arg1) );
        }
    }
    
    bool default_computeLocalToWorldMatrix( ::osg::Matrix & matrix, ::osg::NodeVisitor * arg1 ) const  {
        return osg::Transform::computeLocalToWorldMatrix( boost::ref(matrix), boost::python::ptr(arg1) );
    }

    virtual bool computeWorldToLocalMatrix( ::osg::Matrix & matrix, ::osg::NodeVisitor * arg1 ) const  {
        if( bp::override func_computeWorldToLocalMatrix = this->get_override( "computeWorldToLocalMatrix" ) )
            return func_computeWorldToLocalMatrix( boost::ref(matrix), boost::python::ptr(arg1) );
        else{
            return this->osg::Transform::computeWorldToLocalMatrix( boost::ref(matrix), boost::python::ptr(arg1) );
        }
    }
    
    bool default_computeWorldToLocalMatrix( ::osg::Matrix & matrix, ::osg::NodeVisitor * arg1 ) const  {
        return osg::Transform::computeWorldToLocalMatrix( boost::ref(matrix), boost::python::ptr(arg1) );
    }

    virtual bool isSameKindAs( ::osg::Object const * obj ) const  {
        if( bp::override func_isSameKindAs = this->get_override( "isSameKindAs" ) )
            return func_isSameKindAs( boost::python::ptr(obj) );
        else{
            return this->osg::Transform::isSameKindAs( boost::python::ptr(obj) );
        }
    }
    
    bool default_isSameKindAs( ::osg::Object const * obj ) const  {
        return osg::Transform::isSameKindAs( boost::python::ptr(obj) );
    }

    virtual char const * libraryName(  ) const  {
        if( bp::override func_libraryName = this->get_override( "libraryName" ) )
            return func_libraryName(  );
        else{
            return this->osg::Transform::libraryName(  );
        }
    }
    
    char const * default_libraryName(  ) const  {
        return osg::Transform::libraryName( );
    }

    virtual bool addChild( ::osg::Node * child ) {
        if( bp::override func_addChild = this->get_override( "addChild" ) )
            return func_addChild( boost::python::ptr(child) );
        else{
            return this->osg::Group::addChild( boost::python::ptr(child) );
        }
    }
    
    bool default_addChild( ::osg::Node * child ) {
        return osg::Group::addChild( boost::python::ptr(child) );
    }

    virtual ::osg::Camera * asCamera(  ) {
        if( bp::override func_asCamera = this->get_override( "asCamera" ) )
            return func_asCamera(  );
        else{
            return this->osg::Node::asCamera(  );
        }
    }
    
    ::osg::Camera * default_asCamera(  ) {
        return osg::Node::asCamera( );
    }

    virtual ::osg::Camera const * asCamera(  ) const  {
        if( bp::override func_asCamera = this->get_override( "asCamera" ) )
            return func_asCamera(  );
        else{
            return this->osg::Node::asCamera(  );
        }
    }
    
    ::osg::Camera const * default_asCamera(  ) const  {
        return osg::Node::asCamera( );
    }

    virtual ::osg::Geode * asGeode(  ) {
        if( bp::override func_asGeode = this->get_override( "asGeode" ) )
            return func_asGeode(  );
        else{
            return this->osg::Node::asGeode(  );
        }
    }
    
    ::osg::Geode * default_asGeode(  ) {
        return osg::Node::asGeode( );
    }

    virtual ::osg::Geode const * asGeode(  ) const  {
        if( bp::override func_asGeode = this->get_override( "asGeode" ) )
            return func_asGeode(  );
        else{
            return this->osg::Node::asGeode(  );
        }
    }
    
    ::osg::Geode const * default_asGeode(  ) const  {
        return osg::Node::asGeode( );
    }

    virtual ::osg::Group * asGroup(  ) {
        if( bp::override func_asGroup = this->get_override( "asGroup" ) )
            return func_asGroup(  );
        else{
            return this->osg::Group::asGroup(  );
        }
    }
    
    ::osg::Group * default_asGroup(  ) {
        return osg::Group::asGroup( );
    }

    virtual ::osg::Group const * asGroup(  ) const  {
        if( bp::override func_asGroup = this->get_override( "asGroup" ) )
            return func_asGroup(  );
        else{
            return this->osg::Group::asGroup(  );
        }
    }
    
    ::osg::Group const * default_asGroup(  ) const  {
        return osg::Group::asGroup( );
    }

    virtual ::osg::Switch * asSwitch(  ) {
        if( bp::override func_asSwitch = this->get_override( "asSwitch" ) )
            return func_asSwitch(  );
        else{
            return this->osg::Node::asSwitch(  );
        }
    }
    
    ::osg::Switch * default_asSwitch(  ) {
        return osg::Node::asSwitch( );
    }

    virtual ::osg::Switch const * asSwitch(  ) const  {
        if( bp::override func_asSwitch = this->get_override( "asSwitch" ) )
            return func_asSwitch(  );
        else{
            return this->osg::Node::asSwitch(  );
        }
    }
    
    ::osg::Switch const * default_asSwitch(  ) const  {
        return osg::Node::asSwitch( );
    }

    virtual void ascend( ::osg::NodeVisitor & nv ) {
        if( bp::override func_ascend = this->get_override( "ascend" ) )
            func_ascend( boost::ref(nv) );
        else{
            this->osg::Node::ascend( boost::ref(nv) );
        }
    }
    
    void default_ascend( ::osg::NodeVisitor & nv ) {
        osg::Node::ascend( boost::ref(nv) );
    }

    virtual bool insertChild( unsigned int index, ::osg::Node * child ) {
        if( bp::override func_insertChild = this->get_override( "insertChild" ) )
            return func_insertChild( index, boost::python::ptr(child) );
        else{
            return this->osg::Group::insertChild( index, boost::python::ptr(child) );
        }
    }
    
    bool default_insertChild( unsigned int index, ::osg::Node * child ) {
        return osg::Group::insertChild( index, boost::python::ptr(child) );
    }

    virtual bool removeChildren( unsigned int pos, unsigned int numChildrenToRemove ) {
        if( bp::override func_removeChildren = this->get_override( "removeChildren" ) )
            return func_removeChildren( pos, numChildrenToRemove );
        else{
            return this->osg::Group::removeChildren( pos, numChildrenToRemove );
        }
    }
    
    bool default_removeChildren( unsigned int pos, unsigned int numChildrenToRemove ) {
        return osg::Group::removeChildren( pos, numChildrenToRemove );
    }

    virtual bool replaceChild( ::osg::Node * origChild, ::osg::Node * newChild ) {
        if( bp::override func_replaceChild = this->get_override( "replaceChild" ) )
            return func_replaceChild( boost::python::ptr(origChild), boost::python::ptr(newChild) );
        else{
            return this->osg::Group::replaceChild( boost::python::ptr(origChild), boost::python::ptr(newChild) );
        }
    }
    
    bool default_replaceChild( ::osg::Node * origChild, ::osg::Node * newChild ) {
        return osg::Group::replaceChild( boost::python::ptr(origChild), boost::python::ptr(newChild) );
    }

    virtual void resizeGLObjectBuffers( unsigned int maxSize ) {
        if( bp::override func_resizeGLObjectBuffers = this->get_override( "resizeGLObjectBuffers" ) )
            func_resizeGLObjectBuffers( maxSize );
        else{
            this->osg::Group::resizeGLObjectBuffers( maxSize );
        }
    }
    
    void default_resizeGLObjectBuffers( unsigned int maxSize ) {
        osg::Group::resizeGLObjectBuffers( maxSize );
    }

    virtual bool setChild( unsigned int i, ::osg::Node * node ) {
        if( bp::override func_setChild = this->get_override( "setChild" ) )
            return func_setChild( i, boost::python::ptr(node) );
        else{
            return this->osg::Group::setChild( i, boost::python::ptr(node) );
        }
    }
    
    bool default_setChild( unsigned int i, ::osg::Node * node ) {
        return osg::Group::setChild( i, boost::python::ptr(node) );
    }

    virtual void setThreadSafeRefUnref( bool threadSafe ) {
        if( bp::override func_setThreadSafeRefUnref = this->get_override( "setThreadSafeRefUnref" ) )
            func_setThreadSafeRefUnref( threadSafe );
        else{
            this->osg::Group::setThreadSafeRefUnref( threadSafe );
        }
    }
    
    void default_setThreadSafeRefUnref( bool threadSafe ) {
        osg::Group::setThreadSafeRefUnref( threadSafe );
    }

    virtual void traverse( ::osg::NodeVisitor & nv ) {
        if( bp::override func_traverse = this->get_override( "traverse" ) )
            func_traverse( boost::ref(nv) );
        else{
            this->osg::Group::traverse( boost::ref(nv) );
        }
    }
    
    void default_traverse( ::osg::NodeVisitor & nv ) {
        osg::Group::traverse( boost::ref(nv) );
    }

};

void register_Transform_class(){

    { //::osg::Transform
        typedef bp::class_< Transform_wrapper, bp::bases< osg::Group >, osg::ref_ptr< ::osg::Transform >, boost::noncopyable > Transform_exposer_t;
        Transform_exposer_t Transform_exposer = Transform_exposer_t( "Transform", "\n A Transform is a group node for which all children are transformed by\n a 4x4 matrix. It is often used for positioning objects within a scene,\n producing trackball functionality or for animation.\n\n Transform itself does not provide set/get functions, only the interface\n for defining what the 4x4 transformation is.  Subclasses, such as\n MatrixTransform and PositionAttitudeTransform support the use of an\n osg::Matrix or a osg::Vec3/osg::Quat respectively.\n\n Note: If the transformation matrix scales the subgraph then the normals\n of the underlying geometry will need to be renormalized to be unit\n vectors once more.  This can be done transparently through OpenGLs\n use of either GL_NORMALIZE and GL_RESCALE_NORMAL modes. For further\n background reading see the glNormalize documentation in the OpenGL\n Reference Guide (the blue book). To enable it in the OSG, you simply\n need to attach a local osg::StateSet to the osg::Transform, and set\n the appropriate mode to ON via\n   stateset->setMode(GL_NORMALIZE, osg::StateAttribute::ON);\n", bp::no_init );
        bp::scope Transform_scope( Transform_exposer );
        bp::enum_< osg::Transform::ReferenceFrame>("ReferenceFrame")
            .value("RELATIVE_RF", osg::Transform::RELATIVE_RF)
            .value("ABSOLUTE_RF", osg::Transform::ABSOLUTE_RF)
            .value("ABSOLUTE_RF_INHERIT_VIEWPOINT", osg::Transform::ABSOLUTE_RF_INHERIT_VIEWPOINT)
            .export_values()
            ;
        Transform_exposer.def( bp::init< >("\n A Transform is a group node for which all children are transformed by\n a 4x4 matrix. It is often used for positioning objects within a scene,\n producing trackball functionality or for animation.\n\n Transform itself does not provide set/get functions, only the interface\n for defining what the 4x4 transformation is.  Subclasses, such as\n MatrixTransform and PositionAttitudeTransform support the use of an\n osg::Matrix or a osg::Vec3/osg::Quat respectively.\n\n Note: If the transformation matrix scales the subgraph then the normals\n of the underlying geometry will need to be renormalized to be unit\n vectors once more.  This can be done transparently through OpenGLs\n use of either GL_NORMALIZE and GL_RESCALE_NORMAL modes. For further\n background reading see the glNormalize documentation in the OpenGL\n Reference Guide (the blue book). To enable it in the OSG, you simply\n need to attach a local osg::StateSet to the osg::Transform, and set\n the appropriate mode to ON via\n   stateset->setMode(GL_NORMALIZE, osg::StateAttribute::ON);\n") );
        { //::osg::Transform::accept
        
            typedef void ( ::osg::Transform::*accept_function_type )( ::osg::NodeVisitor & ) ;
            typedef void ( Transform_wrapper::*default_accept_function_type )( ::osg::NodeVisitor & ) ;
            
            Transform_exposer.def( 
                "accept"
                , accept_function_type(&::osg::Transform::accept)
                , default_accept_function_type(&Transform_wrapper::default_accept)
                , ( bp::arg("nv") ) );
        
        }
        { //::osg::Transform::asMatrixTransform
        
            typedef ::osg::MatrixTransform * ( ::osg::Transform::*asMatrixTransform_function_type )(  ) ;
            typedef ::osg::MatrixTransform * ( Transform_wrapper::*default_asMatrixTransform_function_type )(  ) ;
            
            Transform_exposer.def( 
                "asMatrixTransform"
                , asMatrixTransform_function_type(&::osg::Transform::asMatrixTransform)
                , default_asMatrixTransform_function_type(&Transform_wrapper::default_asMatrixTransform)
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::Transform::asMatrixTransform
        
            typedef ::osg::MatrixTransform const * ( ::osg::Transform::*asMatrixTransform_function_type )(  ) const;
            typedef ::osg::MatrixTransform const * ( Transform_wrapper::*default_asMatrixTransform_function_type )(  ) const;
            
            Transform_exposer.def( 
                "asMatrixTransform"
                , asMatrixTransform_function_type(&::osg::Transform::asMatrixTransform)
                , default_asMatrixTransform_function_type(&Transform_wrapper::default_asMatrixTransform)
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::Transform::asPositionAttitudeTransform
        
            typedef ::osg::PositionAttitudeTransform * ( ::osg::Transform::*asPositionAttitudeTransform_function_type )(  ) ;
            typedef ::osg::PositionAttitudeTransform * ( Transform_wrapper::*default_asPositionAttitudeTransform_function_type )(  ) ;
            
            Transform_exposer.def( 
                "asPositionAttitudeTransform"
                , asPositionAttitudeTransform_function_type(&::osg::Transform::asPositionAttitudeTransform)
                , default_asPositionAttitudeTransform_function_type(&Transform_wrapper::default_asPositionAttitudeTransform)
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::Transform::asPositionAttitudeTransform
        
            typedef ::osg::PositionAttitudeTransform const * ( ::osg::Transform::*asPositionAttitudeTransform_function_type )(  ) const;
            typedef ::osg::PositionAttitudeTransform const * ( Transform_wrapper::*default_asPositionAttitudeTransform_function_type )(  ) const;
            
            Transform_exposer.def( 
                "asPositionAttitudeTransform"
                , asPositionAttitudeTransform_function_type(&::osg::Transform::asPositionAttitudeTransform)
                , default_asPositionAttitudeTransform_function_type(&Transform_wrapper::default_asPositionAttitudeTransform)
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::Transform::asTransform
        
            typedef ::osg::Transform * ( ::osg::Transform::*asTransform_function_type )(  ) ;
            typedef ::osg::Transform * ( Transform_wrapper::*default_asTransform_function_type )(  ) ;
            
            Transform_exposer.def( 
                "asTransform"
                , asTransform_function_type(&::osg::Transform::asTransform)
                , default_asTransform_function_type(&Transform_wrapper::default_asTransform)
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::Transform::asTransform
        
            typedef ::osg::Transform const * ( ::osg::Transform::*asTransform_function_type )(  ) const;
            typedef ::osg::Transform const * ( Transform_wrapper::*default_asTransform_function_type )(  ) const;
            
            Transform_exposer.def( 
                "asTransform"
                , asTransform_function_type(&::osg::Transform::asTransform)
                , default_asTransform_function_type(&Transform_wrapper::default_asTransform)
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::Transform::className
        
            typedef char const * ( ::osg::Transform::*className_function_type )(  ) const;
            typedef char const * ( Transform_wrapper::*default_className_function_type )(  ) const;
            
            Transform_exposer.def( 
                "className"
                , className_function_type(&::osg::Transform::className)
                , default_className_function_type(&Transform_wrapper::default_className) );
        
        }
        { //::osg::Transform::clone
        
            typedef ::osg::Object * ( ::osg::Transform::*clone_function_type )( ::osg::CopyOp const & ) const;
            typedef ::osg::Object * ( Transform_wrapper::*default_clone_function_type )( ::osg::CopyOp const & ) const;
            
            Transform_exposer.def( 
                "clone"
                , clone_function_type(&::osg::Transform::clone)
                , default_clone_function_type(&Transform_wrapper::default_clone)
                , ( bp::arg("copyop") )
                , bp::return_value_policy< bp::reference_existing_object >() );
        
        }
        { //::osg::Transform::cloneType
        
            typedef ::osg::Object * ( ::osg::Transform::*cloneType_function_type )(  ) const;
            typedef ::osg::Object * ( Transform_wrapper::*default_cloneType_function_type )(  ) const;
            
            Transform_exposer.def( 
                "cloneType"
                , cloneType_function_type(&::osg::Transform::cloneType)
                , default_cloneType_function_type(&Transform_wrapper::default_cloneType)
                , bp::return_value_policy< bp::reference_existing_object >() );
        
        }
        { //::osg::Transform::computeBound
        
            typedef ::osg::BoundingSphere ( ::osg::Transform::*computeBound_function_type )(  ) const;
            typedef ::osg::BoundingSphere ( Transform_wrapper::*default_computeBound_function_type )(  ) const;
            
            Transform_exposer.def( 
                "computeBound"
                , computeBound_function_type(&::osg::Transform::computeBound)
                , default_computeBound_function_type(&Transform_wrapper::default_computeBound) );
        
        }
        { //::osg::Transform::computeLocalToWorldMatrix
        
            typedef bool ( ::osg::Transform::*computeLocalToWorldMatrix_function_type )( ::osg::Matrix &,::osg::NodeVisitor * ) const;
            typedef bool ( Transform_wrapper::*default_computeLocalToWorldMatrix_function_type )( ::osg::Matrix &,::osg::NodeVisitor * ) const;
            
            Transform_exposer.def( 
                "computeLocalToWorldMatrix"
                , computeLocalToWorldMatrix_function_type(&::osg::Transform::computeLocalToWorldMatrix)
                , default_computeLocalToWorldMatrix_function_type(&Transform_wrapper::default_computeLocalToWorldMatrix)
                , ( bp::arg("matrix"), bp::arg("arg1") ) );
        
        }
        { //::osg::Transform::computeWorldToLocalMatrix
        
            typedef bool ( ::osg::Transform::*computeWorldToLocalMatrix_function_type )( ::osg::Matrix &,::osg::NodeVisitor * ) const;
            typedef bool ( Transform_wrapper::*default_computeWorldToLocalMatrix_function_type )( ::osg::Matrix &,::osg::NodeVisitor * ) const;
            
            Transform_exposer.def( 
                "computeWorldToLocalMatrix"
                , computeWorldToLocalMatrix_function_type(&::osg::Transform::computeWorldToLocalMatrix)
                , default_computeWorldToLocalMatrix_function_type(&Transform_wrapper::default_computeWorldToLocalMatrix)
                , ( bp::arg("matrix"), bp::arg("arg1") ) );
        
        }
        { //::osg::Transform::getReferenceFrame
        
            typedef ::osg::Transform::ReferenceFrame ( ::osg::Transform::*getReferenceFrame_function_type )(  ) const;
            
            Transform_exposer.def( 
                "getReferenceFrame"
                , getReferenceFrame_function_type( &::osg::Transform::getReferenceFrame ) );
        
        }
        { //::osg::Transform::isSameKindAs
        
            typedef bool ( ::osg::Transform::*isSameKindAs_function_type )( ::osg::Object const * ) const;
            typedef bool ( Transform_wrapper::*default_isSameKindAs_function_type )( ::osg::Object const * ) const;
            
            Transform_exposer.def( 
                "isSameKindAs"
                , isSameKindAs_function_type(&::osg::Transform::isSameKindAs)
                , default_isSameKindAs_function_type(&Transform_wrapper::default_isSameKindAs)
                , ( bp::arg("obj") ) );
        
        }
        { //::osg::Transform::libraryName
        
            typedef char const * ( ::osg::Transform::*libraryName_function_type )(  ) const;
            typedef char const * ( Transform_wrapper::*default_libraryName_function_type )(  ) const;
            
            Transform_exposer.def( 
                "libraryName"
                , libraryName_function_type(&::osg::Transform::libraryName)
                , default_libraryName_function_type(&Transform_wrapper::default_libraryName) );
        
        }
        { //::osg::Transform::setReferenceFrame
        
            typedef void ( ::osg::Transform::*setReferenceFrame_function_type )( ::osg::Transform::ReferenceFrame ) ;
            
            Transform_exposer.def( 
                "setReferenceFrame"
                , setReferenceFrame_function_type( &::osg::Transform::setReferenceFrame )
                , ( bp::arg("rf") )
                , " Set the transforms ReferenceFrame, either to be relative to its\n parent reference frame, or relative to an absolute coordinate\n frame. RELATIVE_RF is the default.\n Note: Setting the ReferenceFrame to be ABSOLUTE_RF will\n also set the CullingActive flag on the transform, and hence all\n of its parents, to false, thereby disabling culling of it and\n all its parents.  This is necessary to prevent inappropriate\n culling, but may impact cull times if the absolute transform is\n deep in the scene graph.  It is therefore recommended to only use\n absolute Transforms at the top of the scene, for such things as\n heads up displays.\n ABSOLUTE_RF_INHERIT_VIEWPOINT is the same as ABSOLUTE_RF except it\n adds the ability to use the parents view points position in world coordinates\n as its local viewpoint in the new coordinates frame.  This is useful for\n Render to texture Cameras that wish to use the main views LOD range computation\n (which uses the viewpoint rather than the eye point) rather than use the local\n eye point defined by the this Transforms absolute view matrix." );
        
        }
        { //::osg::Group::addChild
        
            typedef bool ( ::osg::Group::*addChild_function_type )( ::osg::Node * ) ;
            typedef bool ( Transform_wrapper::*default_addChild_function_type )( ::osg::Node * ) ;
            
            Transform_exposer.def( 
                "addChild"
                , addChild_function_type(&::osg::Group::addChild)
                , default_addChild_function_type(&Transform_wrapper::default_addChild)
                , ( bp::arg("child") ) );
        
        }
        { //::osg::Node::asCamera
        
            typedef ::osg::Camera * ( ::osg::Node::*asCamera_function_type )(  ) ;
            typedef ::osg::Camera * ( Transform_wrapper::*default_asCamera_function_type )(  ) ;
            
            Transform_exposer.def( 
                "asCamera"
                , asCamera_function_type(&::osg::Node::asCamera)
                , default_asCamera_function_type(&Transform_wrapper::default_asCamera)
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::Node::asCamera
        
            typedef ::osg::Camera const * ( ::osg::Node::*asCamera_function_type )(  ) const;
            typedef ::osg::Camera const * ( Transform_wrapper::*default_asCamera_function_type )(  ) const;
            
            Transform_exposer.def( 
                "asCamera"
                , asCamera_function_type(&::osg::Node::asCamera)
                , default_asCamera_function_type(&Transform_wrapper::default_asCamera)
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::Node::asGeode
        
            typedef ::osg::Geode * ( ::osg::Node::*asGeode_function_type )(  ) ;
            typedef ::osg::Geode * ( Transform_wrapper::*default_asGeode_function_type )(  ) ;
            
            Transform_exposer.def( 
                "asGeode"
                , asGeode_function_type(&::osg::Node::asGeode)
                , default_asGeode_function_type(&Transform_wrapper::default_asGeode)
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::Node::asGeode
        
            typedef ::osg::Geode const * ( ::osg::Node::*asGeode_function_type )(  ) const;
            typedef ::osg::Geode const * ( Transform_wrapper::*default_asGeode_function_type )(  ) const;
            
            Transform_exposer.def( 
                "asGeode"
                , asGeode_function_type(&::osg::Node::asGeode)
                , default_asGeode_function_type(&Transform_wrapper::default_asGeode)
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::Group::asGroup
        
            typedef ::osg::Group * ( ::osg::Group::*asGroup_function_type )(  ) ;
            typedef ::osg::Group * ( Transform_wrapper::*default_asGroup_function_type )(  ) ;
            
            Transform_exposer.def( 
                "asGroup"
                , asGroup_function_type(&::osg::Group::asGroup)
                , default_asGroup_function_type(&Transform_wrapper::default_asGroup)
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::Group::asGroup
        
            typedef ::osg::Group const * ( ::osg::Group::*asGroup_function_type )(  ) const;
            typedef ::osg::Group const * ( Transform_wrapper::*default_asGroup_function_type )(  ) const;
            
            Transform_exposer.def( 
                "asGroup"
                , asGroup_function_type(&::osg::Group::asGroup)
                , default_asGroup_function_type(&Transform_wrapper::default_asGroup)
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::Node::asSwitch
        
            typedef ::osg::Switch * ( ::osg::Node::*asSwitch_function_type )(  ) ;
            typedef ::osg::Switch * ( Transform_wrapper::*default_asSwitch_function_type )(  ) ;
            
            Transform_exposer.def( 
                "asSwitch"
                , asSwitch_function_type(&::osg::Node::asSwitch)
                , default_asSwitch_function_type(&Transform_wrapper::default_asSwitch)
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::Node::asSwitch
        
            typedef ::osg::Switch const * ( ::osg::Node::*asSwitch_function_type )(  ) const;
            typedef ::osg::Switch const * ( Transform_wrapper::*default_asSwitch_function_type )(  ) const;
            
            Transform_exposer.def( 
                "asSwitch"
                , asSwitch_function_type(&::osg::Node::asSwitch)
                , default_asSwitch_function_type(&Transform_wrapper::default_asSwitch)
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::Node::ascend
        
            typedef void ( ::osg::Node::*ascend_function_type )( ::osg::NodeVisitor & ) ;
            typedef void ( Transform_wrapper::*default_ascend_function_type )( ::osg::NodeVisitor & ) ;
            
            Transform_exposer.def( 
                "ascend"
                , ascend_function_type(&::osg::Node::ascend)
                , default_ascend_function_type(&Transform_wrapper::default_ascend)
                , ( bp::arg("nv") ) );
        
        }
        { //::osg::Group::insertChild
        
            typedef bool ( ::osg::Group::*insertChild_function_type )( unsigned int,::osg::Node * ) ;
            typedef bool ( Transform_wrapper::*default_insertChild_function_type )( unsigned int,::osg::Node * ) ;
            
            Transform_exposer.def( 
                "insertChild"
                , insertChild_function_type(&::osg::Group::insertChild)
                , default_insertChild_function_type(&Transform_wrapper::default_insertChild)
                , ( bp::arg("index"), bp::arg("child") ) );
        
        }
        { //::osg::Group::removeChildren
        
            typedef bool ( ::osg::Group::*removeChildren_function_type )( unsigned int,unsigned int ) ;
            typedef bool ( Transform_wrapper::*default_removeChildren_function_type )( unsigned int,unsigned int ) ;
            
            Transform_exposer.def( 
                "removeChildren"
                , removeChildren_function_type(&::osg::Group::removeChildren)
                , default_removeChildren_function_type(&Transform_wrapper::default_removeChildren)
                , ( bp::arg("pos"), bp::arg("numChildrenToRemove") ) );
        
        }
        { //::osg::Group::replaceChild
        
            typedef bool ( ::osg::Group::*replaceChild_function_type )( ::osg::Node *,::osg::Node * ) ;
            typedef bool ( Transform_wrapper::*default_replaceChild_function_type )( ::osg::Node *,::osg::Node * ) ;
            
            Transform_exposer.def( 
                "replaceChild"
                , replaceChild_function_type(&::osg::Group::replaceChild)
                , default_replaceChild_function_type(&Transform_wrapper::default_replaceChild)
                , ( bp::arg("origChild"), bp::arg("newChild") ) );
        
        }
        { //::osg::Group::resizeGLObjectBuffers
        
            typedef void ( ::osg::Group::*resizeGLObjectBuffers_function_type )( unsigned int ) ;
            typedef void ( Transform_wrapper::*default_resizeGLObjectBuffers_function_type )( unsigned int ) ;
            
            Transform_exposer.def( 
                "resizeGLObjectBuffers"
                , resizeGLObjectBuffers_function_type(&::osg::Group::resizeGLObjectBuffers)
                , default_resizeGLObjectBuffers_function_type(&Transform_wrapper::default_resizeGLObjectBuffers)
                , ( bp::arg("maxSize") ) );
        
        }
        { //::osg::Group::setChild
        
            typedef bool ( ::osg::Group::*setChild_function_type )( unsigned int,::osg::Node * ) ;
            typedef bool ( Transform_wrapper::*default_setChild_function_type )( unsigned int,::osg::Node * ) ;
            
            Transform_exposer.def( 
                "setChild"
                , setChild_function_type(&::osg::Group::setChild)
                , default_setChild_function_type(&Transform_wrapper::default_setChild)
                , ( bp::arg("i"), bp::arg("node") ) );
        
        }
        { //::osg::Group::setThreadSafeRefUnref
        
            typedef void ( ::osg::Group::*setThreadSafeRefUnref_function_type )( bool ) ;
            typedef void ( Transform_wrapper::*default_setThreadSafeRefUnref_function_type )( bool ) ;
            
            Transform_exposer.def( 
                "setThreadSafeRefUnref"
                , setThreadSafeRefUnref_function_type(&::osg::Group::setThreadSafeRefUnref)
                , default_setThreadSafeRefUnref_function_type(&Transform_wrapper::default_setThreadSafeRefUnref)
                , ( bp::arg("threadSafe") ) );
        
        }
        { //::osg::Group::traverse
        
            typedef void ( ::osg::Group::*traverse_function_type )( ::osg::NodeVisitor & ) ;
            typedef void ( Transform_wrapper::*default_traverse_function_type )( ::osg::NodeVisitor & ) ;
            
            Transform_exposer.def( 
                "traverse"
                , traverse_function_type(&::osg::Group::traverse)
                , default_traverse_function_type(&Transform_wrapper::default_traverse)
                , ( bp::arg("nv") ) );
        
        }
    }

}
