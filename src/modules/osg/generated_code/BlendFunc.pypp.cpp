// This file has been generated by Py++.

#include "boost/python.hpp"
#include "__call_policies.pypp.hpp"
#include "wrap_osg.h"
#include "wrap_referenced.h"
#include "BlendFunc.pypp.hpp"

namespace bp = boost::python;

struct BlendFunc_wrapper : osg::BlendFunc, bp::wrapper< osg::BlendFunc > {

    BlendFunc_wrapper( )
    : osg::BlendFunc( )
      , bp::wrapper< osg::BlendFunc >(){
        // null constructor
    
    }

    BlendFunc_wrapper(::GLenum source, ::GLenum destination )
    : osg::BlendFunc( source, destination )
      , bp::wrapper< osg::BlendFunc >(){
        // constructor
    
    }

    BlendFunc_wrapper(::GLenum source, ::GLenum destination, ::GLenum source_alpha, ::GLenum destination_alpha )
    : osg::BlendFunc( source, destination, source_alpha, destination_alpha )
      , bp::wrapper< osg::BlendFunc >(){
        // constructor
    
    }

    virtual void apply( ::osg::State & state ) const  {
        if( bp::override func_apply = this->get_override( "apply" ) )
            func_apply( boost::ref(state) );
        else{
            this->osg::BlendFunc::apply( boost::ref(state) );
        }
    }
    
    void default_apply( ::osg::State & state ) const  {
        osg::BlendFunc::apply( boost::ref(state) );
    }

    virtual char const * className(  ) const  {
        if( bp::override func_className = this->get_override( "className" ) )
            return func_className(  );
        else{
            return this->osg::BlendFunc::className(  );
        }
    }
    
    char const * default_className(  ) const  {
        return osg::BlendFunc::className( );
    }

    virtual ::osg::Object * clone( ::osg::CopyOp const & copyop ) const  {
        if( bp::override func_clone = this->get_override( "clone" ) )
            return func_clone( boost::ref(copyop) );
        else{
            return this->osg::BlendFunc::clone( boost::ref(copyop) );
        }
    }
    
    ::osg::Object * default_clone( ::osg::CopyOp const & copyop ) const  {
        return osg::BlendFunc::clone( boost::ref(copyop) );
    }

    virtual ::osg::Object * cloneType(  ) const  {
        if( bp::override func_cloneType = this->get_override( "cloneType" ) )
            return func_cloneType(  );
        else{
            return this->osg::BlendFunc::cloneType(  );
        }
    }
    
    ::osg::Object * default_cloneType(  ) const  {
        return osg::BlendFunc::cloneType( );
    }

    virtual bool getModeUsage( ::osg::StateAttribute::ModeUsage & usage ) const  {
        if( bp::override func_getModeUsage = this->get_override( "getModeUsage" ) )
            return func_getModeUsage( boost::ref(usage) );
        else{
            return this->osg::BlendFunc::getModeUsage( boost::ref(usage) );
        }
    }
    
    bool default_getModeUsage( ::osg::StateAttribute::ModeUsage & usage ) const  {
        return osg::BlendFunc::getModeUsage( boost::ref(usage) );
    }

    virtual ::osg::StateAttribute::Type getType(  ) const  {
        if( bp::override func_getType = this->get_override( "getType" ) )
            return func_getType(  );
        else{
            return this->osg::BlendFunc::getType(  );
        }
    }
    
    ::osg::StateAttribute::Type default_getType(  ) const  {
        return osg::BlendFunc::getType( );
    }

    virtual bool isSameKindAs( ::osg::Object const * obj ) const  {
        if( bp::override func_isSameKindAs = this->get_override( "isSameKindAs" ) )
            return func_isSameKindAs( boost::python::ptr(obj) );
        else{
            return this->osg::BlendFunc::isSameKindAs( boost::python::ptr(obj) );
        }
    }
    
    bool default_isSameKindAs( ::osg::Object const * obj ) const  {
        return osg::BlendFunc::isSameKindAs( boost::python::ptr(obj) );
    }

    virtual char const * libraryName(  ) const  {
        if( bp::override func_libraryName = this->get_override( "libraryName" ) )
            return func_libraryName(  );
        else{
            return this->osg::BlendFunc::libraryName(  );
        }
    }
    
    char const * default_libraryName(  ) const  {
        return osg::BlendFunc::libraryName( );
    }

    virtual ::osg::Texture * asTexture(  ) {
        if( bp::override func_asTexture = this->get_override( "asTexture" ) )
            return func_asTexture(  );
        else{
            return this->osg::StateAttribute::asTexture(  );
        }
    }
    
    ::osg::Texture * default_asTexture(  ) {
        return osg::StateAttribute::asTexture( );
    }

    virtual ::osg::Texture const * asTexture(  ) const  {
        if( bp::override func_asTexture = this->get_override( "asTexture" ) )
            return func_asTexture(  );
        else{
            return this->osg::StateAttribute::asTexture(  );
        }
    }
    
    ::osg::Texture const * default_asTexture(  ) const  {
        return osg::StateAttribute::asTexture( );
    }

    virtual bool checkValidityOfAssociatedModes( ::osg::State & arg0 ) const  {
        if( bp::override func_checkValidityOfAssociatedModes = this->get_override( "checkValidityOfAssociatedModes" ) )
            return func_checkValidityOfAssociatedModes( boost::ref(arg0) );
        else{
            return this->osg::StateAttribute::checkValidityOfAssociatedModes( boost::ref(arg0) );
        }
    }
    
    bool default_checkValidityOfAssociatedModes( ::osg::State & arg0 ) const  {
        return osg::StateAttribute::checkValidityOfAssociatedModes( boost::ref(arg0) );
    }

    virtual void compileGLObjects( ::osg::State & arg0 ) const  {
        if( bp::override func_compileGLObjects = this->get_override( "compileGLObjects" ) )
            func_compileGLObjects( boost::ref(arg0) );
        else{
            this->osg::StateAttribute::compileGLObjects( boost::ref(arg0) );
        }
    }
    
    void default_compileGLObjects( ::osg::State & arg0 ) const  {
        osg::StateAttribute::compileGLObjects( boost::ref(arg0) );
    }

    virtual unsigned int getMember(  ) const  {
        if( bp::override func_getMember = this->get_override( "getMember" ) )
            return func_getMember(  );
        else{
            return this->osg::StateAttribute::getMember(  );
        }
    }
    
    unsigned int default_getMember(  ) const  {
        return osg::StateAttribute::getMember( );
    }

    virtual bool isTextureAttribute(  ) const  {
        if( bp::override func_isTextureAttribute = this->get_override( "isTextureAttribute" ) )
            return func_isTextureAttribute(  );
        else{
            return this->osg::StateAttribute::isTextureAttribute(  );
        }
    }
    
    bool default_isTextureAttribute(  ) const  {
        return osg::StateAttribute::isTextureAttribute( );
    }

    virtual void resizeGLObjectBuffers( unsigned int arg0 ) {
        if( bp::override func_resizeGLObjectBuffers = this->get_override( "resizeGLObjectBuffers" ) )
            func_resizeGLObjectBuffers( arg0 );
        else{
            this->osg::StateAttribute::resizeGLObjectBuffers( arg0 );
        }
    }
    
    void default_resizeGLObjectBuffers( unsigned int arg0 ) {
        osg::StateAttribute::resizeGLObjectBuffers( arg0 );
    }

};

static void lowestCommonDenominator_24197d1812ea8a7d6d8f643bcb262b43( ::osg::BlendFunc::Extensions & inst, ::osg::BlendFunc::Extensions & rhs ){
    inst.lowestCommonDenominator(rhs);
}

void register_BlendFunc_class(){

    { //::osg::BlendFunc
        typedef bp::class_< BlendFunc_wrapper, bp::bases< osg::StateAttribute >, osg::ref_ptr< ::osg::BlendFunc >, boost::noncopyable > BlendFunc_exposer_t;
        BlendFunc_exposer_t BlendFunc_exposer = BlendFunc_exposer_t( "BlendFunc", "\n Encapsulates OpenGL blend/transparency state.\n\n  Blending combines incoming fragment with a fragment\n  already present in the target buffer.\n\n  OpenGL 1.1 supports following source and destination blending factors:\n  GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA,\n  GL_DST_ALPHA, GL_ONE_MINUS_DST_ALPHA,\n  GL_ZERO, GL_ONE.\n\n  Moreover, there are three source-only blending factors:\n  GL_DST_COLOR, GL_ONE_MINUS_DST_COLOR, GL_SRC_ALPHA_SATURATE\n  and two destination-only blending factors:\n  GL_SRC_COLOR, GL_ONE_MINUS_SRC_COLOR.\n  OpenGL 1.4 allowed to use these five blending factors\n  as both - source and destination blending factors.\n\n  Following four source and destination blending factors\n  were added by Imaging subset of OpenGL 1.2\n  and made mandatory by OpenGL 1.4:\n  GL_CONSTANT_COLOR, GL_ONE_MINUS_CONSTANT_COLOR,\n  GL_CONSTANT_ALPHA, GL_ONE_MINUS_CONSTANT_ALPHA\n\n  OpenGL 1.4 further provides glBlendFuncSeparate\n  (promoted from GL_EXT_blend_func_separate).\n  It makes possible to set blending functions for RGB and Alpha separately.\n  Before, it was possible to set just one blending function for RGBA.\n", bp::no_init );
        bp::scope BlendFunc_scope( BlendFunc_exposer );
        bp::enum_< osg::BlendFunc::BlendFuncMode>("BlendFuncMode")
            .value("DST_ALPHA", osg::BlendFunc::DST_ALPHA)
            .value("DST_COLOR", osg::BlendFunc::DST_COLOR)
            .value("ONE", osg::BlendFunc::ONE)
            .value("ONE_MINUS_DST_ALPHA", osg::BlendFunc::ONE_MINUS_DST_ALPHA)
            .value("ONE_MINUS_DST_COLOR", osg::BlendFunc::ONE_MINUS_DST_COLOR)
            .value("ONE_MINUS_SRC_ALPHA", osg::BlendFunc::ONE_MINUS_SRC_ALPHA)
            .value("ONE_MINUS_SRC_COLOR", osg::BlendFunc::ONE_MINUS_SRC_COLOR)
            .value("SRC_ALPHA", osg::BlendFunc::SRC_ALPHA)
            .value("SRC_ALPHA_SATURATE", osg::BlendFunc::SRC_ALPHA_SATURATE)
            .value("SRC_COLOR", osg::BlendFunc::SRC_COLOR)
            .value("CONSTANT_COLOR", osg::BlendFunc::CONSTANT_COLOR)
            .value("ONE_MINUS_CONSTANT_COLOR", osg::BlendFunc::ONE_MINUS_CONSTANT_COLOR)
            .value("CONSTANT_ALPHA", osg::BlendFunc::CONSTANT_ALPHA)
            .value("ONE_MINUS_CONSTANT_ALPHA", osg::BlendFunc::ONE_MINUS_CONSTANT_ALPHA)
            .value("ZERO", osg::BlendFunc::ZERO)
            .export_values()
            ;
        { //::osg::BlendFunc::Extensions
            typedef bp::class_< osg::BlendFunc::Extensions, bp::bases< osg::Referenced >, osg::ref_ptr< ::osg::BlendFunc::Extensions > > Extensions_exposer_t;
            Extensions_exposer_t Extensions_exposer = Extensions_exposer_t( "Extensions", " Encapsulates queries of extension availability, obtains extension\n function pointers, and provides convenience wrappers for\n calling extension functions.", bp::no_init );
            bp::scope Extensions_scope( Extensions_exposer );
            Extensions_exposer.def( bp::init< unsigned int >(( bp::arg("contextID") ), " Encapsulates queries of extension availability, obtains extension\n function pointers, and provides convenience wrappers for\n calling extension functions.") );
            bp::implicitly_convertible< unsigned int, osg::BlendFunc::Extensions >();
            { //::osg::BlendFunc::Extensions::glBlendFuncSeparate
            
                typedef void ( ::osg::BlendFunc::Extensions::*glBlendFuncSeparate_function_type )( ::GLenum,::GLenum,::GLenum,::GLenum ) const;
                
                Extensions_exposer.def( 
                    "glBlendFuncSeparate"
                    , glBlendFuncSeparate_function_type( &::osg::BlendFunc::Extensions::glBlendFuncSeparate )
                    , ( bp::arg("sfactorRGB"), bp::arg("dfactorRGB"), bp::arg("sfactorAlpha"), bp::arg("dfactorAlpha") ) );
            
            }
            { //::osg::BlendFunc::Extensions::isBlendFuncSeparateSupported
            
                typedef bool ( ::osg::BlendFunc::Extensions::*isBlendFuncSeparateSupported_function_type )(  ) const;
                
                Extensions_exposer.def( 
                    "isBlendFuncSeparateSupported"
                    , isBlendFuncSeparateSupported_function_type( &::osg::BlendFunc::Extensions::isBlendFuncSeparateSupported ) );
            
            }
            { //::osg::BlendFunc::Extensions::lowestCommonDenominator
            
                typedef void ( *lowestCommonDenominator_function_type )( ::osg::BlendFunc::Extensions &,::osg::BlendFunc::Extensions & );
                
                Extensions_exposer.def( 
                    "lowestCommonDenominator"
                    , lowestCommonDenominator_function_type( &lowestCommonDenominator_24197d1812ea8a7d6d8f643bcb262b43 )
                    , ( bp::arg("inst"), bp::arg("rhs") ) );
            
            }
            { //::osg::BlendFunc::Extensions::setBlendFuncSeparateSupported
            
                typedef void ( ::osg::BlendFunc::Extensions::*setBlendFuncSeparateSupported_function_type )( bool ) ;
                
                Extensions_exposer.def( 
                    "setBlendFuncSeparateSupported"
                    , setBlendFuncSeparateSupported_function_type( &::osg::BlendFunc::Extensions::setBlendFuncSeparateSupported )
                    , ( bp::arg("flag") ) );
            
            }
            { //::osg::BlendFunc::Extensions::setupGLExtensions
            
                typedef void ( ::osg::BlendFunc::Extensions::*setupGLExtensions_function_type )( unsigned int ) ;
                
                Extensions_exposer.def( 
                    "setupGLExtensions"
                    , setupGLExtensions_function_type( &::osg::BlendFunc::Extensions::setupGLExtensions )
                    , ( bp::arg("contextID") ) );
            
            }
        }
        BlendFunc_exposer.def( bp::init< >("\n Encapsulates OpenGL blend/transparency state.\n\n  Blending combines incoming fragment with a fragment\n  already present in the target buffer.\n\n  OpenGL 1.1 supports following source and destination blending factors:\n  GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA,\n  GL_DST_ALPHA, GL_ONE_MINUS_DST_ALPHA,\n  GL_ZERO, GL_ONE.\n\n  Moreover, there are three source-only blending factors:\n  GL_DST_COLOR, GL_ONE_MINUS_DST_COLOR, GL_SRC_ALPHA_SATURATE\n  and two destination-only blending factors:\n  GL_SRC_COLOR, GL_ONE_MINUS_SRC_COLOR.\n  OpenGL 1.4 allowed to use these five blending factors\n  as both - source and destination blending factors.\n\n  Following four source and destination blending factors\n  were added by Imaging subset of OpenGL 1.2\n  and made mandatory by OpenGL 1.4:\n  GL_CONSTANT_COLOR, GL_ONE_MINUS_CONSTANT_COLOR,\n  GL_CONSTANT_ALPHA, GL_ONE_MINUS_CONSTANT_ALPHA\n\n  OpenGL 1.4 further provides glBlendFuncSeparate\n  (promoted from GL_EXT_blend_func_separate).\n  It makes possible to set blending functions for RGB and Alpha separately.\n  Before, it was possible to set just one blending function for RGBA.\n") );
        BlendFunc_exposer.def( bp::init< GLenum, GLenum >(( bp::arg("source"), bp::arg("destination") )) );
        BlendFunc_exposer.def( bp::init< GLenum, GLenum, GLenum, GLenum >(( bp::arg("source"), bp::arg("destination"), bp::arg("source_alpha"), bp::arg("destination_alpha") )) );
        { //::osg::BlendFunc::apply
        
            typedef void ( ::osg::BlendFunc::*apply_function_type )( ::osg::State & ) const;
            typedef void ( BlendFunc_wrapper::*default_apply_function_type )( ::osg::State & ) const;
            
            BlendFunc_exposer.def( 
                "apply"
                , apply_function_type(&::osg::BlendFunc::apply)
                , default_apply_function_type(&BlendFunc_wrapper::default_apply)
                , ( bp::arg("state") ) );
        
        }
        { //::osg::BlendFunc::className
        
            typedef char const * ( ::osg::BlendFunc::*className_function_type )(  ) const;
            typedef char const * ( BlendFunc_wrapper::*default_className_function_type )(  ) const;
            
            BlendFunc_exposer.def( 
                "className"
                , className_function_type(&::osg::BlendFunc::className)
                , default_className_function_type(&BlendFunc_wrapper::default_className) );
        
        }
        { //::osg::BlendFunc::clone
        
            typedef ::osg::Object * ( ::osg::BlendFunc::*clone_function_type )( ::osg::CopyOp const & ) const;
            typedef ::osg::Object * ( BlendFunc_wrapper::*default_clone_function_type )( ::osg::CopyOp const & ) const;
            
            BlendFunc_exposer.def( 
                "clone"
                , clone_function_type(&::osg::BlendFunc::clone)
                , default_clone_function_type(&BlendFunc_wrapper::default_clone)
                , ( bp::arg("copyop") )
                , bp::return_value_policy< bp::reference_existing_object >() );
        
        }
        { //::osg::BlendFunc::cloneType
        
            typedef ::osg::Object * ( ::osg::BlendFunc::*cloneType_function_type )(  ) const;
            typedef ::osg::Object * ( BlendFunc_wrapper::*default_cloneType_function_type )(  ) const;
            
            BlendFunc_exposer.def( 
                "cloneType"
                , cloneType_function_type(&::osg::BlendFunc::cloneType)
                , default_cloneType_function_type(&BlendFunc_wrapper::default_cloneType)
                , bp::return_value_policy< bp::reference_existing_object >() );
        
        }
        { //::osg::BlendFunc::getDestination
        
            typedef ::GLenum ( ::osg::BlendFunc::*getDestination_function_type )(  ) const;
            
            BlendFunc_exposer.def( 
                "getDestination"
                , getDestination_function_type( &::osg::BlendFunc::getDestination ) );
        
        }
        { //::osg::BlendFunc::getDestinationAlpha
        
            typedef ::GLenum ( ::osg::BlendFunc::*getDestinationAlpha_function_type )(  ) const;
            
            BlendFunc_exposer.def( 
                "getDestinationAlpha"
                , getDestinationAlpha_function_type( &::osg::BlendFunc::getDestinationAlpha ) );
        
        }
        { //::osg::BlendFunc::getDestinationRGB
        
            typedef ::GLenum ( ::osg::BlendFunc::*getDestinationRGB_function_type )(  ) const;
            
            BlendFunc_exposer.def( 
                "getDestinationRGB"
                , getDestinationRGB_function_type( &::osg::BlendFunc::getDestinationRGB ) );
        
        }
        { //::osg::BlendFunc::getExtensions
        
            typedef ::osg::BlendFunc::Extensions * ( *getExtensions_function_type )( unsigned int,bool );
            
            BlendFunc_exposer.def( 
                "getExtensions"
                , getExtensions_function_type( &::osg::BlendFunc::getExtensions )
                , ( bp::arg("contextID"), bp::arg("createIfNotInitalized") )
                , bp::return_internal_reference< >()
                , " Returns the Extensions object for the given context.\n If createIfNotInitalized is true and the Extensions object doesnt\n exist, getExtensions() creates it on the given context.\n Returns NULL if createIfNotInitalized is false and the Extensions\n object doesnt exist." );
        
        }
        { //::osg::BlendFunc::getModeUsage
        
            typedef bool ( ::osg::BlendFunc::*getModeUsage_function_type )( ::osg::StateAttribute::ModeUsage & ) const;
            typedef bool ( BlendFunc_wrapper::*default_getModeUsage_function_type )( ::osg::StateAttribute::ModeUsage & ) const;
            
            BlendFunc_exposer.def( 
                "getModeUsage"
                , getModeUsage_function_type(&::osg::BlendFunc::getModeUsage)
                , default_getModeUsage_function_type(&BlendFunc_wrapper::default_getModeUsage)
                , ( bp::arg("usage") ) );
        
        }
        { //::osg::BlendFunc::getSource
        
            typedef ::GLenum ( ::osg::BlendFunc::*getSource_function_type )(  ) const;
            
            BlendFunc_exposer.def( 
                "getSource"
                , getSource_function_type( &::osg::BlendFunc::getSource ) );
        
        }
        { //::osg::BlendFunc::getSourceAlpha
        
            typedef ::GLenum ( ::osg::BlendFunc::*getSourceAlpha_function_type )(  ) const;
            
            BlendFunc_exposer.def( 
                "getSourceAlpha"
                , getSourceAlpha_function_type( &::osg::BlendFunc::getSourceAlpha ) );
        
        }
        { //::osg::BlendFunc::getSourceRGB
        
            typedef ::GLenum ( ::osg::BlendFunc::*getSourceRGB_function_type )(  ) const;
            
            BlendFunc_exposer.def( 
                "getSourceRGB"
                , getSourceRGB_function_type( &::osg::BlendFunc::getSourceRGB ) );
        
        }
        { //::osg::BlendFunc::getType
        
            typedef ::osg::StateAttribute::Type ( ::osg::BlendFunc::*getType_function_type )(  ) const;
            typedef ::osg::StateAttribute::Type ( BlendFunc_wrapper::*default_getType_function_type )(  ) const;
            
            BlendFunc_exposer.def( 
                "getType"
                , getType_function_type(&::osg::BlendFunc::getType)
                , default_getType_function_type(&BlendFunc_wrapper::default_getType) );
        
        }
        { //::osg::BlendFunc::isSameKindAs
        
            typedef bool ( ::osg::BlendFunc::*isSameKindAs_function_type )( ::osg::Object const * ) const;
            typedef bool ( BlendFunc_wrapper::*default_isSameKindAs_function_type )( ::osg::Object const * ) const;
            
            BlendFunc_exposer.def( 
                "isSameKindAs"
                , isSameKindAs_function_type(&::osg::BlendFunc::isSameKindAs)
                , default_isSameKindAs_function_type(&BlendFunc_wrapper::default_isSameKindAs)
                , ( bp::arg("obj") ) );
        
        }
        { //::osg::BlendFunc::libraryName
        
            typedef char const * ( ::osg::BlendFunc::*libraryName_function_type )(  ) const;
            typedef char const * ( BlendFunc_wrapper::*default_libraryName_function_type )(  ) const;
            
            BlendFunc_exposer.def( 
                "libraryName"
                , libraryName_function_type(&::osg::BlendFunc::libraryName)
                , default_libraryName_function_type(&BlendFunc_wrapper::default_libraryName) );
        
        }
        { //::osg::BlendFunc::setDestination
        
            typedef void ( ::osg::BlendFunc::*setDestination_function_type )( ::GLenum ) ;
            
            BlendFunc_exposer.def( 
                "setDestination"
                , setDestination_function_type( &::osg::BlendFunc::setDestination )
                , ( bp::arg("destination") ) );
        
        }
        { //::osg::BlendFunc::setDestinationAlpha
        
            typedef void ( ::osg::BlendFunc::*setDestinationAlpha_function_type )( ::GLenum ) ;
            
            BlendFunc_exposer.def( 
                "setDestinationAlpha"
                , setDestinationAlpha_function_type( &::osg::BlendFunc::setDestinationAlpha )
                , ( bp::arg("destination") ) );
        
        }
        { //::osg::BlendFunc::setDestinationRGB
        
            typedef void ( ::osg::BlendFunc::*setDestinationRGB_function_type )( ::GLenum ) ;
            
            BlendFunc_exposer.def( 
                "setDestinationRGB"
                , setDestinationRGB_function_type( &::osg::BlendFunc::setDestinationRGB )
                , ( bp::arg("destination") ) );
        
        }
        { //::osg::BlendFunc::setExtensions
        
            typedef void ( *setExtensions_function_type )( unsigned int,::osg::BlendFunc::Extensions * );
            
            BlendFunc_exposer.def( 
                "setExtensions"
                , setExtensions_function_type( &::osg::BlendFunc::setExtensions )
                , ( bp::arg("contextID"), bp::arg("extensions") )
                , " setExtensions() allows users to override the extensions across graphics contexts.\n Typically used when you have different extensions supported across graphics pipes,\n but need to ensure that they all use the same low common denominator extensions." );
        
        }
        { //::osg::BlendFunc::setFunction
        
            typedef void ( ::osg::BlendFunc::*setFunction_function_type )( ::GLenum,::GLenum ) ;
            
            BlendFunc_exposer.def( 
                "setFunction"
                , setFunction_function_type( &::osg::BlendFunc::setFunction )
                , ( bp::arg("source"), bp::arg("destination") ) );
        
        }
        { //::osg::BlendFunc::setFunction
        
            typedef void ( ::osg::BlendFunc::*setFunction_function_type )( ::GLenum,::GLenum,::GLenum,::GLenum ) ;
            
            BlendFunc_exposer.def( 
                "setFunction"
                , setFunction_function_type( &::osg::BlendFunc::setFunction )
                , ( bp::arg("source_rgb"), bp::arg("destination_rgb"), bp::arg("source_alpha"), bp::arg("destination_alpha") ) );
        
        }
        { //::osg::BlendFunc::setSource
        
            typedef void ( ::osg::BlendFunc::*setSource_function_type )( ::GLenum ) ;
            
            BlendFunc_exposer.def( 
                "setSource"
                , setSource_function_type( &::osg::BlendFunc::setSource )
                , ( bp::arg("source") ) );
        
        }
        { //::osg::BlendFunc::setSourceAlpha
        
            typedef void ( ::osg::BlendFunc::*setSourceAlpha_function_type )( ::GLenum ) ;
            
            BlendFunc_exposer.def( 
                "setSourceAlpha"
                , setSourceAlpha_function_type( &::osg::BlendFunc::setSourceAlpha )
                , ( bp::arg("source") ) );
        
        }
        { //::osg::BlendFunc::setSourceRGB
        
            typedef void ( ::osg::BlendFunc::*setSourceRGB_function_type )( ::GLenum ) ;
            
            BlendFunc_exposer.def( 
                "setSourceRGB"
                , setSourceRGB_function_type( &::osg::BlendFunc::setSourceRGB )
                , ( bp::arg("source") ) );
        
        }
        { //::osg::StateAttribute::asTexture
        
            typedef ::osg::Texture * ( ::osg::StateAttribute::*asTexture_function_type )(  ) ;
            typedef ::osg::Texture * ( BlendFunc_wrapper::*default_asTexture_function_type )(  ) ;
            
            BlendFunc_exposer.def( 
                "asTexture"
                , asTexture_function_type(&::osg::StateAttribute::asTexture)
                , default_asTexture_function_type(&BlendFunc_wrapper::default_asTexture)
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::StateAttribute::asTexture
        
            typedef ::osg::Texture const * ( ::osg::StateAttribute::*asTexture_function_type )(  ) const;
            typedef ::osg::Texture const * ( BlendFunc_wrapper::*default_asTexture_function_type )(  ) const;
            
            BlendFunc_exposer.def( 
                "asTexture"
                , asTexture_function_type(&::osg::StateAttribute::asTexture)
                , default_asTexture_function_type(&BlendFunc_wrapper::default_asTexture)
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::StateAttribute::checkValidityOfAssociatedModes
        
            typedef bool ( ::osg::StateAttribute::*checkValidityOfAssociatedModes_function_type )( ::osg::State & ) const;
            typedef bool ( BlendFunc_wrapper::*default_checkValidityOfAssociatedModes_function_type )( ::osg::State & ) const;
            
            BlendFunc_exposer.def( 
                "checkValidityOfAssociatedModes"
                , checkValidityOfAssociatedModes_function_type(&::osg::StateAttribute::checkValidityOfAssociatedModes)
                , default_checkValidityOfAssociatedModes_function_type(&BlendFunc_wrapper::default_checkValidityOfAssociatedModes)
                , ( bp::arg("arg0") ) );
        
        }
        { //::osg::StateAttribute::compileGLObjects
        
            typedef void ( ::osg::StateAttribute::*compileGLObjects_function_type )( ::osg::State & ) const;
            typedef void ( BlendFunc_wrapper::*default_compileGLObjects_function_type )( ::osg::State & ) const;
            
            BlendFunc_exposer.def( 
                "compileGLObjects"
                , compileGLObjects_function_type(&::osg::StateAttribute::compileGLObjects)
                , default_compileGLObjects_function_type(&BlendFunc_wrapper::default_compileGLObjects)
                , ( bp::arg("arg0") ) );
        
        }
        { //::osg::StateAttribute::getMember
        
            typedef unsigned int ( ::osg::StateAttribute::*getMember_function_type )(  ) const;
            typedef unsigned int ( BlendFunc_wrapper::*default_getMember_function_type )(  ) const;
            
            BlendFunc_exposer.def( 
                "getMember"
                , getMember_function_type(&::osg::StateAttribute::getMember)
                , default_getMember_function_type(&BlendFunc_wrapper::default_getMember) );
        
        }
        { //::osg::StateAttribute::isTextureAttribute
        
            typedef bool ( ::osg::StateAttribute::*isTextureAttribute_function_type )(  ) const;
            typedef bool ( BlendFunc_wrapper::*default_isTextureAttribute_function_type )(  ) const;
            
            BlendFunc_exposer.def( 
                "isTextureAttribute"
                , isTextureAttribute_function_type(&::osg::StateAttribute::isTextureAttribute)
                , default_isTextureAttribute_function_type(&BlendFunc_wrapper::default_isTextureAttribute) );
        
        }
        { //::osg::StateAttribute::resizeGLObjectBuffers
        
            typedef void ( ::osg::StateAttribute::*resizeGLObjectBuffers_function_type )( unsigned int ) ;
            typedef void ( BlendFunc_wrapper::*default_resizeGLObjectBuffers_function_type )( unsigned int ) ;
            
            BlendFunc_exposer.def( 
                "resizeGLObjectBuffers"
                , resizeGLObjectBuffers_function_type(&::osg::StateAttribute::resizeGLObjectBuffers)
                , default_resizeGLObjectBuffers_function_type(&BlendFunc_wrapper::default_resizeGLObjectBuffers)
                , ( bp::arg("arg0") ) );
        
        }
        BlendFunc_exposer.staticmethod( "getExtensions" );
        BlendFunc_exposer.staticmethod( "setExtensions" );
    }

}
