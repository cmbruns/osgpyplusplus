// This file has been generated by Py++.

#include "boost/python.hpp"
#include "wrap_osg.h"
#include "wrap_referenced.h"
#include "Program.pypp.hpp"

namespace bp = boost::python;

struct Program_wrapper : osg::Program, bp::wrapper< osg::Program > {

    struct PerContextProgram_wrapper : osg::Program::PerContextProgram, bp::wrapper< osg::Program::PerContextProgram > {
    
        PerContextProgram_wrapper(::osg::Program const * program, unsigned int contextID, ::GLuint programHandle=0 )
        : osg::Program::PerContextProgram( boost::python::ptr(program), contextID, programHandle )
          , bp::wrapper< osg::Program::PerContextProgram >(){
            // constructor
        
        }
    
        virtual ::osg::Program::ProgramBinary * compileProgramBinary( ::osg::State & state ) {
            if( bp::override func_compileProgramBinary = this->get_override( "compileProgramBinary" ) )
                return func_compileProgramBinary( boost::ref(state) );
            else{
                return this->osg::Program::PerContextProgram::compileProgramBinary( boost::ref(state) );
            }
        }
        
        ::osg::Program::ProgramBinary * default_compileProgramBinary( ::osg::State & state ) {
            return osg::Program::PerContextProgram::compileProgramBinary( boost::ref(state) );
        }
    
        virtual bool getInfoLog( ::std::string & infoLog ) const  {
            if( bp::override func_getInfoLog = this->get_override( "getInfoLog" ) )
                return func_getInfoLog( infoLog );
            else{
                return this->osg::Program::PerContextProgram::getInfoLog( infoLog );
            }
        }
        
        bool default_getInfoLog( ::std::string & infoLog ) const  {
            return osg::Program::PerContextProgram::getInfoLog( infoLog );
        }
    
        virtual void linkProgram( ::osg::State & state ) {
            if( bp::override func_linkProgram = this->get_override( "linkProgram" ) )
                func_linkProgram( boost::ref(state) );
            else{
                this->osg::Program::PerContextProgram::linkProgram( boost::ref(state) );
            }
        }
        
        void default_linkProgram( ::osg::State & state ) {
            osg::Program::PerContextProgram::linkProgram( boost::ref(state) );
        }
    
        virtual void useProgram(  ) const  {
            if( bp::override func_useProgram = this->get_override( "useProgram" ) )
                func_useProgram(  );
            else{
                this->osg::Program::PerContextProgram::useProgram(  );
            }
        }
        
        void default_useProgram(  ) const  {
            osg::Program::PerContextProgram::useProgram( );
        }
    
        virtual bool validateProgram(  ) {
            if( bp::override func_validateProgram = this->get_override( "validateProgram" ) )
                return func_validateProgram(  );
            else{
                return this->osg::Program::PerContextProgram::validateProgram(  );
            }
        }
        
        bool default_validateProgram(  ) {
            return osg::Program::PerContextProgram::validateProgram( );
        }
    
    };

    struct ProgramBinary_wrapper : osg::Program::ProgramBinary, bp::wrapper< osg::Program::ProgramBinary > {
    
        ProgramBinary_wrapper( )
        : osg::Program::ProgramBinary( )
          , bp::wrapper< osg::Program::ProgramBinary >(){
            // null constructor
        
        }
    
        virtual char const * className(  ) const  {
            if( bp::override func_className = this->get_override( "className" ) )
                return func_className(  );
            else{
                return this->osg::Program::ProgramBinary::className(  );
            }
        }
        
        char const * default_className(  ) const  {
            return osg::Program::ProgramBinary::className( );
        }
    
        virtual ::osg::Object * clone( ::osg::CopyOp const & copyop ) const  {
            if( bp::override func_clone = this->get_override( "clone" ) )
                return func_clone( boost::ref(copyop) );
            else{
                return this->osg::Program::ProgramBinary::clone( boost::ref(copyop) );
            }
        }
        
        ::osg::Object * default_clone( ::osg::CopyOp const & copyop ) const  {
            return osg::Program::ProgramBinary::clone( boost::ref(copyop) );
        }
    
        virtual ::osg::Object * cloneType(  ) const  {
            if( bp::override func_cloneType = this->get_override( "cloneType" ) )
                return func_cloneType(  );
            else{
                return this->osg::Program::ProgramBinary::cloneType(  );
            }
        }
        
        ::osg::Object * default_cloneType(  ) const  {
            return osg::Program::ProgramBinary::cloneType( );
        }
    
        virtual bool isSameKindAs( ::osg::Object const * obj ) const  {
            if( bp::override func_isSameKindAs = this->get_override( "isSameKindAs" ) )
                return func_isSameKindAs( boost::python::ptr(obj) );
            else{
                return this->osg::Program::ProgramBinary::isSameKindAs( boost::python::ptr(obj) );
            }
        }
        
        bool default_isSameKindAs( ::osg::Object const * obj ) const  {
            return osg::Program::ProgramBinary::isSameKindAs( boost::python::ptr(obj) );
        }
    
        virtual char const * libraryName(  ) const  {
            if( bp::override func_libraryName = this->get_override( "libraryName" ) )
                return func_libraryName(  );
            else{
                return this->osg::Program::ProgramBinary::libraryName(  );
            }
        }
        
        char const * default_libraryName(  ) const  {
            return osg::Program::ProgramBinary::libraryName( );
        }
    
    };

    Program_wrapper( )
    : osg::Program( )
      , bp::wrapper< osg::Program >(){
        // null constructor
    
    }

    virtual char const * className(  ) const  {
        if( bp::override func_className = this->get_override( "className" ) )
            return func_className(  );
        else{
            return this->osg::Program::className(  );
        }
    }
    
    char const * default_className(  ) const  {
        return osg::Program::className( );
    }

    virtual ::osg::Object * clone( ::osg::CopyOp const & copyop ) const  {
        if( bp::override func_clone = this->get_override( "clone" ) )
            return func_clone( boost::ref(copyop) );
        else{
            return this->osg::Program::clone( boost::ref(copyop) );
        }
    }
    
    ::osg::Object * default_clone( ::osg::CopyOp const & copyop ) const  {
        return osg::Program::clone( boost::ref(copyop) );
    }

    virtual ::osg::Object * cloneType(  ) const  {
        if( bp::override func_cloneType = this->get_override( "cloneType" ) )
            return func_cloneType(  );
        else{
            return this->osg::Program::cloneType(  );
        }
    }
    
    ::osg::Object * default_cloneType(  ) const  {
        return osg::Program::cloneType( );
    }

    virtual void compileGLObjects( ::osg::State & state ) const  {
        if( bp::override func_compileGLObjects = this->get_override( "compileGLObjects" ) )
            func_compileGLObjects( boost::ref(state) );
        else{
            this->osg::Program::compileGLObjects( boost::ref(state) );
        }
    }
    
    void default_compileGLObjects( ::osg::State & state ) const  {
        osg::Program::compileGLObjects( boost::ref(state) );
    }

    virtual ::osg::StateAttribute::Type getType(  ) const  {
        if( bp::override func_getType = this->get_override( "getType" ) )
            return func_getType(  );
        else{
            return this->osg::Program::getType(  );
        }
    }
    
    ::osg::StateAttribute::Type default_getType(  ) const  {
        return osg::Program::getType( );
    }

    virtual bool isSameKindAs( ::osg::Object const * obj ) const  {
        if( bp::override func_isSameKindAs = this->get_override( "isSameKindAs" ) )
            return func_isSameKindAs( boost::python::ptr(obj) );
        else{
            return this->osg::Program::isSameKindAs( boost::python::ptr(obj) );
        }
    }
    
    bool default_isSameKindAs( ::osg::Object const * obj ) const  {
        return osg::Program::isSameKindAs( boost::python::ptr(obj) );
    }

    virtual char const * libraryName(  ) const  {
        if( bp::override func_libraryName = this->get_override( "libraryName" ) )
            return func_libraryName(  );
        else{
            return this->osg::Program::libraryName(  );
        }
    }
    
    char const * default_libraryName(  ) const  {
        return osg::Program::libraryName( );
    }

    virtual void resizeGLObjectBuffers( unsigned int maxSize ) {
        if( bp::override func_resizeGLObjectBuffers = this->get_override( "resizeGLObjectBuffers" ) )
            func_resizeGLObjectBuffers( maxSize );
        else{
            this->osg::Program::resizeGLObjectBuffers( maxSize );
        }
    }
    
    void default_resizeGLObjectBuffers( unsigned int maxSize ) {
        osg::Program::resizeGLObjectBuffers( maxSize );
    }

    virtual void setThreadSafeRefUnref( bool threadSafe ) {
        if( bp::override func_setThreadSafeRefUnref = this->get_override( "setThreadSafeRefUnref" ) )
            func_setThreadSafeRefUnref( threadSafe );
        else{
            this->osg::Program::setThreadSafeRefUnref( threadSafe );
        }
    }
    
    void default_setThreadSafeRefUnref( bool threadSafe ) {
        osg::Program::setThreadSafeRefUnref( threadSafe );
    }

    virtual ::osg::Texture * asTexture(  ) {
        if( bp::override func_asTexture = this->get_override( "asTexture" ) )
            return func_asTexture(  );
        else{
            return this->osg::StateAttribute::asTexture(  );
        }
    }
    
    ::osg::Texture * default_asTexture(  ) {
        return osg::StateAttribute::asTexture( );
    }

    virtual ::osg::Texture const * asTexture(  ) const  {
        if( bp::override func_asTexture = this->get_override( "asTexture" ) )
            return func_asTexture(  );
        else{
            return this->osg::StateAttribute::asTexture(  );
        }
    }
    
    ::osg::Texture const * default_asTexture(  ) const  {
        return osg::StateAttribute::asTexture( );
    }

    virtual bool checkValidityOfAssociatedModes( ::osg::State & arg0 ) const  {
        if( bp::override func_checkValidityOfAssociatedModes = this->get_override( "checkValidityOfAssociatedModes" ) )
            return func_checkValidityOfAssociatedModes( boost::ref(arg0) );
        else{
            return this->osg::StateAttribute::checkValidityOfAssociatedModes( boost::ref(arg0) );
        }
    }
    
    bool default_checkValidityOfAssociatedModes( ::osg::State & arg0 ) const  {
        return osg::StateAttribute::checkValidityOfAssociatedModes( boost::ref(arg0) );
    }

    virtual unsigned int getMember(  ) const  {
        if( bp::override func_getMember = this->get_override( "getMember" ) )
            return func_getMember(  );
        else{
            return this->osg::StateAttribute::getMember(  );
        }
    }
    
    unsigned int default_getMember(  ) const  {
        return osg::StateAttribute::getMember( );
    }

    virtual bool getModeUsage( ::osg::StateAttribute::ModeUsage & arg0 ) const  {
        if( bp::override func_getModeUsage = this->get_override( "getModeUsage" ) )
            return func_getModeUsage( boost::ref(arg0) );
        else{
            return this->osg::StateAttribute::getModeUsage( boost::ref(arg0) );
        }
    }
    
    bool default_getModeUsage( ::osg::StateAttribute::ModeUsage & arg0 ) const  {
        return osg::StateAttribute::getModeUsage( boost::ref(arg0) );
    }

    virtual bool isTextureAttribute(  ) const  {
        if( bp::override func_isTextureAttribute = this->get_override( "isTextureAttribute" ) )
            return func_isTextureAttribute(  );
        else{
            return this->osg::StateAttribute::isTextureAttribute(  );
        }
    }
    
    bool default_isTextureAttribute(  ) const  {
        return osg::StateAttribute::isTextureAttribute( );
    }

};

void register_Program_class(){

    { //::osg::Program
        typedef bp::class_< Program_wrapper, bp::bases< osg::StateAttribute >, osg::ref_ptr< ::osg::Program >, boost::noncopyable > Program_exposer_t;
        Program_exposer_t Program_exposer = Program_exposer_t( "Program", "\n osg::Program is an application-level abstraction of an OpenGL glProgram.\n It is an osg::StateAttribute that, when applied, will activate a\n glProgram for subsequent rendering.\n osg::Shaders containing the actual shader source code are\n attached to a Program, which will then manage the compilation,\n linking, and activation of the GLSL program.\n osg::Program will automatically manage per-context instancing of the\n OpenGL glPrograms, if that is necessary for a particular display\n configuration.\n", bp::no_init );
        bp::scope Program_scope( Program_exposer );
        bp::class_< osg::Program::ActiveVarInfo >( "ActiveVarInfo", bp::init< >() )    
            .def( bp::init< GLint, GLenum, GLint >(( bp::arg("loc"), bp::arg("type"), bp::arg("size") )) )    
            .def_readwrite( "_location", &osg::Program::ActiveVarInfo::_location )    
            .def_readwrite( "_size", &osg::Program::ActiveVarInfo::_size )    
            .def_readwrite( "_type", &osg::Program::ActiveVarInfo::_type );
        bp::class_< Program_wrapper::PerContextProgram_wrapper, bp::bases< osg::Referenced >, osg::ref_ptr< ::osg::Program::PerContextProgram >, boost::noncopyable >( "PerContextProgram", "\n PerContextProgram (PCP) is an OSG-internal encapsulation of glPrograms per-GL context.\n", bp::no_init )    
            .def( bp::init< osg::Program const *, unsigned int, bp::optional< GLuint > >(( bp::arg("program"), bp::arg("contextID"), bp::arg("programHandle")=(::GLuint)(0) ), "\n Use 0 as programHandle to let the PeContextProgram execute glCreateProgramand glDeleteProgram\n") )    
            .def( 
                "addShaderToAttach"
                , (void ( ::osg::Program::PerContextProgram::* )( ::osg::Shader * ) )( &::osg::Program::PerContextProgram::addShaderToAttach )
                , ( bp::arg("shader") ) )    
            .def( 
                "addShaderToDetach"
                , (void ( ::osg::Program::PerContextProgram::* )( ::osg::Shader * ) )( &::osg::Program::PerContextProgram::addShaderToDetach )
                , ( bp::arg("shader") ) )    
            .def( 
                "compileProgramBinary"
                , (::osg::Program::ProgramBinary * ( ::osg::Program::PerContextProgram::* )( ::osg::State & ) )(&::osg::Program::PerContextProgram::compileProgramBinary)
                , (::osg::Program::ProgramBinary * ( Program_wrapper::PerContextProgram_wrapper::* )( ::osg::State & ) )(&Program_wrapper::PerContextProgram_wrapper::default_compileProgramBinary)
                , ( bp::arg("state") )
                , bp::return_internal_reference< >() )    
            .def( 
                "getActiveAttribs"
                , (::std::map< std::string, osg::Program::ActiveVarInfo > const & ( ::osg::Program::PerContextProgram::* )(  ) const)( &::osg::Program::PerContextProgram::getActiveAttribs )
                , bp::return_internal_reference< >() )    
            .def( 
                "getActiveUniforms"
                , (::std::map< unsigned int, osg::Program::ActiveVarInfo > const & ( ::osg::Program::PerContextProgram::* )(  ) const)( &::osg::Program::PerContextProgram::getActiveUniforms )
                , bp::return_internal_reference< >() )    
            .def( 
                "getAttribLocation"
                , (::GLint ( ::osg::Program::PerContextProgram::* )( ::std::string const & ) const)( &::osg::Program::PerContextProgram::getAttribLocation )
                , ( bp::arg("name") ) )    
            .def( 
                "getHandle"
                , (::GLuint ( ::osg::Program::PerContextProgram::* )(  ) const)( &::osg::Program::PerContextProgram::getHandle ) )    
            .def( 
                "getInfoLog"
                , (bool ( ::osg::Program::PerContextProgram::* )( ::std::string & ) const)(&::osg::Program::PerContextProgram::getInfoLog)
                , (bool ( Program_wrapper::PerContextProgram_wrapper::* )( ::std::string & ) const)(&Program_wrapper::PerContextProgram_wrapper::default_getInfoLog)
                , ( bp::arg("infoLog") ) )    
            .def( 
                "getUniformBlocks"
                , (::std::map< std::string, osg::Program::UniformBlockInfo > const & ( ::osg::Program::PerContextProgram::* )(  ) const)( &::osg::Program::PerContextProgram::getUniformBlocks )
                , bp::return_internal_reference< >() )    
            .def( 
                "getUniformLocation"
                , (::GLint ( ::osg::Program::PerContextProgram::* )( unsigned int ) const)( &::osg::Program::PerContextProgram::getUniformLocation )
                , ( bp::arg("uniformNameID") ) )    
            .def( 
                "getUniformLocation"
                , (::GLint ( ::osg::Program::PerContextProgram::* )( ::std::string const & ) const)( &::osg::Program::PerContextProgram::getUniformLocation )
                , ( bp::arg("uniformName") )
                , " Alternative version of getUniformLocation( unsigned int uniformNameID )\n retrofited into OSG for backward compatibility with osgCal,\n after uniform ids were refactored from std::strings to GLints in OSG version 2.9.10.\n\n Drawbacks: This method is not particularly fast. It has to access mutexed static\n map of uniform ids. So dont overuse it or your app performance will suffer." )    
            .def( 
                "isLinked"
                , (bool ( ::osg::Program::PerContextProgram::* )(  ) const)( &::osg::Program::PerContextProgram::isLinked ) )    
            .def( 
                "linkProgram"
                , (void ( ::osg::Program::PerContextProgram::* )( ::osg::State & ) )(&::osg::Program::PerContextProgram::linkProgram)
                , (void ( Program_wrapper::PerContextProgram_wrapper::* )( ::osg::State & ) )(&Program_wrapper::PerContextProgram_wrapper::default_linkProgram)
                , ( bp::arg("state") ) )    
            .def( 
                "loadedBinary"
                , (bool ( ::osg::Program::PerContextProgram::* )(  ) const)( &::osg::Program::PerContextProgram::loadedBinary )
                , " Was glProgramBinary called successfully?" )    
            .def( 
                "needsLink"
                , (bool ( ::osg::Program::PerContextProgram::* )(  ) const)( &::osg::Program::PerContextProgram::needsLink ) )    
            .def( 
                "requestLink"
                , (void ( ::osg::Program::PerContextProgram::* )(  ) )( &::osg::Program::PerContextProgram::requestLink ) )    
            .def( 
                "resetAppliedUniforms"
                , (void ( ::osg::Program::PerContextProgram::* )(  ) const)( &::osg::Program::PerContextProgram::resetAppliedUniforms ) )    
            .def( 
                "useProgram"
                , (void ( ::osg::Program::PerContextProgram::* )(  ) const)(&::osg::Program::PerContextProgram::useProgram)
                , (void ( Program_wrapper::PerContextProgram_wrapper::* )(  ) const)(&Program_wrapper::PerContextProgram_wrapper::default_useProgram) )    
            .def( 
                "validateProgram"
                , (bool ( ::osg::Program::PerContextProgram::* )(  ) )(&::osg::Program::PerContextProgram::validateProgram)
                , (bool ( Program_wrapper::PerContextProgram_wrapper::* )(  ) )(&Program_wrapper::PerContextProgram_wrapper::default_validateProgram) );
        bp::class_< Program_wrapper::ProgramBinary_wrapper, bp::bases< osg::Object >, osg::ref_ptr< ::osg::Program::ProgramBinary >, boost::noncopyable >( "ProgramBinary", "\n Simple class for wrapping up the data used in glProgramBinary and glGetProgramBinary.\n On the first run of your application Programs should be assigned an empty ProgramBinary.\n Before your application exits it should retrieve the program binary via\n Program::PerContextProgram::compileProgramBinary and save it to disk.\n When your application is run subsequently, load your binary from disk and use it to set\n the data of a ProgramBinary, and set the ProgramBinary on the associated Program.\n This will typically result in Program::compileGLObjects executing much faster.\n", bp::init< >("\n Simple class for wrapping up the data used in glProgramBinary and glGetProgramBinary.\n On the first run of your application Programs should be assigned an empty ProgramBinary.\n Before your application exits it should retrieve the program binary via\n Program::PerContextProgram::compileProgramBinary and save it to disk.\n When your application is run subsequently, load your binary from disk and use it to set\n the data of a ProgramBinary, and set the ProgramBinary on the associated Program.\n This will typically result in Program::compileGLObjects executing much faster.\n") )    
            .def( 
                "allocate"
                , (void ( ::osg::Program::ProgramBinary::* )( unsigned int ) )( &::osg::Program::ProgramBinary::allocate )
                , ( bp::arg("size") )
                , " Allocated a data buffer of specified size" )    
            .def( 
                "assign"
                , (void ( ::osg::Program::ProgramBinary::* )( unsigned int,unsigned char const * ) )( &::osg::Program::ProgramBinary::assign )
                , ( bp::arg("size"), bp::arg("data") )
                , " Assign program binary data, copying the specified data into locally stored data buffer, the original data can then be deleted." )    
            .def( 
                "className"
                , (char const * ( ::osg::Program::ProgramBinary::* )(  ) const)(&::osg::Program::ProgramBinary::className)
                , (char const * ( Program_wrapper::ProgramBinary_wrapper::* )(  ) const)(&Program_wrapper::ProgramBinary_wrapper::default_className) )    
            .def( 
                "clone"
                , (::osg::Object * ( ::osg::Program::ProgramBinary::* )( ::osg::CopyOp const & ) const)(&::osg::Program::ProgramBinary::clone)
                , (::osg::Object * ( Program_wrapper::ProgramBinary_wrapper::* )( ::osg::CopyOp const & ) const)(&Program_wrapper::ProgramBinary_wrapper::default_clone)
                , ( bp::arg("copyop") )
                , bp::return_value_policy< bp::reference_existing_object >() )    
            .def( 
                "cloneType"
                , (::osg::Object * ( ::osg::Program::ProgramBinary::* )(  ) const)(&::osg::Program::ProgramBinary::cloneType)
                , (::osg::Object * ( Program_wrapper::ProgramBinary_wrapper::* )(  ) const)(&Program_wrapper::ProgramBinary_wrapper::default_cloneType)
                , bp::return_value_policy< bp::reference_existing_object >() )    
            .def( 
                "getFormat"
                , (::GLenum ( ::osg::Program::ProgramBinary::* )(  ) const)( &::osg::Program::ProgramBinary::getFormat )
                , " Get the format of the program binary data." )    
            .def( 
                "getSize"
                , (unsigned int ( ::osg::Program::ProgramBinary::* )(  ) const)( &::osg::Program::ProgramBinary::getSize )
                , " Get the size of the program binary data." )    
            .def( 
                "isSameKindAs"
                , (bool ( ::osg::Program::ProgramBinary::* )( ::osg::Object const * ) const)(&::osg::Program::ProgramBinary::isSameKindAs)
                , (bool ( Program_wrapper::ProgramBinary_wrapper::* )( ::osg::Object const * ) const)(&Program_wrapper::ProgramBinary_wrapper::default_isSameKindAs)
                , ( bp::arg("obj") ) )    
            .def( 
                "libraryName"
                , (char const * ( ::osg::Program::ProgramBinary::* )(  ) const)(&::osg::Program::ProgramBinary::libraryName)
                , (char const * ( Program_wrapper::ProgramBinary_wrapper::* )(  ) const)(&Program_wrapper::ProgramBinary_wrapper::default_libraryName) )    
            .def( 
                "setFormat"
                , (void ( ::osg::Program::ProgramBinary::* )( ::GLenum ) )( &::osg::Program::ProgramBinary::setFormat )
                , ( bp::arg("format") )
                , " Set the format of the program binary data." );
        bp::class_< osg::Program::UniformBlockInfo >( "UniformBlockInfo", bp::init< >() )    
            .def( bp::init< GLuint, GLsizei >(( bp::arg("index"), bp::arg("size") )) )    
            .def_readwrite( "_index", &osg::Program::UniformBlockInfo::_index )    
            .def_readwrite( "_size", &osg::Program::UniformBlockInfo::_size );
        Program_exposer.def( bp::init< >("\n osg::Program is an application-level abstraction of an OpenGL glProgram.\n It is an osg::StateAttribute that, when applied, will activate a\n glProgram for subsequent rendering.\n osg::Shaders containing the actual shader source code are\n attached to a Program, which will then manage the compilation,\n linking, and activation of the GLSL program.\n osg::Program will automatically manage per-context instancing of the\n OpenGL glPrograms, if that is necessary for a particular display\n configuration.\n") );
        { //::osg::Program::addBindAttribLocation
        
            typedef void ( ::osg::Program::*addBindAttribLocation_function_type )( ::std::string const &,::GLuint ) ;
            
            Program_exposer.def( 
                "addBindAttribLocation"
                , addBindAttribLocation_function_type( &::osg::Program::addBindAttribLocation )
                , ( bp::arg("name"), bp::arg("index") )
                , " Add an attribute location binding." );
        
        }
        { //::osg::Program::addBindFragDataLocation
        
            typedef void ( ::osg::Program::*addBindFragDataLocation_function_type )( ::std::string const &,::GLuint ) ;
            
            Program_exposer.def( 
                "addBindFragDataLocation"
                , addBindFragDataLocation_function_type( &::osg::Program::addBindFragDataLocation )
                , ( bp::arg("name"), bp::arg("index") )
                , " Add an frag data location binding. See EXT_gpu_shader4 for BindFragDataLocationEXT" );
        
        }
        { //::osg::Program::addBindUniformBlock
        
            typedef void ( ::osg::Program::*addBindUniformBlock_function_type )( ::std::string const &,::GLuint ) ;
            
            Program_exposer.def( 
                "addBindUniformBlock"
                , addBindUniformBlock_function_type( &::osg::Program::addBindUniformBlock )
                , ( bp::arg("name"), bp::arg("index") )
                , " Add a uniform block binding to an index target. XXX This\n should not be an attribute of the program. It should be a\n pseudo-uniform that can live in StateSet objects because\n it is cheap to set." );
        
        }
        { //::osg::Program::addShader
        
            typedef bool ( ::osg::Program::*addShader_function_type )( ::osg::Shader * ) ;
            
            Program_exposer.def( 
                "addShader"
                , addShader_function_type( &::osg::Program::addShader )
                , ( bp::arg("shader") )
                , " Attach an osg::Shader to this osg::Program.\n Mark Program as needing relink.  Return true for success" );
        
        }
        { //::osg::Program::className
        
            typedef char const * ( ::osg::Program::*className_function_type )(  ) const;
            typedef char const * ( Program_wrapper::*default_className_function_type )(  ) const;
            
            Program_exposer.def( 
                "className"
                , className_function_type(&::osg::Program::className)
                , default_className_function_type(&Program_wrapper::default_className) );
        
        }
        { //::osg::Program::clone
        
            typedef ::osg::Object * ( ::osg::Program::*clone_function_type )( ::osg::CopyOp const & ) const;
            typedef ::osg::Object * ( Program_wrapper::*default_clone_function_type )( ::osg::CopyOp const & ) const;
            
            Program_exposer.def( 
                "clone"
                , clone_function_type(&::osg::Program::clone)
                , default_clone_function_type(&Program_wrapper::default_clone)
                , ( bp::arg("copyop") )
                , bp::return_value_policy< bp::reference_existing_object >() );
        
        }
        { //::osg::Program::cloneType
        
            typedef ::osg::Object * ( ::osg::Program::*cloneType_function_type )(  ) const;
            typedef ::osg::Object * ( Program_wrapper::*default_cloneType_function_type )(  ) const;
            
            Program_exposer.def( 
                "cloneType"
                , cloneType_function_type(&::osg::Program::cloneType)
                , default_cloneType_function_type(&Program_wrapper::default_cloneType)
                , bp::return_value_policy< bp::reference_existing_object >() );
        
        }
        { //::osg::Program::compileGLObjects
        
            typedef void ( ::osg::Program::*compileGLObjects_function_type )( ::osg::State & ) const;
            typedef void ( Program_wrapper::*default_compileGLObjects_function_type )( ::osg::State & ) const;
            
            Program_exposer.def( 
                "compileGLObjects"
                , compileGLObjects_function_type(&::osg::Program::compileGLObjects)
                , default_compileGLObjects_function_type(&Program_wrapper::default_compileGLObjects)
                , ( bp::arg("state") ) );
        
        }
        { //::osg::Program::deleteGlProgram
        
            typedef void ( *deleteGlProgram_function_type )( unsigned int,::GLuint );
            
            Program_exposer.def( 
                "deleteGlProgram"
                , deleteGlProgram_function_type( &::osg::Program::deleteGlProgram )
                , ( bp::arg("contextID"), bp::arg("program") )
                , " Mark internal glProgram for deletion.\n Deletion requests are queued until they can be executed\n in the proper GL context." );
        
        }
        { //::osg::Program::dirtyProgram
        
            typedef void ( ::osg::Program::*dirtyProgram_function_type )(  ) ;
            
            Program_exposer.def( 
                "dirtyProgram"
                , dirtyProgram_function_type( &::osg::Program::dirtyProgram )
                , " Mark our PCSOs as needing relink" );
        
        }
        { //::osg::Program::discardDeletedGlPrograms
        
            typedef void ( *discardDeletedGlPrograms_function_type )( unsigned int );
            
            Program_exposer.def( 
                "discardDeletedGlPrograms"
                , discardDeletedGlPrograms_function_type( &::osg::Program::discardDeletedGlPrograms )
                , ( bp::arg("contextID") )
                , " discard all the cached glPrograms which need to be deleted\n in the OpenGL context related to contextID.\n Note, unlike flush no OpenGL calls are made, instead the handles are all removed.\n this call is useful for when an OpenGL context has been destroyed." );
        
        }
        { //::osg::Program::flushDeletedGlPrograms
        
            typedef void ( *flushDeletedGlPrograms_function_type )( unsigned int,double,double & );
            
            Program_exposer.def( 
                "flushDeletedGlPrograms"
                , flushDeletedGlPrograms_function_type( &::osg::Program::flushDeletedGlPrograms )
                , ( bp::arg("contextID"), bp::arg("currentTime"), bp::arg("availableTime") )
                , " flush all the cached glPrograms which need to be deleted\n in the OpenGL context related to contextID." );
        
        }
        { //::osg::Program::getActiveAttribs
        
            typedef ::std::map< std::string, osg::Program::ActiveVarInfo > const & ( ::osg::Program::*getActiveAttribs_function_type )( unsigned int ) const;
            
            Program_exposer.def( 
                "getActiveAttribs"
                , getActiveAttribs_function_type( &::osg::Program::getActiveAttribs )
                , ( bp::arg("contextID") )
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::Program::getActiveUniforms
        
            typedef ::std::map< unsigned int, osg::Program::ActiveVarInfo > const & ( ::osg::Program::*getActiveUniforms_function_type )( unsigned int ) const;
            
            Program_exposer.def( 
                "getActiveUniforms"
                , getActiveUniforms_function_type( &::osg::Program::getActiveUniforms )
                , ( bp::arg("contextID") )
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::Program::getAttribBindingList
        
            typedef ::std::map< std::string, unsigned int > const & ( ::osg::Program::*getAttribBindingList_function_type )(  ) const;
            
            Program_exposer.def( 
                "getAttribBindingList"
                , getAttribBindingList_function_type( &::osg::Program::getAttribBindingList )
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::Program::getComputeGroups
        
            typedef void ( ::osg::Program::*getComputeGroups_function_type )( ::GLint &,::GLint &,::GLint & ) const;
            
            Program_exposer.def( 
                "getComputeGroups"
                , getComputeGroups_function_type( &::osg::Program::getComputeGroups )
                , ( bp::arg("numGroupsX"), bp::arg("numGroupsY"), bp::arg("numGroupsZ") ) );
        
        }
        { //::osg::Program::getFragDataBindingList
        
            typedef ::std::map< std::string, unsigned int > const & ( ::osg::Program::*getFragDataBindingList_function_type )(  ) const;
            
            Program_exposer.def( 
                "getFragDataBindingList"
                , getFragDataBindingList_function_type( &::osg::Program::getFragDataBindingList )
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::Program::getGlProgramInfoLog
        
            typedef bool ( ::osg::Program::*getGlProgramInfoLog_function_type )( unsigned int,::std::string & ) const;
            
            Program_exposer.def( 
                "getGlProgramInfoLog"
                , getGlProgramInfoLog_function_type( &::osg::Program::getGlProgramInfoLog )
                , ( bp::arg("contextID"), bp::arg("log") )
                , " Query InfoLog from a glProgram" );
        
        }
        { //::osg::Program::getNumShaders
        
            typedef unsigned int ( ::osg::Program::*getNumShaders_function_type )(  ) const;
            
            Program_exposer.def( 
                "getNumShaders"
                , getNumShaders_function_type( &::osg::Program::getNumShaders ) );
        
        }
        { //::osg::Program::getPCP
        
            typedef ::osg::Program::PerContextProgram * ( ::osg::Program::*getPCP_function_type )( unsigned int ) const;
            
            Program_exposer.def( 
                "getPCP"
                , getPCP_function_type( &::osg::Program::getPCP )
                , ( bp::arg("contextID") )
                , bp::return_internal_reference< >()
                , " Get the PCP for a particular GL context" );
        
        }
        { //::osg::Program::getParameter
        
            typedef ::GLint ( ::osg::Program::*getParameter_function_type )( ::GLenum ) const;
            
            Program_exposer.def( 
                "getParameter"
                , getParameter_function_type( &::osg::Program::getParameter )
                , ( bp::arg("pname") ) );
        
        }
        { //::osg::Program::getProgramBinary
        
            typedef ::osg::Program::ProgramBinary * ( ::osg::Program::*getProgramBinary_function_type )(  ) ;
            
            Program_exposer.def( 
                "getProgramBinary"
                , getProgramBinary_function_type( &::osg::Program::getProgramBinary )
                , bp::return_internal_reference< >()
                , " Get the Programs ProgramBinary, return NULL if none is assigned." );
        
        }
        { //::osg::Program::getProgramBinary
        
            typedef ::osg::Program::ProgramBinary const * ( ::osg::Program::*getProgramBinary_function_type )(  ) const;
            
            Program_exposer.def( 
                "getProgramBinary"
                , getProgramBinary_function_type( &::osg::Program::getProgramBinary )
                , bp::return_internal_reference< >()
                , " Get the const Programs ProgramBinary, return NULL if none is assigned." );
        
        }
        { //::osg::Program::getShader
        
            typedef ::osg::Shader * ( ::osg::Program::*getShader_function_type )( unsigned int ) ;
            
            Program_exposer.def( 
                "getShader"
                , getShader_function_type( &::osg::Program::getShader )
                , ( bp::arg("i") )
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::Program::getShader
        
            typedef ::osg::Shader const * ( ::osg::Program::*getShader_function_type )( unsigned int ) const;
            
            Program_exposer.def( 
                "getShader"
                , getShader_function_type( &::osg::Program::getShader )
                , ( bp::arg("i") )
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::Program::getType
        
            typedef ::osg::StateAttribute::Type ( ::osg::Program::*getType_function_type )(  ) const;
            typedef ::osg::StateAttribute::Type ( Program_wrapper::*default_getType_function_type )(  ) const;
            
            Program_exposer.def( 
                "getType"
                , getType_function_type(&::osg::Program::getType)
                , default_getType_function_type(&Program_wrapper::default_getType) );
        
        }
        { //::osg::Program::getUniformBlockBindingList
        
            typedef ::std::map< std::string, unsigned int > const & ( ::osg::Program::*getUniformBlockBindingList_function_type )(  ) const;
            
            Program_exposer.def( 
                "getUniformBlockBindingList"
                , getUniformBlockBindingList_function_type( &::osg::Program::getUniformBlockBindingList )
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::Program::getUniformBlocks
        
            typedef ::std::map< std::string, osg::Program::UniformBlockInfo > const & ( ::osg::Program::*getUniformBlocks_function_type )( unsigned int ) const;
            
            Program_exposer.def( 
                "getUniformBlocks"
                , getUniformBlocks_function_type( &::osg::Program::getUniformBlocks )
                , ( bp::arg("contextID") )
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::Program::isFixedFunction
        
            typedef bool ( ::osg::Program::*isFixedFunction_function_type )(  ) const;
            
            Program_exposer.def( 
                "isFixedFunction"
                , isFixedFunction_function_type( &::osg::Program::isFixedFunction )
                , " Return true if this Program represents fixed-functionality rendering" );
        
        }
        { //::osg::Program::isSameKindAs
        
            typedef bool ( ::osg::Program::*isSameKindAs_function_type )( ::osg::Object const * ) const;
            typedef bool ( Program_wrapper::*default_isSameKindAs_function_type )( ::osg::Object const * ) const;
            
            Program_exposer.def( 
                "isSameKindAs"
                , isSameKindAs_function_type(&::osg::Program::isSameKindAs)
                , default_isSameKindAs_function_type(&Program_wrapper::default_isSameKindAs)
                , ( bp::arg("obj") ) );
        
        }
        { //::osg::Program::libraryName
        
            typedef char const * ( ::osg::Program::*libraryName_function_type )(  ) const;
            typedef char const * ( Program_wrapper::*default_libraryName_function_type )(  ) const;
            
            Program_exposer.def( 
                "libraryName"
                , libraryName_function_type(&::osg::Program::libraryName)
                , default_libraryName_function_type(&Program_wrapper::default_libraryName) );
        
        }
        { //::osg::Program::removeBindAttribLocation
        
            typedef void ( ::osg::Program::*removeBindAttribLocation_function_type )( ::std::string const & ) ;
            
            Program_exposer.def( 
                "removeBindAttribLocation"
                , removeBindAttribLocation_function_type( &::osg::Program::removeBindAttribLocation )
                , ( bp::arg("name") )
                , " Remove an attribute location binding." );
        
        }
        { //::osg::Program::removeBindFragDataLocation
        
            typedef void ( ::osg::Program::*removeBindFragDataLocation_function_type )( ::std::string const & ) ;
            
            Program_exposer.def( 
                "removeBindFragDataLocation"
                , removeBindFragDataLocation_function_type( &::osg::Program::removeBindFragDataLocation )
                , ( bp::arg("name") )
                , " Remove an frag data location binding." );
        
        }
        { //::osg::Program::removeBindUniformBlock
        
            typedef void ( ::osg::Program::*removeBindUniformBlock_function_type )( ::std::string const & ) ;
            
            Program_exposer.def( 
                "removeBindUniformBlock"
                , removeBindUniformBlock_function_type( &::osg::Program::removeBindUniformBlock )
                , ( bp::arg("name") )
                , " Remove a uniform block binding." );
        
        }
        { //::osg::Program::removeShader
        
            typedef bool ( ::osg::Program::*removeShader_function_type )( ::osg::Shader * ) ;
            
            Program_exposer.def( 
                "removeShader"
                , removeShader_function_type( &::osg::Program::removeShader )
                , ( bp::arg("shader") )
                , " Remove osg::Shader from this osg::Program.\n Mark Program as needing relink.  Return true for success" );
        
        }
        { //::osg::Program::resizeGLObjectBuffers
        
            typedef void ( ::osg::Program::*resizeGLObjectBuffers_function_type )( unsigned int ) ;
            typedef void ( Program_wrapper::*default_resizeGLObjectBuffers_function_type )( unsigned int ) ;
            
            Program_exposer.def( 
                "resizeGLObjectBuffers"
                , resizeGLObjectBuffers_function_type(&::osg::Program::resizeGLObjectBuffers)
                , default_resizeGLObjectBuffers_function_type(&Program_wrapper::default_resizeGLObjectBuffers)
                , ( bp::arg("maxSize") ) );
        
        }
        { //::osg::Program::setComputeGroups
        
            typedef void ( ::osg::Program::*setComputeGroups_function_type )( ::GLint,::GLint,::GLint ) ;
            
            Program_exposer.def( 
                "setComputeGroups"
                , setComputeGroups_function_type( &::osg::Program::setComputeGroups )
                , ( bp::arg("numGroupsX"), bp::arg("numGroupsY"), bp::arg("numGroupsZ") )
                , " Set/get compute shader work groups" );
        
        }
        { //::osg::Program::setParameter
        
            typedef void ( ::osg::Program::*setParameter_function_type )( ::GLenum,::GLint ) ;
            
            Program_exposer.def( 
                "setParameter"
                , setParameter_function_type( &::osg::Program::setParameter )
                , ( bp::arg("pname"), bp::arg("value") )
                , " Set/get GL program parameters" );
        
        }
        { //::osg::Program::setProgramBinary
        
            typedef void ( ::osg::Program::*setProgramBinary_function_type )( ::osg::Program::ProgramBinary * ) ;
            
            Program_exposer.def( 
                "setProgramBinary"
                , setProgramBinary_function_type( &::osg::Program::setProgramBinary )
                , ( bp::arg("programBinary") )
                , " Set the Program using a ProgramBinary. If a ProgramBinary is not yet\n available then setting an empty one signals that compileProgramBinary\n will be called later." );
        
        }
        { //::osg::Program::setThreadSafeRefUnref
        
            typedef void ( ::osg::Program::*setThreadSafeRefUnref_function_type )( bool ) ;
            typedef void ( Program_wrapper::*default_setThreadSafeRefUnref_function_type )( bool ) ;
            
            Program_exposer.def( 
                "setThreadSafeRefUnref"
                , setThreadSafeRefUnref_function_type(&::osg::Program::setThreadSafeRefUnref)
                , default_setThreadSafeRefUnref_function_type(&Program_wrapper::default_setThreadSafeRefUnref)
                , ( bp::arg("threadSafe") ) );
        
        }
        { //::osg::StateAttribute::asTexture
        
            typedef ::osg::Texture * ( ::osg::StateAttribute::*asTexture_function_type )(  ) ;
            typedef ::osg::Texture * ( Program_wrapper::*default_asTexture_function_type )(  ) ;
            
            Program_exposer.def( 
                "asTexture"
                , asTexture_function_type(&::osg::StateAttribute::asTexture)
                , default_asTexture_function_type(&Program_wrapper::default_asTexture)
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::StateAttribute::asTexture
        
            typedef ::osg::Texture const * ( ::osg::StateAttribute::*asTexture_function_type )(  ) const;
            typedef ::osg::Texture const * ( Program_wrapper::*default_asTexture_function_type )(  ) const;
            
            Program_exposer.def( 
                "asTexture"
                , asTexture_function_type(&::osg::StateAttribute::asTexture)
                , default_asTexture_function_type(&Program_wrapper::default_asTexture)
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::StateAttribute::checkValidityOfAssociatedModes
        
            typedef bool ( ::osg::StateAttribute::*checkValidityOfAssociatedModes_function_type )( ::osg::State & ) const;
            typedef bool ( Program_wrapper::*default_checkValidityOfAssociatedModes_function_type )( ::osg::State & ) const;
            
            Program_exposer.def( 
                "checkValidityOfAssociatedModes"
                , checkValidityOfAssociatedModes_function_type(&::osg::StateAttribute::checkValidityOfAssociatedModes)
                , default_checkValidityOfAssociatedModes_function_type(&Program_wrapper::default_checkValidityOfAssociatedModes)
                , ( bp::arg("arg0") ) );
        
        }
        { //::osg::StateAttribute::getMember
        
            typedef unsigned int ( ::osg::StateAttribute::*getMember_function_type )(  ) const;
            typedef unsigned int ( Program_wrapper::*default_getMember_function_type )(  ) const;
            
            Program_exposer.def( 
                "getMember"
                , getMember_function_type(&::osg::StateAttribute::getMember)
                , default_getMember_function_type(&Program_wrapper::default_getMember) );
        
        }
        { //::osg::StateAttribute::getModeUsage
        
            typedef bool ( ::osg::StateAttribute::*getModeUsage_function_type )( ::osg::StateAttribute::ModeUsage & ) const;
            typedef bool ( Program_wrapper::*default_getModeUsage_function_type )( ::osg::StateAttribute::ModeUsage & ) const;
            
            Program_exposer.def( 
                "getModeUsage"
                , getModeUsage_function_type(&::osg::StateAttribute::getModeUsage)
                , default_getModeUsage_function_type(&Program_wrapper::default_getModeUsage)
                , ( bp::arg("arg0") ) );
        
        }
        { //::osg::StateAttribute::isTextureAttribute
        
            typedef bool ( ::osg::StateAttribute::*isTextureAttribute_function_type )(  ) const;
            typedef bool ( Program_wrapper::*default_isTextureAttribute_function_type )(  ) const;
            
            Program_exposer.def( 
                "isTextureAttribute"
                , isTextureAttribute_function_type(&::osg::StateAttribute::isTextureAttribute)
                , default_isTextureAttribute_function_type(&Program_wrapper::default_isTextureAttribute) );
        
        }
        Program_exposer.staticmethod( "deleteGlProgram" );
        Program_exposer.staticmethod( "discardDeletedGlPrograms" );
        Program_exposer.staticmethod( "flushDeletedGlPrograms" );
    }

}
