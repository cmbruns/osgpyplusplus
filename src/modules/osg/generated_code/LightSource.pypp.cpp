// This file has been generated by Py++.

#include "boost/python.hpp"
#include "wrap_osg.h"
#include "wrap_referenced.h"
#include "LightSource.pypp.hpp"

namespace bp = boost::python;

struct LightSource_wrapper : osg::LightSource, bp::wrapper< osg::LightSource > {

    LightSource_wrapper( )
    : osg::LightSource( )
      , bp::wrapper< osg::LightSource >(){
        // null constructor
    
    }

    virtual void accept( ::osg::NodeVisitor & nv ) {
        if( bp::override func_accept = this->get_override( "accept" ) )
            func_accept( boost::ref(nv) );
        else{
            this->osg::LightSource::accept( boost::ref(nv) );
        }
    }
    
    void default_accept( ::osg::NodeVisitor & nv ) {
        osg::LightSource::accept( boost::ref(nv) );
    }

    virtual char const * className(  ) const  {
        if( bp::override func_className = this->get_override( "className" ) )
            return func_className(  );
        else{
            return this->osg::LightSource::className(  );
        }
    }
    
    char const * default_className(  ) const  {
        return osg::LightSource::className( );
    }

    virtual ::osg::Object * clone( ::osg::CopyOp const & copyop ) const  {
        if( bp::override func_clone = this->get_override( "clone" ) )
            return func_clone( boost::ref(copyop) );
        else{
            return this->osg::LightSource::clone( boost::ref(copyop) );
        }
    }
    
    ::osg::Object * default_clone( ::osg::CopyOp const & copyop ) const  {
        return osg::LightSource::clone( boost::ref(copyop) );
    }

    virtual ::osg::Object * cloneType(  ) const  {
        if( bp::override func_cloneType = this->get_override( "cloneType" ) )
            return func_cloneType(  );
        else{
            return this->osg::LightSource::cloneType(  );
        }
    }
    
    ::osg::Object * default_cloneType(  ) const  {
        return osg::LightSource::cloneType( );
    }

    virtual ::osg::BoundingSphere computeBound(  ) const  {
        if( bp::override func_computeBound = this->get_override( "computeBound" ) )
            return func_computeBound(  );
        else{
            return this->osg::LightSource::computeBound(  );
        }
    }
    
    ::osg::BoundingSphere default_computeBound(  ) const  {
        return osg::LightSource::computeBound( );
    }

    virtual bool isSameKindAs( ::osg::Object const * obj ) const  {
        if( bp::override func_isSameKindAs = this->get_override( "isSameKindAs" ) )
            return func_isSameKindAs( boost::python::ptr(obj) );
        else{
            return this->osg::LightSource::isSameKindAs( boost::python::ptr(obj) );
        }
    }
    
    bool default_isSameKindAs( ::osg::Object const * obj ) const  {
        return osg::LightSource::isSameKindAs( boost::python::ptr(obj) );
    }

    virtual char const * libraryName(  ) const  {
        if( bp::override func_libraryName = this->get_override( "libraryName" ) )
            return func_libraryName(  );
        else{
            return this->osg::LightSource::libraryName(  );
        }
    }
    
    char const * default_libraryName(  ) const  {
        return osg::LightSource::libraryName( );
    }

    virtual void setThreadSafeRefUnref( bool threadSafe ) {
        if( bp::override func_setThreadSafeRefUnref = this->get_override( "setThreadSafeRefUnref" ) )
            func_setThreadSafeRefUnref( threadSafe );
        else{
            this->osg::LightSource::setThreadSafeRefUnref( threadSafe );
        }
    }
    
    void default_setThreadSafeRefUnref( bool threadSafe ) {
        osg::LightSource::setThreadSafeRefUnref( threadSafe );
    }

    virtual bool addChild( ::osg::Node * child ) {
        if( bp::override func_addChild = this->get_override( "addChild" ) )
            return func_addChild( boost::python::ptr(child) );
        else{
            return this->osg::Group::addChild( boost::python::ptr(child) );
        }
    }
    
    bool default_addChild( ::osg::Node * child ) {
        return osg::Group::addChild( boost::python::ptr(child) );
    }

    virtual ::osg::Camera * asCamera(  ) {
        if( bp::override func_asCamera = this->get_override( "asCamera" ) )
            return func_asCamera(  );
        else{
            return this->osg::Node::asCamera(  );
        }
    }
    
    ::osg::Camera * default_asCamera(  ) {
        return osg::Node::asCamera( );
    }

    virtual ::osg::Camera const * asCamera(  ) const  {
        if( bp::override func_asCamera = this->get_override( "asCamera" ) )
            return func_asCamera(  );
        else{
            return this->osg::Node::asCamera(  );
        }
    }
    
    ::osg::Camera const * default_asCamera(  ) const  {
        return osg::Node::asCamera( );
    }

    virtual ::osg::Geode * asGeode(  ) {
        if( bp::override func_asGeode = this->get_override( "asGeode" ) )
            return func_asGeode(  );
        else{
            return this->osg::Node::asGeode(  );
        }
    }
    
    ::osg::Geode * default_asGeode(  ) {
        return osg::Node::asGeode( );
    }

    virtual ::osg::Geode const * asGeode(  ) const  {
        if( bp::override func_asGeode = this->get_override( "asGeode" ) )
            return func_asGeode(  );
        else{
            return this->osg::Node::asGeode(  );
        }
    }
    
    ::osg::Geode const * default_asGeode(  ) const  {
        return osg::Node::asGeode( );
    }

    virtual ::osg::Group * asGroup(  ) {
        if( bp::override func_asGroup = this->get_override( "asGroup" ) )
            return func_asGroup(  );
        else{
            return this->osg::Group::asGroup(  );
        }
    }
    
    ::osg::Group * default_asGroup(  ) {
        return osg::Group::asGroup( );
    }

    virtual ::osg::Group const * asGroup(  ) const  {
        if( bp::override func_asGroup = this->get_override( "asGroup" ) )
            return func_asGroup(  );
        else{
            return this->osg::Group::asGroup(  );
        }
    }
    
    ::osg::Group const * default_asGroup(  ) const  {
        return osg::Group::asGroup( );
    }

    virtual ::osg::Switch * asSwitch(  ) {
        if( bp::override func_asSwitch = this->get_override( "asSwitch" ) )
            return func_asSwitch(  );
        else{
            return this->osg::Node::asSwitch(  );
        }
    }
    
    ::osg::Switch * default_asSwitch(  ) {
        return osg::Node::asSwitch( );
    }

    virtual ::osg::Switch const * asSwitch(  ) const  {
        if( bp::override func_asSwitch = this->get_override( "asSwitch" ) )
            return func_asSwitch(  );
        else{
            return this->osg::Node::asSwitch(  );
        }
    }
    
    ::osg::Switch const * default_asSwitch(  ) const  {
        return osg::Node::asSwitch( );
    }

    virtual ::osg::Transform * asTransform(  ) {
        if( bp::override func_asTransform = this->get_override( "asTransform" ) )
            return func_asTransform(  );
        else{
            return this->osg::Node::asTransform(  );
        }
    }
    
    ::osg::Transform * default_asTransform(  ) {
        return osg::Node::asTransform( );
    }

    virtual ::osg::Transform const * asTransform(  ) const  {
        if( bp::override func_asTransform = this->get_override( "asTransform" ) )
            return func_asTransform(  );
        else{
            return this->osg::Node::asTransform(  );
        }
    }
    
    ::osg::Transform const * default_asTransform(  ) const  {
        return osg::Node::asTransform( );
    }

    virtual void ascend( ::osg::NodeVisitor & nv ) {
        if( bp::override func_ascend = this->get_override( "ascend" ) )
            func_ascend( boost::ref(nv) );
        else{
            this->osg::Node::ascend( boost::ref(nv) );
        }
    }
    
    void default_ascend( ::osg::NodeVisitor & nv ) {
        osg::Node::ascend( boost::ref(nv) );
    }

    virtual bool insertChild( unsigned int index, ::osg::Node * child ) {
        if( bp::override func_insertChild = this->get_override( "insertChild" ) )
            return func_insertChild( index, boost::python::ptr(child) );
        else{
            return this->osg::Group::insertChild( index, boost::python::ptr(child) );
        }
    }
    
    bool default_insertChild( unsigned int index, ::osg::Node * child ) {
        return osg::Group::insertChild( index, boost::python::ptr(child) );
    }

    virtual bool removeChildren( unsigned int pos, unsigned int numChildrenToRemove ) {
        if( bp::override func_removeChildren = this->get_override( "removeChildren" ) )
            return func_removeChildren( pos, numChildrenToRemove );
        else{
            return this->osg::Group::removeChildren( pos, numChildrenToRemove );
        }
    }
    
    bool default_removeChildren( unsigned int pos, unsigned int numChildrenToRemove ) {
        return osg::Group::removeChildren( pos, numChildrenToRemove );
    }

    virtual bool replaceChild( ::osg::Node * origChild, ::osg::Node * newChild ) {
        if( bp::override func_replaceChild = this->get_override( "replaceChild" ) )
            return func_replaceChild( boost::python::ptr(origChild), boost::python::ptr(newChild) );
        else{
            return this->osg::Group::replaceChild( boost::python::ptr(origChild), boost::python::ptr(newChild) );
        }
    }
    
    bool default_replaceChild( ::osg::Node * origChild, ::osg::Node * newChild ) {
        return osg::Group::replaceChild( boost::python::ptr(origChild), boost::python::ptr(newChild) );
    }

    virtual void resizeGLObjectBuffers( unsigned int maxSize ) {
        if( bp::override func_resizeGLObjectBuffers = this->get_override( "resizeGLObjectBuffers" ) )
            func_resizeGLObjectBuffers( maxSize );
        else{
            this->osg::Group::resizeGLObjectBuffers( maxSize );
        }
    }
    
    void default_resizeGLObjectBuffers( unsigned int maxSize ) {
        osg::Group::resizeGLObjectBuffers( maxSize );
    }

    virtual bool setChild( unsigned int i, ::osg::Node * node ) {
        if( bp::override func_setChild = this->get_override( "setChild" ) )
            return func_setChild( i, boost::python::ptr(node) );
        else{
            return this->osg::Group::setChild( i, boost::python::ptr(node) );
        }
    }
    
    bool default_setChild( unsigned int i, ::osg::Node * node ) {
        return osg::Group::setChild( i, boost::python::ptr(node) );
    }

    virtual void traverse( ::osg::NodeVisitor & nv ) {
        if( bp::override func_traverse = this->get_override( "traverse" ) )
            func_traverse( boost::ref(nv) );
        else{
            this->osg::Group::traverse( boost::ref(nv) );
        }
    }
    
    void default_traverse( ::osg::NodeVisitor & nv ) {
        osg::Group::traverse( boost::ref(nv) );
    }

};

void register_LightSource_class(){

    { //::osg::LightSource
        typedef bp::class_< LightSource_wrapper, bp::bases< osg::Group >, osg::ref_ptr< ::osg::LightSource >, boost::noncopyable > LightSource_exposer_t;
        LightSource_exposer_t LightSource_exposer = LightSource_exposer_t( "LightSource", "\n Leaf Node for defining a light in the scene.\n", bp::no_init );
        bp::scope LightSource_scope( LightSource_exposer );
        bp::enum_< osg::LightSource::ReferenceFrame>("ReferenceFrame")
            .value("RELATIVE_RF", osg::LightSource::RELATIVE_RF)
            .value("ABSOLUTE_RF", osg::LightSource::ABSOLUTE_RF)
            .export_values()
            ;
        LightSource_exposer.def( bp::init< >("\n Leaf Node for defining a light in the scene.\n") );
        { //::osg::LightSource::accept
        
            typedef void ( ::osg::LightSource::*accept_function_type )( ::osg::NodeVisitor & ) ;
            typedef void ( LightSource_wrapper::*default_accept_function_type )( ::osg::NodeVisitor & ) ;
            
            LightSource_exposer.def( 
                "accept"
                , accept_function_type(&::osg::LightSource::accept)
                , default_accept_function_type(&LightSource_wrapper::default_accept)
                , ( bp::arg("nv") ) );
        
        }
        { //::osg::LightSource::className
        
            typedef char const * ( ::osg::LightSource::*className_function_type )(  ) const;
            typedef char const * ( LightSource_wrapper::*default_className_function_type )(  ) const;
            
            LightSource_exposer.def( 
                "className"
                , className_function_type(&::osg::LightSource::className)
                , default_className_function_type(&LightSource_wrapper::default_className) );
        
        }
        { //::osg::LightSource::clone
        
            typedef ::osg::Object * ( ::osg::LightSource::*clone_function_type )( ::osg::CopyOp const & ) const;
            typedef ::osg::Object * ( LightSource_wrapper::*default_clone_function_type )( ::osg::CopyOp const & ) const;
            
            LightSource_exposer.def( 
                "clone"
                , clone_function_type(&::osg::LightSource::clone)
                , default_clone_function_type(&LightSource_wrapper::default_clone)
                , ( bp::arg("copyop") )
                , bp::return_value_policy< bp::reference_existing_object >() );
        
        }
        { //::osg::LightSource::cloneType
        
            typedef ::osg::Object * ( ::osg::LightSource::*cloneType_function_type )(  ) const;
            typedef ::osg::Object * ( LightSource_wrapper::*default_cloneType_function_type )(  ) const;
            
            LightSource_exposer.def( 
                "cloneType"
                , cloneType_function_type(&::osg::LightSource::cloneType)
                , default_cloneType_function_type(&LightSource_wrapper::default_cloneType)
                , bp::return_value_policy< bp::reference_existing_object >() );
        
        }
        { //::osg::LightSource::computeBound
        
            typedef ::osg::BoundingSphere ( ::osg::LightSource::*computeBound_function_type )(  ) const;
            typedef ::osg::BoundingSphere ( LightSource_wrapper::*default_computeBound_function_type )(  ) const;
            
            LightSource_exposer.def( 
                "computeBound"
                , computeBound_function_type(&::osg::LightSource::computeBound)
                , default_computeBound_function_type(&LightSource_wrapper::default_computeBound) );
        
        }
        { //::osg::LightSource::getLight
        
            typedef ::osg::Light * ( ::osg::LightSource::*getLight_function_type )(  ) ;
            
            LightSource_exposer.def( 
                "getLight"
                , getLight_function_type( &::osg::LightSource::getLight )
                , bp::return_internal_reference< >()
                , " Get the attached light." );
        
        }
        { //::osg::LightSource::getLight
        
            typedef ::osg::Light const * ( ::osg::LightSource::*getLight_function_type )(  ) const;
            
            LightSource_exposer.def( 
                "getLight"
                , getLight_function_type( &::osg::LightSource::getLight )
                , bp::return_internal_reference< >()
                , " Get the const attached light." );
        
        }
        { //::osg::LightSource::getReferenceFrame
        
            typedef ::osg::LightSource::ReferenceFrame ( ::osg::LightSource::*getReferenceFrame_function_type )(  ) const;
            
            LightSource_exposer.def( 
                "getReferenceFrame"
                , getReferenceFrame_function_type( &::osg::LightSource::getReferenceFrame ) );
        
        }
        { //::osg::LightSource::isSameKindAs
        
            typedef bool ( ::osg::LightSource::*isSameKindAs_function_type )( ::osg::Object const * ) const;
            typedef bool ( LightSource_wrapper::*default_isSameKindAs_function_type )( ::osg::Object const * ) const;
            
            LightSource_exposer.def( 
                "isSameKindAs"
                , isSameKindAs_function_type(&::osg::LightSource::isSameKindAs)
                , default_isSameKindAs_function_type(&LightSource_wrapper::default_isSameKindAs)
                , ( bp::arg("obj") ) );
        
        }
        { //::osg::LightSource::libraryName
        
            typedef char const * ( ::osg::LightSource::*libraryName_function_type )(  ) const;
            typedef char const * ( LightSource_wrapper::*default_libraryName_function_type )(  ) const;
            
            LightSource_exposer.def( 
                "libraryName"
                , libraryName_function_type(&::osg::LightSource::libraryName)
                , default_libraryName_function_type(&LightSource_wrapper::default_libraryName) );
        
        }
        { //::osg::LightSource::setLight
        
            typedef void ( ::osg::LightSource::*setLight_function_type )( ::osg::Light * ) ;
            
            LightSource_exposer.def( 
                "setLight"
                , setLight_function_type( &::osg::LightSource::setLight )
                , ( bp::arg("light") )
                , " Set the attached light." );
        
        }
        { //::osg::LightSource::setLocalStateSetModes
        
            typedef void ( ::osg::LightSource::*setLocalStateSetModes_function_type )( unsigned int ) ;
            
            LightSource_exposer.def( 
                "setLocalStateSetModes"
                , setLocalStateSetModes_function_type( &::osg::LightSource::setLocalStateSetModes )
                , ( bp::arg("value")=(unsigned int)(ON) )
                , " Set up the local StateSet." );
        
        }
        { //::osg::LightSource::setReferenceFrame
        
            typedef void ( ::osg::LightSource::*setReferenceFrame_function_type )( ::osg::LightSource::ReferenceFrame ) ;
            
            LightSource_exposer.def( 
                "setReferenceFrame"
                , setReferenceFrame_function_type( &::osg::LightSource::setReferenceFrame )
                , ( bp::arg("rf") )
                , " Set the light sourcess ReferenceFrame, either to be relative to its\n parent reference frame, or relative to an absolute coordinate\n frame. RELATIVE_RF is the default.\n Note: setting the ReferenceFrame to be ABSOLUTE_RF will\n also set the CullingActive flag on the light source, and hence all\n of its parents, to false, thereby disabling culling of it and\n all its parents.  This is necessary to prevent inappropriate\n culling, but may impact cull times if the absolute light source is\n deep in the scene graph.  It is therefore recommended to only use\n absolute light source at the top of the scene." );
        
        }
        { //::osg::LightSource::setStateSetModes
        
            typedef void ( ::osg::LightSource::*setStateSetModes_function_type )( ::osg::StateSet &,unsigned int ) const;
            
            LightSource_exposer.def( 
                "setStateSetModes"
                , setStateSetModes_function_type( &::osg::LightSource::setStateSetModes )
                , ( bp::arg("arg0"), bp::arg("arg1") )
                , " Set the GLModes on StateSet associated with the LightSource." );
        
        }
        { //::osg::LightSource::setThreadSafeRefUnref
        
            typedef void ( ::osg::LightSource::*setThreadSafeRefUnref_function_type )( bool ) ;
            typedef void ( LightSource_wrapper::*default_setThreadSafeRefUnref_function_type )( bool ) ;
            
            LightSource_exposer.def( 
                "setThreadSafeRefUnref"
                , setThreadSafeRefUnref_function_type(&::osg::LightSource::setThreadSafeRefUnref)
                , default_setThreadSafeRefUnref_function_type(&LightSource_wrapper::default_setThreadSafeRefUnref)
                , ( bp::arg("threadSafe") ) );
        
        }
        { //::osg::Group::addChild
        
            typedef bool ( ::osg::Group::*addChild_function_type )( ::osg::Node * ) ;
            typedef bool ( LightSource_wrapper::*default_addChild_function_type )( ::osg::Node * ) ;
            
            LightSource_exposer.def( 
                "addChild"
                , addChild_function_type(&::osg::Group::addChild)
                , default_addChild_function_type(&LightSource_wrapper::default_addChild)
                , ( bp::arg("child") ) );
        
        }
        { //::osg::Node::asCamera
        
            typedef ::osg::Camera * ( ::osg::Node::*asCamera_function_type )(  ) ;
            typedef ::osg::Camera * ( LightSource_wrapper::*default_asCamera_function_type )(  ) ;
            
            LightSource_exposer.def( 
                "asCamera"
                , asCamera_function_type(&::osg::Node::asCamera)
                , default_asCamera_function_type(&LightSource_wrapper::default_asCamera)
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::Node::asCamera
        
            typedef ::osg::Camera const * ( ::osg::Node::*asCamera_function_type )(  ) const;
            typedef ::osg::Camera const * ( LightSource_wrapper::*default_asCamera_function_type )(  ) const;
            
            LightSource_exposer.def( 
                "asCamera"
                , asCamera_function_type(&::osg::Node::asCamera)
                , default_asCamera_function_type(&LightSource_wrapper::default_asCamera)
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::Node::asGeode
        
            typedef ::osg::Geode * ( ::osg::Node::*asGeode_function_type )(  ) ;
            typedef ::osg::Geode * ( LightSource_wrapper::*default_asGeode_function_type )(  ) ;
            
            LightSource_exposer.def( 
                "asGeode"
                , asGeode_function_type(&::osg::Node::asGeode)
                , default_asGeode_function_type(&LightSource_wrapper::default_asGeode)
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::Node::asGeode
        
            typedef ::osg::Geode const * ( ::osg::Node::*asGeode_function_type )(  ) const;
            typedef ::osg::Geode const * ( LightSource_wrapper::*default_asGeode_function_type )(  ) const;
            
            LightSource_exposer.def( 
                "asGeode"
                , asGeode_function_type(&::osg::Node::asGeode)
                , default_asGeode_function_type(&LightSource_wrapper::default_asGeode)
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::Group::asGroup
        
            typedef ::osg::Group * ( ::osg::Group::*asGroup_function_type )(  ) ;
            typedef ::osg::Group * ( LightSource_wrapper::*default_asGroup_function_type )(  ) ;
            
            LightSource_exposer.def( 
                "asGroup"
                , asGroup_function_type(&::osg::Group::asGroup)
                , default_asGroup_function_type(&LightSource_wrapper::default_asGroup)
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::Group::asGroup
        
            typedef ::osg::Group const * ( ::osg::Group::*asGroup_function_type )(  ) const;
            typedef ::osg::Group const * ( LightSource_wrapper::*default_asGroup_function_type )(  ) const;
            
            LightSource_exposer.def( 
                "asGroup"
                , asGroup_function_type(&::osg::Group::asGroup)
                , default_asGroup_function_type(&LightSource_wrapper::default_asGroup)
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::Node::asSwitch
        
            typedef ::osg::Switch * ( ::osg::Node::*asSwitch_function_type )(  ) ;
            typedef ::osg::Switch * ( LightSource_wrapper::*default_asSwitch_function_type )(  ) ;
            
            LightSource_exposer.def( 
                "asSwitch"
                , asSwitch_function_type(&::osg::Node::asSwitch)
                , default_asSwitch_function_type(&LightSource_wrapper::default_asSwitch)
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::Node::asSwitch
        
            typedef ::osg::Switch const * ( ::osg::Node::*asSwitch_function_type )(  ) const;
            typedef ::osg::Switch const * ( LightSource_wrapper::*default_asSwitch_function_type )(  ) const;
            
            LightSource_exposer.def( 
                "asSwitch"
                , asSwitch_function_type(&::osg::Node::asSwitch)
                , default_asSwitch_function_type(&LightSource_wrapper::default_asSwitch)
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::Node::asTransform
        
            typedef ::osg::Transform * ( ::osg::Node::*asTransform_function_type )(  ) ;
            typedef ::osg::Transform * ( LightSource_wrapper::*default_asTransform_function_type )(  ) ;
            
            LightSource_exposer.def( 
                "asTransform"
                , asTransform_function_type(&::osg::Node::asTransform)
                , default_asTransform_function_type(&LightSource_wrapper::default_asTransform)
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::Node::asTransform
        
            typedef ::osg::Transform const * ( ::osg::Node::*asTransform_function_type )(  ) const;
            typedef ::osg::Transform const * ( LightSource_wrapper::*default_asTransform_function_type )(  ) const;
            
            LightSource_exposer.def( 
                "asTransform"
                , asTransform_function_type(&::osg::Node::asTransform)
                , default_asTransform_function_type(&LightSource_wrapper::default_asTransform)
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::Node::ascend
        
            typedef void ( ::osg::Node::*ascend_function_type )( ::osg::NodeVisitor & ) ;
            typedef void ( LightSource_wrapper::*default_ascend_function_type )( ::osg::NodeVisitor & ) ;
            
            LightSource_exposer.def( 
                "ascend"
                , ascend_function_type(&::osg::Node::ascend)
                , default_ascend_function_type(&LightSource_wrapper::default_ascend)
                , ( bp::arg("nv") ) );
        
        }
        { //::osg::Group::insertChild
        
            typedef bool ( ::osg::Group::*insertChild_function_type )( unsigned int,::osg::Node * ) ;
            typedef bool ( LightSource_wrapper::*default_insertChild_function_type )( unsigned int,::osg::Node * ) ;
            
            LightSource_exposer.def( 
                "insertChild"
                , insertChild_function_type(&::osg::Group::insertChild)
                , default_insertChild_function_type(&LightSource_wrapper::default_insertChild)
                , ( bp::arg("index"), bp::arg("child") ) );
        
        }
        { //::osg::Group::removeChildren
        
            typedef bool ( ::osg::Group::*removeChildren_function_type )( unsigned int,unsigned int ) ;
            typedef bool ( LightSource_wrapper::*default_removeChildren_function_type )( unsigned int,unsigned int ) ;
            
            LightSource_exposer.def( 
                "removeChildren"
                , removeChildren_function_type(&::osg::Group::removeChildren)
                , default_removeChildren_function_type(&LightSource_wrapper::default_removeChildren)
                , ( bp::arg("pos"), bp::arg("numChildrenToRemove") ) );
        
        }
        { //::osg::Group::replaceChild
        
            typedef bool ( ::osg::Group::*replaceChild_function_type )( ::osg::Node *,::osg::Node * ) ;
            typedef bool ( LightSource_wrapper::*default_replaceChild_function_type )( ::osg::Node *,::osg::Node * ) ;
            
            LightSource_exposer.def( 
                "replaceChild"
                , replaceChild_function_type(&::osg::Group::replaceChild)
                , default_replaceChild_function_type(&LightSource_wrapper::default_replaceChild)
                , ( bp::arg("origChild"), bp::arg("newChild") ) );
        
        }
        { //::osg::Group::resizeGLObjectBuffers
        
            typedef void ( ::osg::Group::*resizeGLObjectBuffers_function_type )( unsigned int ) ;
            typedef void ( LightSource_wrapper::*default_resizeGLObjectBuffers_function_type )( unsigned int ) ;
            
            LightSource_exposer.def( 
                "resizeGLObjectBuffers"
                , resizeGLObjectBuffers_function_type(&::osg::Group::resizeGLObjectBuffers)
                , default_resizeGLObjectBuffers_function_type(&LightSource_wrapper::default_resizeGLObjectBuffers)
                , ( bp::arg("maxSize") ) );
        
        }
        { //::osg::Group::setChild
        
            typedef bool ( ::osg::Group::*setChild_function_type )( unsigned int,::osg::Node * ) ;
            typedef bool ( LightSource_wrapper::*default_setChild_function_type )( unsigned int,::osg::Node * ) ;
            
            LightSource_exposer.def( 
                "setChild"
                , setChild_function_type(&::osg::Group::setChild)
                , default_setChild_function_type(&LightSource_wrapper::default_setChild)
                , ( bp::arg("i"), bp::arg("node") ) );
        
        }
        { //::osg::Group::traverse
        
            typedef void ( ::osg::Group::*traverse_function_type )( ::osg::NodeVisitor & ) ;
            typedef void ( LightSource_wrapper::*default_traverse_function_type )( ::osg::NodeVisitor & ) ;
            
            LightSource_exposer.def( 
                "traverse"
                , traverse_function_type(&::osg::Group::traverse)
                , default_traverse_function_type(&LightSource_wrapper::default_traverse)
                , ( bp::arg("nv") ) );
        
        }
    }

}
