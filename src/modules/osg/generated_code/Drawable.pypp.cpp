// This file has been generated by Py++.

#include "boost/python.hpp"
#include "wrap_osg.h"
#include "wrap_referenced.h"
#include "Drawable.pypp.hpp"

namespace bp = boost::python;

struct Drawable_wrapper : osg::Drawable, bp::wrapper< osg::Drawable > {

    struct AttributeFunctor_wrapper : osg::Drawable::AttributeFunctor, bp::wrapper< osg::Drawable::AttributeFunctor > {
    
        AttributeFunctor_wrapper(osg::Drawable::AttributeFunctor const & arg )
        : osg::Drawable::AttributeFunctor( arg )
          , bp::wrapper< osg::Drawable::AttributeFunctor >(){
            // copy constructor
            
        }
    
        AttributeFunctor_wrapper()
        : osg::Drawable::AttributeFunctor()
          , bp::wrapper< osg::Drawable::AttributeFunctor >(){
            // null constructor
            
        }
    
        virtual void apply( unsigned int arg0, unsigned int arg1, ::GLbyte * arg2 ) {
            if( bp::override func_apply = this->get_override( "apply" ) )
                func_apply( arg0, arg1, arg2 );
            else{
                this->osg::Drawable::AttributeFunctor::apply( arg0, arg1, arg2 );
            }
        }
        
        void default_apply( unsigned int arg0, unsigned int arg1, ::GLbyte * arg2 ) {
            osg::Drawable::AttributeFunctor::apply( arg0, arg1, arg2 );
        }
    
        virtual void apply( unsigned int arg0, unsigned int arg1, ::GLshort * arg2 ) {
            if( bp::override func_apply = this->get_override( "apply" ) )
                func_apply( arg0, arg1, arg2 );
            else{
                this->osg::Drawable::AttributeFunctor::apply( arg0, arg1, arg2 );
            }
        }
        
        void default_apply( unsigned int arg0, unsigned int arg1, ::GLshort * arg2 ) {
            osg::Drawable::AttributeFunctor::apply( arg0, arg1, arg2 );
        }
    
        virtual void apply( unsigned int arg0, unsigned int arg1, ::GLint * arg2 ) {
            if( bp::override func_apply = this->get_override( "apply" ) )
                func_apply( arg0, arg1, arg2 );
            else{
                this->osg::Drawable::AttributeFunctor::apply( arg0, arg1, arg2 );
            }
        }
        
        void default_apply( unsigned int arg0, unsigned int arg1, ::GLint * arg2 ) {
            osg::Drawable::AttributeFunctor::apply( arg0, arg1, arg2 );
        }
    
        virtual void apply( unsigned int arg0, unsigned int arg1, ::GLubyte * arg2 ) {
            if( bp::override func_apply = this->get_override( "apply" ) )
                func_apply( arg0, arg1, arg2 );
            else{
                this->osg::Drawable::AttributeFunctor::apply( arg0, arg1, arg2 );
            }
        }
        
        void default_apply( unsigned int arg0, unsigned int arg1, ::GLubyte * arg2 ) {
            osg::Drawable::AttributeFunctor::apply( arg0, arg1, arg2 );
        }
    
        virtual void apply( unsigned int arg0, unsigned int arg1, ::GLushort * arg2 ) {
            if( bp::override func_apply = this->get_override( "apply" ) )
                func_apply( arg0, arg1, arg2 );
            else{
                this->osg::Drawable::AttributeFunctor::apply( arg0, arg1, arg2 );
            }
        }
        
        void default_apply( unsigned int arg0, unsigned int arg1, ::GLushort * arg2 ) {
            osg::Drawable::AttributeFunctor::apply( arg0, arg1, arg2 );
        }
    
        virtual void apply( unsigned int arg0, unsigned int arg1, ::GLuint * arg2 ) {
            if( bp::override func_apply = this->get_override( "apply" ) )
                func_apply( arg0, arg1, arg2 );
            else{
                this->osg::Drawable::AttributeFunctor::apply( arg0, arg1, arg2 );
            }
        }
        
        void default_apply( unsigned int arg0, unsigned int arg1, ::GLuint * arg2 ) {
            osg::Drawable::AttributeFunctor::apply( arg0, arg1, arg2 );
        }
    
        virtual void apply( unsigned int arg0, unsigned int arg1, float * arg2 ) {
            if( bp::override func_apply = this->get_override( "apply" ) )
                func_apply( arg0, arg1, arg2 );
            else{
                this->osg::Drawable::AttributeFunctor::apply( arg0, arg1, arg2 );
            }
        }
        
        void default_apply( unsigned int arg0, unsigned int arg1, float * arg2 ) {
            osg::Drawable::AttributeFunctor::apply( arg0, arg1, arg2 );
        }
    
        virtual void apply( unsigned int arg0, unsigned int arg1, ::osg::Vec2 * arg2 ) {
            if( bp::override func_apply = this->get_override( "apply" ) )
                func_apply( arg0, arg1, boost::python::ptr(arg2) );
            else{
                this->osg::Drawable::AttributeFunctor::apply( arg0, arg1, boost::python::ptr(arg2) );
            }
        }
        
        void default_apply( unsigned int arg0, unsigned int arg1, ::osg::Vec2 * arg2 ) {
            osg::Drawable::AttributeFunctor::apply( arg0, arg1, boost::python::ptr(arg2) );
        }
    
        virtual void apply( unsigned int arg0, unsigned int arg1, ::osg::Vec3 * arg2 ) {
            if( bp::override func_apply = this->get_override( "apply" ) )
                func_apply( arg0, arg1, boost::python::ptr(arg2) );
            else{
                this->osg::Drawable::AttributeFunctor::apply( arg0, arg1, boost::python::ptr(arg2) );
            }
        }
        
        void default_apply( unsigned int arg0, unsigned int arg1, ::osg::Vec3 * arg2 ) {
            osg::Drawable::AttributeFunctor::apply( arg0, arg1, boost::python::ptr(arg2) );
        }
    
        virtual void apply( unsigned int arg0, unsigned int arg1, ::osg::Vec4 * arg2 ) {
            if( bp::override func_apply = this->get_override( "apply" ) )
                func_apply( arg0, arg1, boost::python::ptr(arg2) );
            else{
                this->osg::Drawable::AttributeFunctor::apply( arg0, arg1, boost::python::ptr(arg2) );
            }
        }
        
        void default_apply( unsigned int arg0, unsigned int arg1, ::osg::Vec4 * arg2 ) {
            osg::Drawable::AttributeFunctor::apply( arg0, arg1, boost::python::ptr(arg2) );
        }
    
        virtual void apply( unsigned int arg0, unsigned int arg1, ::osg::Vec4ub * arg2 ) {
            if( bp::override func_apply = this->get_override( "apply" ) )
                func_apply( arg0, arg1, boost::python::ptr(arg2) );
            else{
                this->osg::Drawable::AttributeFunctor::apply( arg0, arg1, boost::python::ptr(arg2) );
            }
        }
        
        void default_apply( unsigned int arg0, unsigned int arg1, ::osg::Vec4ub * arg2 ) {
            osg::Drawable::AttributeFunctor::apply( arg0, arg1, boost::python::ptr(arg2) );
        }
    
        virtual void apply( unsigned int arg0, unsigned int arg1, double * arg2 ) {
            if( bp::override func_apply = this->get_override( "apply" ) )
                func_apply( arg0, arg1, arg2 );
            else{
                this->osg::Drawable::AttributeFunctor::apply( arg0, arg1, arg2 );
            }
        }
        
        void default_apply( unsigned int arg0, unsigned int arg1, double * arg2 ) {
            osg::Drawable::AttributeFunctor::apply( arg0, arg1, arg2 );
        }
    
        virtual void apply( unsigned int arg0, unsigned int arg1, ::osg::Vec2d * arg2 ) {
            if( bp::override func_apply = this->get_override( "apply" ) )
                func_apply( arg0, arg1, boost::python::ptr(arg2) );
            else{
                this->osg::Drawable::AttributeFunctor::apply( arg0, arg1, boost::python::ptr(arg2) );
            }
        }
        
        void default_apply( unsigned int arg0, unsigned int arg1, ::osg::Vec2d * arg2 ) {
            osg::Drawable::AttributeFunctor::apply( arg0, arg1, boost::python::ptr(arg2) );
        }
    
        virtual void apply( unsigned int arg0, unsigned int arg1, ::osg::Vec3d * arg2 ) {
            if( bp::override func_apply = this->get_override( "apply" ) )
                func_apply( arg0, arg1, boost::python::ptr(arg2) );
            else{
                this->osg::Drawable::AttributeFunctor::apply( arg0, arg1, boost::python::ptr(arg2) );
            }
        }
        
        void default_apply( unsigned int arg0, unsigned int arg1, ::osg::Vec3d * arg2 ) {
            osg::Drawable::AttributeFunctor::apply( arg0, arg1, boost::python::ptr(arg2) );
        }
    
        virtual void apply( unsigned int arg0, unsigned int arg1, ::osg::Vec4d * arg2 ) {
            if( bp::override func_apply = this->get_override( "apply" ) )
                func_apply( arg0, arg1, boost::python::ptr(arg2) );
            else{
                this->osg::Drawable::AttributeFunctor::apply( arg0, arg1, boost::python::ptr(arg2) );
            }
        }
        
        void default_apply( unsigned int arg0, unsigned int arg1, ::osg::Vec4d * arg2 ) {
            osg::Drawable::AttributeFunctor::apply( arg0, arg1, boost::python::ptr(arg2) );
        }
    
    };

    struct ConstAttributeFunctor_wrapper : osg::Drawable::ConstAttributeFunctor, bp::wrapper< osg::Drawable::ConstAttributeFunctor > {
    
        ConstAttributeFunctor_wrapper(osg::Drawable::ConstAttributeFunctor const & arg )
        : osg::Drawable::ConstAttributeFunctor( arg )
          , bp::wrapper< osg::Drawable::ConstAttributeFunctor >(){
            // copy constructor
            
        }
    
        ConstAttributeFunctor_wrapper()
        : osg::Drawable::ConstAttributeFunctor()
          , bp::wrapper< osg::Drawable::ConstAttributeFunctor >(){
            // null constructor
            
        }
    
        virtual void apply( unsigned int arg0, unsigned int arg1, ::GLbyte const * arg2 ) {
            if( bp::override func_apply = this->get_override( "apply" ) )
                func_apply( arg0, arg1, arg2 );
            else{
                this->osg::Drawable::ConstAttributeFunctor::apply( arg0, arg1, arg2 );
            }
        }
        
        void default_apply( unsigned int arg0, unsigned int arg1, ::GLbyte const * arg2 ) {
            osg::Drawable::ConstAttributeFunctor::apply( arg0, arg1, arg2 );
        }
    
        virtual void apply( unsigned int arg0, unsigned int arg1, ::GLshort const * arg2 ) {
            if( bp::override func_apply = this->get_override( "apply" ) )
                func_apply( arg0, arg1, arg2 );
            else{
                this->osg::Drawable::ConstAttributeFunctor::apply( arg0, arg1, arg2 );
            }
        }
        
        void default_apply( unsigned int arg0, unsigned int arg1, ::GLshort const * arg2 ) {
            osg::Drawable::ConstAttributeFunctor::apply( arg0, arg1, arg2 );
        }
    
        virtual void apply( unsigned int arg0, unsigned int arg1, ::GLint const * arg2 ) {
            if( bp::override func_apply = this->get_override( "apply" ) )
                func_apply( arg0, arg1, arg2 );
            else{
                this->osg::Drawable::ConstAttributeFunctor::apply( arg0, arg1, arg2 );
            }
        }
        
        void default_apply( unsigned int arg0, unsigned int arg1, ::GLint const * arg2 ) {
            osg::Drawable::ConstAttributeFunctor::apply( arg0, arg1, arg2 );
        }
    
        virtual void apply( unsigned int arg0, unsigned int arg1, ::GLubyte const * arg2 ) {
            if( bp::override func_apply = this->get_override( "apply" ) )
                func_apply( arg0, arg1, arg2 );
            else{
                this->osg::Drawable::ConstAttributeFunctor::apply( arg0, arg1, arg2 );
            }
        }
        
        void default_apply( unsigned int arg0, unsigned int arg1, ::GLubyte const * arg2 ) {
            osg::Drawable::ConstAttributeFunctor::apply( arg0, arg1, arg2 );
        }
    
        virtual void apply( unsigned int arg0, unsigned int arg1, ::GLushort const * arg2 ) {
            if( bp::override func_apply = this->get_override( "apply" ) )
                func_apply( arg0, arg1, arg2 );
            else{
                this->osg::Drawable::ConstAttributeFunctor::apply( arg0, arg1, arg2 );
            }
        }
        
        void default_apply( unsigned int arg0, unsigned int arg1, ::GLushort const * arg2 ) {
            osg::Drawable::ConstAttributeFunctor::apply( arg0, arg1, arg2 );
        }
    
        virtual void apply( unsigned int arg0, unsigned int arg1, ::GLuint const * arg2 ) {
            if( bp::override func_apply = this->get_override( "apply" ) )
                func_apply( arg0, arg1, arg2 );
            else{
                this->osg::Drawable::ConstAttributeFunctor::apply( arg0, arg1, arg2 );
            }
        }
        
        void default_apply( unsigned int arg0, unsigned int arg1, ::GLuint const * arg2 ) {
            osg::Drawable::ConstAttributeFunctor::apply( arg0, arg1, arg2 );
        }
    
        virtual void apply( unsigned int arg0, unsigned int arg1, float const * arg2 ) {
            if( bp::override func_apply = this->get_override( "apply" ) )
                func_apply( arg0, arg1, arg2 );
            else{
                this->osg::Drawable::ConstAttributeFunctor::apply( arg0, arg1, arg2 );
            }
        }
        
        void default_apply( unsigned int arg0, unsigned int arg1, float const * arg2 ) {
            osg::Drawable::ConstAttributeFunctor::apply( arg0, arg1, arg2 );
        }
    
        virtual void apply( unsigned int arg0, unsigned int arg1, ::osg::Vec2 const * arg2 ) {
            if( bp::override func_apply = this->get_override( "apply" ) )
                func_apply( arg0, arg1, boost::python::ptr(arg2) );
            else{
                this->osg::Drawable::ConstAttributeFunctor::apply( arg0, arg1, boost::python::ptr(arg2) );
            }
        }
        
        void default_apply( unsigned int arg0, unsigned int arg1, ::osg::Vec2 const * arg2 ) {
            osg::Drawable::ConstAttributeFunctor::apply( arg0, arg1, boost::python::ptr(arg2) );
        }
    
        virtual void apply( unsigned int arg0, unsigned int arg1, ::osg::Vec3 const * arg2 ) {
            if( bp::override func_apply = this->get_override( "apply" ) )
                func_apply( arg0, arg1, boost::python::ptr(arg2) );
            else{
                this->osg::Drawable::ConstAttributeFunctor::apply( arg0, arg1, boost::python::ptr(arg2) );
            }
        }
        
        void default_apply( unsigned int arg0, unsigned int arg1, ::osg::Vec3 const * arg2 ) {
            osg::Drawable::ConstAttributeFunctor::apply( arg0, arg1, boost::python::ptr(arg2) );
        }
    
        virtual void apply( unsigned int arg0, unsigned int arg1, ::osg::Vec4 const * arg2 ) {
            if( bp::override func_apply = this->get_override( "apply" ) )
                func_apply( arg0, arg1, boost::python::ptr(arg2) );
            else{
                this->osg::Drawable::ConstAttributeFunctor::apply( arg0, arg1, boost::python::ptr(arg2) );
            }
        }
        
        void default_apply( unsigned int arg0, unsigned int arg1, ::osg::Vec4 const * arg2 ) {
            osg::Drawable::ConstAttributeFunctor::apply( arg0, arg1, boost::python::ptr(arg2) );
        }
    
        virtual void apply( unsigned int arg0, unsigned int arg1, ::osg::Vec4ub const * arg2 ) {
            if( bp::override func_apply = this->get_override( "apply" ) )
                func_apply( arg0, arg1, boost::python::ptr(arg2) );
            else{
                this->osg::Drawable::ConstAttributeFunctor::apply( arg0, arg1, boost::python::ptr(arg2) );
            }
        }
        
        void default_apply( unsigned int arg0, unsigned int arg1, ::osg::Vec4ub const * arg2 ) {
            osg::Drawable::ConstAttributeFunctor::apply( arg0, arg1, boost::python::ptr(arg2) );
        }
    
        virtual void apply( unsigned int arg0, unsigned int arg1, double const * arg2 ) {
            if( bp::override func_apply = this->get_override( "apply" ) )
                func_apply( arg0, arg1, arg2 );
            else{
                this->osg::Drawable::ConstAttributeFunctor::apply( arg0, arg1, arg2 );
            }
        }
        
        void default_apply( unsigned int arg0, unsigned int arg1, double const * arg2 ) {
            osg::Drawable::ConstAttributeFunctor::apply( arg0, arg1, arg2 );
        }
    
        virtual void apply( unsigned int arg0, unsigned int arg1, ::osg::Vec2d const * arg2 ) {
            if( bp::override func_apply = this->get_override( "apply" ) )
                func_apply( arg0, arg1, boost::python::ptr(arg2) );
            else{
                this->osg::Drawable::ConstAttributeFunctor::apply( arg0, arg1, boost::python::ptr(arg2) );
            }
        }
        
        void default_apply( unsigned int arg0, unsigned int arg1, ::osg::Vec2d const * arg2 ) {
            osg::Drawable::ConstAttributeFunctor::apply( arg0, arg1, boost::python::ptr(arg2) );
        }
    
        virtual void apply( unsigned int arg0, unsigned int arg1, ::osg::Vec3d const * arg2 ) {
            if( bp::override func_apply = this->get_override( "apply" ) )
                func_apply( arg0, arg1, boost::python::ptr(arg2) );
            else{
                this->osg::Drawable::ConstAttributeFunctor::apply( arg0, arg1, boost::python::ptr(arg2) );
            }
        }
        
        void default_apply( unsigned int arg0, unsigned int arg1, ::osg::Vec3d const * arg2 ) {
            osg::Drawable::ConstAttributeFunctor::apply( arg0, arg1, boost::python::ptr(arg2) );
        }
    
        virtual void apply( unsigned int arg0, unsigned int arg1, ::osg::Vec4d const * arg2 ) {
            if( bp::override func_apply = this->get_override( "apply" ) )
                func_apply( arg0, arg1, boost::python::ptr(arg2) );
            else{
                this->osg::Drawable::ConstAttributeFunctor::apply( arg0, arg1, boost::python::ptr(arg2) );
            }
        }
        
        void default_apply( unsigned int arg0, unsigned int arg1, ::osg::Vec4d const * arg2 ) {
            osg::Drawable::ConstAttributeFunctor::apply( arg0, arg1, boost::python::ptr(arg2) );
        }
    
    };

    struct CullCallback_wrapper : osg::Drawable::CullCallback, bp::wrapper< osg::Drawable::CullCallback > {
    
        virtual char const * className(  ) const  {
            if( bp::override func_className = this->get_override( "className" ) )
                return func_className(  );
            else{
                return this->osg::Drawable::CullCallback::className(  );
            }
        }
        
        char const * default_className(  ) const  {
            return osg::Drawable::CullCallback::className( );
        }
    
        virtual ::osg::Object * clone( ::osg::CopyOp const & copyop ) const  {
            if( bp::override func_clone = this->get_override( "clone" ) )
                return func_clone( boost::ref(copyop) );
            else{
                return this->osg::Drawable::CullCallback::clone( boost::ref(copyop) );
            }
        }
        
        ::osg::Object * default_clone( ::osg::CopyOp const & copyop ) const  {
            return osg::Drawable::CullCallback::clone( boost::ref(copyop) );
        }
    
        virtual ::osg::Object * cloneType(  ) const  {
            if( bp::override func_cloneType = this->get_override( "cloneType" ) )
                return func_cloneType(  );
            else{
                return this->osg::Drawable::CullCallback::cloneType(  );
            }
        }
        
        ::osg::Object * default_cloneType(  ) const  {
            return osg::Drawable::CullCallback::cloneType( );
        }
    
        virtual bool cull( ::osg::NodeVisitor * arg0, ::osg::Drawable * arg1, ::osg::State * arg2 ) const  {
            if( bp::override func_cull = this->get_override( "cull" ) )
                return func_cull( boost::python::ptr(arg0), boost::python::ptr(arg1), boost::python::ptr(arg2) );
            else{
                return this->osg::Drawable::CullCallback::cull( boost::python::ptr(arg0), boost::python::ptr(arg1), boost::python::ptr(arg2) );
            }
        }
        
        bool default_cull( ::osg::NodeVisitor * arg0, ::osg::Drawable * arg1, ::osg::State * arg2 ) const  {
            return osg::Drawable::CullCallback::cull( boost::python::ptr(arg0), boost::python::ptr(arg1), boost::python::ptr(arg2) );
        }
    
        virtual bool cull( ::osg::NodeVisitor * nv, ::osg::Drawable * drawable, ::osg::RenderInfo * renderInfo ) const  {
            if( bp::override func_cull = this->get_override( "cull" ) )
                return func_cull( boost::python::ptr(nv), boost::python::ptr(drawable), boost::python::ptr(renderInfo) );
            else{
                return this->osg::Drawable::CullCallback::cull( boost::python::ptr(nv), boost::python::ptr(drawable), boost::python::ptr(renderInfo) );
            }
        }
        
        bool default_cull( ::osg::NodeVisitor * nv, ::osg::Drawable * drawable, ::osg::RenderInfo * renderInfo ) const  {
            return osg::Drawable::CullCallback::cull( boost::python::ptr(nv), boost::python::ptr(drawable), boost::python::ptr(renderInfo) );
        }
    
        virtual bool isSameKindAs( ::osg::Object const * obj ) const  {
            if( bp::override func_isSameKindAs = this->get_override( "isSameKindAs" ) )
                return func_isSameKindAs( boost::python::ptr(obj) );
            else{
                return this->osg::Drawable::CullCallback::isSameKindAs( boost::python::ptr(obj) );
            }
        }
        
        bool default_isSameKindAs( ::osg::Object const * obj ) const  {
            return osg::Drawable::CullCallback::isSameKindAs( boost::python::ptr(obj) );
        }
    
        virtual char const * libraryName(  ) const  {
            if( bp::override func_libraryName = this->get_override( "libraryName" ) )
                return func_libraryName(  );
            else{
                return this->osg::Drawable::CullCallback::libraryName(  );
            }
        }
        
        char const * default_libraryName(  ) const  {
            return osg::Drawable::CullCallback::libraryName( );
        }
    
    };

    struct DrawCallback_wrapper : osg::Drawable::DrawCallback, bp::wrapper< osg::Drawable::DrawCallback > {
    
        virtual char const * className(  ) const  {
            if( bp::override func_className = this->get_override( "className" ) )
                return func_className(  );
            else{
                return this->osg::Drawable::DrawCallback::className(  );
            }
        }
        
        char const * default_className(  ) const  {
            return osg::Drawable::DrawCallback::className( );
        }
    
        virtual ::osg::Object * clone( ::osg::CopyOp const & copyop ) const  {
            if( bp::override func_clone = this->get_override( "clone" ) )
                return func_clone( boost::ref(copyop) );
            else{
                return this->osg::Drawable::DrawCallback::clone( boost::ref(copyop) );
            }
        }
        
        ::osg::Object * default_clone( ::osg::CopyOp const & copyop ) const  {
            return osg::Drawable::DrawCallback::clone( boost::ref(copyop) );
        }
    
        virtual ::osg::Object * cloneType(  ) const  {
            if( bp::override func_cloneType = this->get_override( "cloneType" ) )
                return func_cloneType(  );
            else{
                return this->osg::Drawable::DrawCallback::cloneType(  );
            }
        }
        
        ::osg::Object * default_cloneType(  ) const  {
            return osg::Drawable::DrawCallback::cloneType( );
        }
    
        virtual void drawImplementation( ::osg::RenderInfo & arg0, ::osg::Drawable const * arg1 ) const  {
            if( bp::override func_drawImplementation = this->get_override( "drawImplementation" ) )
                func_drawImplementation( boost::ref(arg0), boost::python::ptr(arg1) );
            else{
                this->osg::Drawable::DrawCallback::drawImplementation( boost::ref(arg0), boost::python::ptr(arg1) );
            }
        }
        
        void default_drawImplementation( ::osg::RenderInfo & arg0, ::osg::Drawable const * arg1 ) const  {
            osg::Drawable::DrawCallback::drawImplementation( boost::ref(arg0), boost::python::ptr(arg1) );
        }
    
        virtual bool isSameKindAs( ::osg::Object const * obj ) const  {
            if( bp::override func_isSameKindAs = this->get_override( "isSameKindAs" ) )
                return func_isSameKindAs( boost::python::ptr(obj) );
            else{
                return this->osg::Drawable::DrawCallback::isSameKindAs( boost::python::ptr(obj) );
            }
        }
        
        bool default_isSameKindAs( ::osg::Object const * obj ) const  {
            return osg::Drawable::DrawCallback::isSameKindAs( boost::python::ptr(obj) );
        }
    
        virtual char const * libraryName(  ) const  {
            if( bp::override func_libraryName = this->get_override( "libraryName" ) )
                return func_libraryName(  );
            else{
                return this->osg::Drawable::DrawCallback::libraryName(  );
            }
        }
        
        char const * default_libraryName(  ) const  {
            return osg::Drawable::DrawCallback::libraryName( );
        }
    
    };

    struct EventCallback_wrapper : osg::Drawable::EventCallback, bp::wrapper< osg::Drawable::EventCallback > {
    
        virtual char const * className(  ) const  {
            if( bp::override func_className = this->get_override( "className" ) )
                return func_className(  );
            else{
                return this->osg::Drawable::EventCallback::className(  );
            }
        }
        
        char const * default_className(  ) const  {
            return osg::Drawable::EventCallback::className( );
        }
    
        virtual ::osg::Object * clone( ::osg::CopyOp const & copyop ) const  {
            if( bp::override func_clone = this->get_override( "clone" ) )
                return func_clone( boost::ref(copyop) );
            else{
                return this->osg::Drawable::EventCallback::clone( boost::ref(copyop) );
            }
        }
        
        ::osg::Object * default_clone( ::osg::CopyOp const & copyop ) const  {
            return osg::Drawable::EventCallback::clone( boost::ref(copyop) );
        }
    
        virtual ::osg::Object * cloneType(  ) const  {
            if( bp::override func_cloneType = this->get_override( "cloneType" ) )
                return func_cloneType(  );
            else{
                return this->osg::Drawable::EventCallback::cloneType(  );
            }
        }
        
        ::osg::Object * default_cloneType(  ) const  {
            return osg::Drawable::EventCallback::cloneType( );
        }
    
        virtual void event( ::osg::NodeVisitor * arg0, ::osg::Drawable * arg1 ) {
            if( bp::override func_event = this->get_override( "event" ) )
                func_event( boost::python::ptr(arg0), boost::python::ptr(arg1) );
            else{
                this->osg::Drawable::EventCallback::event( boost::python::ptr(arg0), boost::python::ptr(arg1) );
            }
        }
        
        void default_event( ::osg::NodeVisitor * arg0, ::osg::Drawable * arg1 ) {
            osg::Drawable::EventCallback::event( boost::python::ptr(arg0), boost::python::ptr(arg1) );
        }
    
        virtual bool isSameKindAs( ::osg::Object const * obj ) const  {
            if( bp::override func_isSameKindAs = this->get_override( "isSameKindAs" ) )
                return func_isSameKindAs( boost::python::ptr(obj) );
            else{
                return this->osg::Drawable::EventCallback::isSameKindAs( boost::python::ptr(obj) );
            }
        }
        
        bool default_isSameKindAs( ::osg::Object const * obj ) const  {
            return osg::Drawable::EventCallback::isSameKindAs( boost::python::ptr(obj) );
        }
    
        virtual char const * libraryName(  ) const  {
            if( bp::override func_libraryName = this->get_override( "libraryName" ) )
                return func_libraryName(  );
            else{
                return this->osg::Drawable::EventCallback::libraryName(  );
            }
        }
        
        char const * default_libraryName(  ) const  {
            return osg::Drawable::EventCallback::libraryName( );
        }
    
    };

    struct UpdateCallback_wrapper : osg::Drawable::UpdateCallback, bp::wrapper< osg::Drawable::UpdateCallback > {
    
        virtual char const * className(  ) const  {
            if( bp::override func_className = this->get_override( "className" ) )
                return func_className(  );
            else{
                return this->osg::Drawable::UpdateCallback::className(  );
            }
        }
        
        char const * default_className(  ) const  {
            return osg::Drawable::UpdateCallback::className( );
        }
    
        virtual ::osg::Object * clone( ::osg::CopyOp const & copyop ) const  {
            if( bp::override func_clone = this->get_override( "clone" ) )
                return func_clone( boost::ref(copyop) );
            else{
                return this->osg::Drawable::UpdateCallback::clone( boost::ref(copyop) );
            }
        }
        
        ::osg::Object * default_clone( ::osg::CopyOp const & copyop ) const  {
            return osg::Drawable::UpdateCallback::clone( boost::ref(copyop) );
        }
    
        virtual ::osg::Object * cloneType(  ) const  {
            if( bp::override func_cloneType = this->get_override( "cloneType" ) )
                return func_cloneType(  );
            else{
                return this->osg::Drawable::UpdateCallback::cloneType(  );
            }
        }
        
        ::osg::Object * default_cloneType(  ) const  {
            return osg::Drawable::UpdateCallback::cloneType( );
        }
    
        virtual bool isSameKindAs( ::osg::Object const * obj ) const  {
            if( bp::override func_isSameKindAs = this->get_override( "isSameKindAs" ) )
                return func_isSameKindAs( boost::python::ptr(obj) );
            else{
                return this->osg::Drawable::UpdateCallback::isSameKindAs( boost::python::ptr(obj) );
            }
        }
        
        bool default_isSameKindAs( ::osg::Object const * obj ) const  {
            return osg::Drawable::UpdateCallback::isSameKindAs( boost::python::ptr(obj) );
        }
    
        virtual char const * libraryName(  ) const  {
            if( bp::override func_libraryName = this->get_override( "libraryName" ) )
                return func_libraryName(  );
            else{
                return this->osg::Drawable::UpdateCallback::libraryName(  );
            }
        }
        
        char const * default_libraryName(  ) const  {
            return osg::Drawable::UpdateCallback::libraryName( );
        }
    
        virtual void update( ::osg::NodeVisitor * arg0, ::osg::Drawable * arg1 ) {
            if( bp::override func_update = this->get_override( "update" ) )
                func_update( boost::python::ptr(arg0), boost::python::ptr(arg1) );
            else{
                this->osg::Drawable::UpdateCallback::update( boost::python::ptr(arg0), boost::python::ptr(arg1) );
            }
        }
        
        void default_update( ::osg::NodeVisitor * arg0, ::osg::Drawable * arg1 ) {
            osg::Drawable::UpdateCallback::update( boost::python::ptr(arg0), boost::python::ptr(arg1) );
        }
    
    };

    virtual void accept( ::osg::Drawable::AttributeFunctor & arg0 ) {
        if( bp::override func_accept = this->get_override( "accept" ) )
            func_accept( boost::ref(arg0) );
        else{
            this->osg::Drawable::accept( boost::ref(arg0) );
        }
    }
    
    void default_accept( ::osg::Drawable::AttributeFunctor & arg0 ) {
        osg::Drawable::accept( boost::ref(arg0) );
    }

    virtual void accept( ::osg::Drawable::ConstAttributeFunctor & arg0 ) const  {
        if( bp::override func_accept = this->get_override( "accept" ) )
            func_accept( boost::ref(arg0) );
        else{
            this->osg::Drawable::accept( boost::ref(arg0) );
        }
    }
    
    void default_accept( ::osg::Drawable::ConstAttributeFunctor & arg0 ) const  {
        osg::Drawable::accept( boost::ref(arg0) );
    }

    virtual void accept( ::osg::PrimitiveFunctor & arg0 ) const  {
        if( bp::override func_accept = this->get_override( "accept" ) )
            func_accept( boost::ref(arg0) );
        else{
            this->osg::Drawable::accept( boost::ref(arg0) );
        }
    }
    
    void default_accept( ::osg::PrimitiveFunctor & arg0 ) const  {
        osg::Drawable::accept( boost::ref(arg0) );
    }

    virtual void accept( ::osg::PrimitiveIndexFunctor & arg0 ) const  {
        if( bp::override func_accept = this->get_override( "accept" ) )
            func_accept( boost::ref(arg0) );
        else{
            this->osg::Drawable::accept( boost::ref(arg0) );
        }
    }
    
    void default_accept( ::osg::PrimitiveIndexFunctor & arg0 ) const  {
        osg::Drawable::accept( boost::ref(arg0) );
    }

    virtual ::osg::Geometry * asGeometry(  ) {
        if( bp::override func_asGeometry = this->get_override( "asGeometry" ) )
            return func_asGeometry(  );
        else{
            return this->osg::Drawable::asGeometry(  );
        }
    }
    
    ::osg::Geometry * default_asGeometry(  ) {
        return osg::Drawable::asGeometry( );
    }

    virtual ::osg::Geometry const * asGeometry(  ) const  {
        if( bp::override func_asGeometry = this->get_override( "asGeometry" ) )
            return func_asGeometry(  );
        else{
            return this->osg::Drawable::asGeometry(  );
        }
    }
    
    ::osg::Geometry const * default_asGeometry(  ) const  {
        return osg::Drawable::asGeometry( );
    }

    virtual char const * className(  ) const  {
        if( bp::override func_className = this->get_override( "className" ) )
            return func_className(  );
        else{
            return this->osg::Drawable::className(  );
        }
    }
    
    char const * default_className(  ) const  {
        return osg::Drawable::className( );
    }

    virtual void compileGLObjects( ::osg::RenderInfo & renderInfo ) const  {
        if( bp::override func_compileGLObjects = this->get_override( "compileGLObjects" ) )
            func_compileGLObjects( boost::ref(renderInfo) );
        else{
            this->osg::Drawable::compileGLObjects( boost::ref(renderInfo) );
        }
    }
    
    void default_compileGLObjects( ::osg::RenderInfo & renderInfo ) const  {
        osg::Drawable::compileGLObjects( boost::ref(renderInfo) );
    }

    virtual ::osg::BoundingBox computeBound(  ) const  {
        if( bp::override func_computeBound = this->get_override( "computeBound" ) )
            return func_computeBound(  );
        else{
            return this->osg::Drawable::computeBound(  );
        }
    }
    
    ::osg::BoundingBox default_computeBound(  ) const  {
        return osg::Drawable::computeBound( );
    }

    virtual void computeDataVariance(  ) {
        if( bp::override func_computeDataVariance = this->get_override( "computeDataVariance" ) )
            func_computeDataVariance(  );
        else{
            this->osg::Drawable::computeDataVariance(  );
        }
    }
    
    void default_computeDataVariance(  ) {
        osg::Drawable::computeDataVariance( );
    }

    virtual void dirtyDisplayList(  ) {
        if( bp::override func_dirtyDisplayList = this->get_override( "dirtyDisplayList" ) )
            func_dirtyDisplayList(  );
        else{
            this->osg::Drawable::dirtyDisplayList(  );
        }
    }
    
    void default_dirtyDisplayList(  ) {
        osg::Drawable::dirtyDisplayList( );
    }

    virtual void drawImplementation( ::osg::RenderInfo & renderInfo ) const {
        bp::override func_drawImplementation = this->get_override( "drawImplementation" );
        func_drawImplementation( boost::ref(renderInfo) );
    }

    virtual unsigned int getGLObjectSizeHint(  ) const  {
        if( bp::override func_getGLObjectSizeHint = this->get_override( "getGLObjectSizeHint" ) )
            return func_getGLObjectSizeHint(  );
        else{
            return this->osg::Drawable::getGLObjectSizeHint(  );
        }
    }
    
    unsigned int default_getGLObjectSizeHint(  ) const  {
        return osg::Drawable::getGLObjectSizeHint( );
    }

    virtual bool isSameKindAs( ::osg::Object const * obj ) const  {
        if( bp::override func_isSameKindAs = this->get_override( "isSameKindAs" ) )
            return func_isSameKindAs( boost::python::ptr(obj) );
        else{
            return this->osg::Drawable::isSameKindAs( boost::python::ptr(obj) );
        }
    }
    
    bool default_isSameKindAs( ::osg::Object const * obj ) const  {
        return osg::Drawable::isSameKindAs( boost::python::ptr(obj) );
    }

    virtual char const * libraryName(  ) const  {
        if( bp::override func_libraryName = this->get_override( "libraryName" ) )
            return func_libraryName(  );
        else{
            return this->osg::Drawable::libraryName(  );
        }
    }
    
    char const * default_libraryName(  ) const  {
        return osg::Drawable::libraryName( );
    }

    virtual void resizeGLObjectBuffers( unsigned int maxSize ) {
        if( bp::override func_resizeGLObjectBuffers = this->get_override( "resizeGLObjectBuffers" ) )
            func_resizeGLObjectBuffers( maxSize );
        else{
            this->osg::Drawable::resizeGLObjectBuffers( maxSize );
        }
    }
    
    void default_resizeGLObjectBuffers( unsigned int maxSize ) {
        osg::Drawable::resizeGLObjectBuffers( maxSize );
    }

    virtual void setCullCallback( ::osg::Drawable::CullCallback * cc ) {
        if( bp::override func_setCullCallback = this->get_override( "setCullCallback" ) )
            func_setCullCallback( boost::python::ptr(cc) );
        else{
            this->osg::Drawable::setCullCallback( boost::python::ptr(cc) );
        }
    }
    
    void default_setCullCallback( ::osg::Drawable::CullCallback * cc ) {
        osg::Drawable::setCullCallback( boost::python::ptr(cc) );
    }

    virtual void setDrawCallback( ::osg::Drawable::DrawCallback * dc ) {
        if( bp::override func_setDrawCallback = this->get_override( "setDrawCallback" ) )
            func_setDrawCallback( boost::python::ptr(dc) );
        else{
            this->osg::Drawable::setDrawCallback( boost::python::ptr(dc) );
        }
    }
    
    void default_setDrawCallback( ::osg::Drawable::DrawCallback * dc ) {
        osg::Drawable::setDrawCallback( boost::python::ptr(dc) );
    }

    virtual void setEventCallback( ::osg::Drawable::EventCallback * ac ) {
        if( bp::override func_setEventCallback = this->get_override( "setEventCallback" ) )
            func_setEventCallback( boost::python::ptr(ac) );
        else{
            this->osg::Drawable::setEventCallback( boost::python::ptr(ac) );
        }
    }
    
    void default_setEventCallback( ::osg::Drawable::EventCallback * ac ) {
        osg::Drawable::setEventCallback( boost::python::ptr(ac) );
    }

    virtual void setThreadSafeRefUnref( bool threadSafe ) {
        if( bp::override func_setThreadSafeRefUnref = this->get_override( "setThreadSafeRefUnref" ) )
            func_setThreadSafeRefUnref( threadSafe );
        else{
            this->osg::Drawable::setThreadSafeRefUnref( threadSafe );
        }
    }
    
    void default_setThreadSafeRefUnref( bool threadSafe ) {
        osg::Drawable::setThreadSafeRefUnref( threadSafe );
    }

    virtual void setUpdateCallback( ::osg::Drawable::UpdateCallback * ac ) {
        if( bp::override func_setUpdateCallback = this->get_override( "setUpdateCallback" ) )
            func_setUpdateCallback( boost::python::ptr(ac) );
        else{
            this->osg::Drawable::setUpdateCallback( boost::python::ptr(ac) );
        }
    }
    
    void default_setUpdateCallback( ::osg::Drawable::UpdateCallback * ac ) {
        osg::Drawable::setUpdateCallback( boost::python::ptr(ac) );
    }

    virtual void setUseVertexBufferObjects( bool flag ) {
        if( bp::override func_setUseVertexBufferObjects = this->get_override( "setUseVertexBufferObjects" ) )
            func_setUseVertexBufferObjects( flag );
        else{
            this->osg::Drawable::setUseVertexBufferObjects( flag );
        }
    }
    
    void default_setUseVertexBufferObjects( bool flag ) {
        osg::Drawable::setUseVertexBufferObjects( flag );
    }

    virtual bool supports( ::osg::Drawable::AttributeFunctor const & arg0 ) const  {
        if( bp::override func_supports = this->get_override( "supports" ) )
            return func_supports( boost::ref(arg0) );
        else{
            return this->osg::Drawable::supports( boost::ref(arg0) );
        }
    }
    
    bool default_supports( ::osg::Drawable::AttributeFunctor const & arg0 ) const  {
        return osg::Drawable::supports( boost::ref(arg0) );
    }

    virtual bool supports( ::osg::Drawable::ConstAttributeFunctor const & arg0 ) const  {
        if( bp::override func_supports = this->get_override( "supports" ) )
            return func_supports( boost::ref(arg0) );
        else{
            return this->osg::Drawable::supports( boost::ref(arg0) );
        }
    }
    
    bool default_supports( ::osg::Drawable::ConstAttributeFunctor const & arg0 ) const  {
        return osg::Drawable::supports( boost::ref(arg0) );
    }

    virtual bool supports( ::osg::PrimitiveFunctor const & arg0 ) const  {
        if( bp::override func_supports = this->get_override( "supports" ) )
            return func_supports( boost::ref(arg0) );
        else{
            return this->osg::Drawable::supports( boost::ref(arg0) );
        }
    }
    
    bool default_supports( ::osg::PrimitiveFunctor const & arg0 ) const  {
        return osg::Drawable::supports( boost::ref(arg0) );
    }

    virtual bool supports( ::osg::PrimitiveIndexFunctor const & arg0 ) const  {
        if( bp::override func_supports = this->get_override( "supports" ) )
            return func_supports( boost::ref(arg0) );
        else{
            return this->osg::Drawable::supports( boost::ref(arg0) );
        }
    }
    
    bool default_supports( ::osg::PrimitiveIndexFunctor const & arg0 ) const  {
        return osg::Drawable::supports( boost::ref(arg0) );
    }

    virtual ::osg::Object * clone( ::osg::CopyOp const & arg0 ) const {
        bp::override func_clone = this->get_override( "clone" );
        return func_clone( boost::ref(arg0) );
    }

    virtual ::osg::Object * cloneType(  ) const {
        bp::override func_cloneType = this->get_override( "cloneType" );
        return func_cloneType(  );
    }

};

void register_Drawable_class(){

    { //::osg::Drawable
        typedef bp::class_< Drawable_wrapper, bp::bases< osg::Object >, osg::ref_ptr< ::osg::Drawable >, boost::noncopyable > Drawable_exposer_t;
        Drawable_exposer_t Drawable_exposer = Drawable_exposer_t( "Drawable", "\n Pure virtual base class for drawable geometry. In OSG, everything that can\n  be rendered is implemented as a class derived from  Drawable. The\n   Drawable class contains no drawing primitives, since these are provided\n  by subclasses such as  osg::Geometry.\n  <p>Notice that a  Drawable is not a  Node, and therefore it cannot be\n  directly added to a scene graph. Instead, <tt>Drawable</tt>s are attached to\n  <tt>Geode</tt>s, which are scene graph nodes.\n  <p>The OpenGL state that must be used when rendering a  Drawable is\n  represented by a  StateSet. Since a  Drawable has a reference\n  ( osg::ref_ptr) to a  StateSet, <tt>StateSet</tt>s can be shared between\n  different <tt>Drawable</tt>s. In fact, sharing <tt>StateSet</tt>s is a good\n  way to improve performance, since this allows OSG to reduce the number of\n  expensive changes in the OpenGL state.\n  <p>Finally, <tt>Drawable</tt>s can also be shared between different\n  <tt>Geode</tt>s, so that the same geometry (loaded to memory just once) can\n  be used in different parts of the scene graph.\n", bp::no_init );
        bp::scope Drawable_scope( Drawable_exposer );
        bp::enum_< osg::Drawable::AttributeTypes>("AttributeTypes")
            .value("VERTICES", osg::Drawable::VERTICES)
            .value("WEIGHTS", osg::Drawable::WEIGHTS)
            .value("NORMALS", osg::Drawable::NORMALS)
            .value("COLORS", osg::Drawable::COLORS)
            .value("SECONDARY_COLORS", osg::Drawable::SECONDARY_COLORS)
            .value("FOG_COORDS", osg::Drawable::FOG_COORDS)
            .value("ATTRIBUTE_6", osg::Drawable::ATTRIBUTE_6)
            .value("ATTRIBUTE_7", osg::Drawable::ATTRIBUTE_7)
            .value("TEXTURE_COORDS", osg::Drawable::TEXTURE_COORDS)
            .value("TEXTURE_COORDS_0", osg::Drawable::TEXTURE_COORDS_0)
            .value("TEXTURE_COORDS_1", osg::Drawable::TEXTURE_COORDS_1)
            .value("TEXTURE_COORDS_2", osg::Drawable::TEXTURE_COORDS_2)
            .value("TEXTURE_COORDS_3", osg::Drawable::TEXTURE_COORDS_3)
            .value("TEXTURE_COORDS_4", osg::Drawable::TEXTURE_COORDS_4)
            .value("TEXTURE_COORDS_5", osg::Drawable::TEXTURE_COORDS_5)
            .value("TEXTURE_COORDS_6", osg::Drawable::TEXTURE_COORDS_6)
            .value("TEXTURE_COORDS_7", osg::Drawable::TEXTURE_COORDS_7)
            .export_values()
            ;
        bp::class_< Drawable_wrapper::AttributeFunctor_wrapper >( "AttributeFunctor" )    
            .def( 
                "apply"
                , (void ( ::osg::Drawable::AttributeFunctor::* )( unsigned int,unsigned int,::GLbyte * ) )(&::osg::Drawable::AttributeFunctor::apply)
                , (void ( Drawable_wrapper::AttributeFunctor_wrapper::* )( unsigned int,unsigned int,::GLbyte * ) )(&Drawable_wrapper::AttributeFunctor_wrapper::default_apply)
                , ( bp::arg("arg0"), bp::arg("arg1"), bp::arg("arg2") ) )    
            .def( 
                "apply"
                , (void ( ::osg::Drawable::AttributeFunctor::* )( unsigned int,unsigned int,::GLshort * ) )(&::osg::Drawable::AttributeFunctor::apply)
                , (void ( Drawable_wrapper::AttributeFunctor_wrapper::* )( unsigned int,unsigned int,::GLshort * ) )(&Drawable_wrapper::AttributeFunctor_wrapper::default_apply)
                , ( bp::arg("arg0"), bp::arg("arg1"), bp::arg("arg2") ) )    
            .def( 
                "apply"
                , (void ( ::osg::Drawable::AttributeFunctor::* )( unsigned int,unsigned int,::GLint * ) )(&::osg::Drawable::AttributeFunctor::apply)
                , (void ( Drawable_wrapper::AttributeFunctor_wrapper::* )( unsigned int,unsigned int,::GLint * ) )(&Drawable_wrapper::AttributeFunctor_wrapper::default_apply)
                , ( bp::arg("arg0"), bp::arg("arg1"), bp::arg("arg2") ) )    
            .def( 
                "apply"
                , (void ( ::osg::Drawable::AttributeFunctor::* )( unsigned int,unsigned int,::GLubyte * ) )(&::osg::Drawable::AttributeFunctor::apply)
                , (void ( Drawable_wrapper::AttributeFunctor_wrapper::* )( unsigned int,unsigned int,::GLubyte * ) )(&Drawable_wrapper::AttributeFunctor_wrapper::default_apply)
                , ( bp::arg("arg0"), bp::arg("arg1"), bp::arg("arg2") ) )    
            .def( 
                "apply"
                , (void ( ::osg::Drawable::AttributeFunctor::* )( unsigned int,unsigned int,::GLushort * ) )(&::osg::Drawable::AttributeFunctor::apply)
                , (void ( Drawable_wrapper::AttributeFunctor_wrapper::* )( unsigned int,unsigned int,::GLushort * ) )(&Drawable_wrapper::AttributeFunctor_wrapper::default_apply)
                , ( bp::arg("arg0"), bp::arg("arg1"), bp::arg("arg2") ) )    
            .def( 
                "apply"
                , (void ( ::osg::Drawable::AttributeFunctor::* )( unsigned int,unsigned int,::GLuint * ) )(&::osg::Drawable::AttributeFunctor::apply)
                , (void ( Drawable_wrapper::AttributeFunctor_wrapper::* )( unsigned int,unsigned int,::GLuint * ) )(&Drawable_wrapper::AttributeFunctor_wrapper::default_apply)
                , ( bp::arg("arg0"), bp::arg("arg1"), bp::arg("arg2") ) )    
            .def( 
                "apply"
                , (void ( ::osg::Drawable::AttributeFunctor::* )( unsigned int,unsigned int,float * ) )(&::osg::Drawable::AttributeFunctor::apply)
                , (void ( Drawable_wrapper::AttributeFunctor_wrapper::* )( unsigned int,unsigned int,float * ) )(&Drawable_wrapper::AttributeFunctor_wrapper::default_apply)
                , ( bp::arg("arg0"), bp::arg("arg1"), bp::arg("arg2") ) )    
            .def( 
                "apply"
                , (void ( ::osg::Drawable::AttributeFunctor::* )( unsigned int,unsigned int,::osg::Vec2 * ) )(&::osg::Drawable::AttributeFunctor::apply)
                , (void ( Drawable_wrapper::AttributeFunctor_wrapper::* )( unsigned int,unsigned int,::osg::Vec2 * ) )(&Drawable_wrapper::AttributeFunctor_wrapper::default_apply)
                , ( bp::arg("arg0"), bp::arg("arg1"), bp::arg("arg2") ) )    
            .def( 
                "apply"
                , (void ( ::osg::Drawable::AttributeFunctor::* )( unsigned int,unsigned int,::osg::Vec3 * ) )(&::osg::Drawable::AttributeFunctor::apply)
                , (void ( Drawable_wrapper::AttributeFunctor_wrapper::* )( unsigned int,unsigned int,::osg::Vec3 * ) )(&Drawable_wrapper::AttributeFunctor_wrapper::default_apply)
                , ( bp::arg("arg0"), bp::arg("arg1"), bp::arg("arg2") ) )    
            .def( 
                "apply"
                , (void ( ::osg::Drawable::AttributeFunctor::* )( unsigned int,unsigned int,::osg::Vec4 * ) )(&::osg::Drawable::AttributeFunctor::apply)
                , (void ( Drawable_wrapper::AttributeFunctor_wrapper::* )( unsigned int,unsigned int,::osg::Vec4 * ) )(&Drawable_wrapper::AttributeFunctor_wrapper::default_apply)
                , ( bp::arg("arg0"), bp::arg("arg1"), bp::arg("arg2") ) )    
            .def( 
                "apply"
                , (void ( ::osg::Drawable::AttributeFunctor::* )( unsigned int,unsigned int,::osg::Vec4ub * ) )(&::osg::Drawable::AttributeFunctor::apply)
                , (void ( Drawable_wrapper::AttributeFunctor_wrapper::* )( unsigned int,unsigned int,::osg::Vec4ub * ) )(&Drawable_wrapper::AttributeFunctor_wrapper::default_apply)
                , ( bp::arg("arg0"), bp::arg("arg1"), bp::arg("arg2") ) )    
            .def( 
                "apply"
                , (void ( ::osg::Drawable::AttributeFunctor::* )( unsigned int,unsigned int,double * ) )(&::osg::Drawable::AttributeFunctor::apply)
                , (void ( Drawable_wrapper::AttributeFunctor_wrapper::* )( unsigned int,unsigned int,double * ) )(&Drawable_wrapper::AttributeFunctor_wrapper::default_apply)
                , ( bp::arg("arg0"), bp::arg("arg1"), bp::arg("arg2") ) )    
            .def( 
                "apply"
                , (void ( ::osg::Drawable::AttributeFunctor::* )( unsigned int,unsigned int,::osg::Vec2d * ) )(&::osg::Drawable::AttributeFunctor::apply)
                , (void ( Drawable_wrapper::AttributeFunctor_wrapper::* )( unsigned int,unsigned int,::osg::Vec2d * ) )(&Drawable_wrapper::AttributeFunctor_wrapper::default_apply)
                , ( bp::arg("arg0"), bp::arg("arg1"), bp::arg("arg2") ) )    
            .def( 
                "apply"
                , (void ( ::osg::Drawable::AttributeFunctor::* )( unsigned int,unsigned int,::osg::Vec3d * ) )(&::osg::Drawable::AttributeFunctor::apply)
                , (void ( Drawable_wrapper::AttributeFunctor_wrapper::* )( unsigned int,unsigned int,::osg::Vec3d * ) )(&Drawable_wrapper::AttributeFunctor_wrapper::default_apply)
                , ( bp::arg("arg0"), bp::arg("arg1"), bp::arg("arg2") ) )    
            .def( 
                "apply"
                , (void ( ::osg::Drawable::AttributeFunctor::* )( unsigned int,unsigned int,::osg::Vec4d * ) )(&::osg::Drawable::AttributeFunctor::apply)
                , (void ( Drawable_wrapper::AttributeFunctor_wrapper::* )( unsigned int,unsigned int,::osg::Vec4d * ) )(&Drawable_wrapper::AttributeFunctor_wrapper::default_apply)
                , ( bp::arg("arg0"), bp::arg("arg1"), bp::arg("arg2") ) );
        bp::class_< Drawable_wrapper::ConstAttributeFunctor_wrapper >( "ConstAttributeFunctor", "\n accept an AttributeFunctor and call its methods to tell it about the internal attributes that this Drawable has.\n return true if functor handled by drawable,\n return false on failure of drawable to generate functor calls.\n" )    
            .def( 
                "apply"
                , (void ( ::osg::Drawable::ConstAttributeFunctor::* )( unsigned int,unsigned int,::GLbyte const * ) )(&::osg::Drawable::ConstAttributeFunctor::apply)
                , (void ( Drawable_wrapper::ConstAttributeFunctor_wrapper::* )( unsigned int,unsigned int,::GLbyte const * ) )(&Drawable_wrapper::ConstAttributeFunctor_wrapper::default_apply)
                , ( bp::arg("arg0"), bp::arg("arg1"), bp::arg("arg2") ) )    
            .def( 
                "apply"
                , (void ( ::osg::Drawable::ConstAttributeFunctor::* )( unsigned int,unsigned int,::GLshort const * ) )(&::osg::Drawable::ConstAttributeFunctor::apply)
                , (void ( Drawable_wrapper::ConstAttributeFunctor_wrapper::* )( unsigned int,unsigned int,::GLshort const * ) )(&Drawable_wrapper::ConstAttributeFunctor_wrapper::default_apply)
                , ( bp::arg("arg0"), bp::arg("arg1"), bp::arg("arg2") ) )    
            .def( 
                "apply"
                , (void ( ::osg::Drawable::ConstAttributeFunctor::* )( unsigned int,unsigned int,::GLint const * ) )(&::osg::Drawable::ConstAttributeFunctor::apply)
                , (void ( Drawable_wrapper::ConstAttributeFunctor_wrapper::* )( unsigned int,unsigned int,::GLint const * ) )(&Drawable_wrapper::ConstAttributeFunctor_wrapper::default_apply)
                , ( bp::arg("arg0"), bp::arg("arg1"), bp::arg("arg2") ) )    
            .def( 
                "apply"
                , (void ( ::osg::Drawable::ConstAttributeFunctor::* )( unsigned int,unsigned int,::GLubyte const * ) )(&::osg::Drawable::ConstAttributeFunctor::apply)
                , (void ( Drawable_wrapper::ConstAttributeFunctor_wrapper::* )( unsigned int,unsigned int,::GLubyte const * ) )(&Drawable_wrapper::ConstAttributeFunctor_wrapper::default_apply)
                , ( bp::arg("arg0"), bp::arg("arg1"), bp::arg("arg2") ) )    
            .def( 
                "apply"
                , (void ( ::osg::Drawable::ConstAttributeFunctor::* )( unsigned int,unsigned int,::GLushort const * ) )(&::osg::Drawable::ConstAttributeFunctor::apply)
                , (void ( Drawable_wrapper::ConstAttributeFunctor_wrapper::* )( unsigned int,unsigned int,::GLushort const * ) )(&Drawable_wrapper::ConstAttributeFunctor_wrapper::default_apply)
                , ( bp::arg("arg0"), bp::arg("arg1"), bp::arg("arg2") ) )    
            .def( 
                "apply"
                , (void ( ::osg::Drawable::ConstAttributeFunctor::* )( unsigned int,unsigned int,::GLuint const * ) )(&::osg::Drawable::ConstAttributeFunctor::apply)
                , (void ( Drawable_wrapper::ConstAttributeFunctor_wrapper::* )( unsigned int,unsigned int,::GLuint const * ) )(&Drawable_wrapper::ConstAttributeFunctor_wrapper::default_apply)
                , ( bp::arg("arg0"), bp::arg("arg1"), bp::arg("arg2") ) )    
            .def( 
                "apply"
                , (void ( ::osg::Drawable::ConstAttributeFunctor::* )( unsigned int,unsigned int,float const * ) )(&::osg::Drawable::ConstAttributeFunctor::apply)
                , (void ( Drawable_wrapper::ConstAttributeFunctor_wrapper::* )( unsigned int,unsigned int,float const * ) )(&Drawable_wrapper::ConstAttributeFunctor_wrapper::default_apply)
                , ( bp::arg("arg0"), bp::arg("arg1"), bp::arg("arg2") ) )    
            .def( 
                "apply"
                , (void ( ::osg::Drawable::ConstAttributeFunctor::* )( unsigned int,unsigned int,::osg::Vec2 const * ) )(&::osg::Drawable::ConstAttributeFunctor::apply)
                , (void ( Drawable_wrapper::ConstAttributeFunctor_wrapper::* )( unsigned int,unsigned int,::osg::Vec2 const * ) )(&Drawable_wrapper::ConstAttributeFunctor_wrapper::default_apply)
                , ( bp::arg("arg0"), bp::arg("arg1"), bp::arg("arg2") ) )    
            .def( 
                "apply"
                , (void ( ::osg::Drawable::ConstAttributeFunctor::* )( unsigned int,unsigned int,::osg::Vec3 const * ) )(&::osg::Drawable::ConstAttributeFunctor::apply)
                , (void ( Drawable_wrapper::ConstAttributeFunctor_wrapper::* )( unsigned int,unsigned int,::osg::Vec3 const * ) )(&Drawable_wrapper::ConstAttributeFunctor_wrapper::default_apply)
                , ( bp::arg("arg0"), bp::arg("arg1"), bp::arg("arg2") ) )    
            .def( 
                "apply"
                , (void ( ::osg::Drawable::ConstAttributeFunctor::* )( unsigned int,unsigned int,::osg::Vec4 const * ) )(&::osg::Drawable::ConstAttributeFunctor::apply)
                , (void ( Drawable_wrapper::ConstAttributeFunctor_wrapper::* )( unsigned int,unsigned int,::osg::Vec4 const * ) )(&Drawable_wrapper::ConstAttributeFunctor_wrapper::default_apply)
                , ( bp::arg("arg0"), bp::arg("arg1"), bp::arg("arg2") ) )    
            .def( 
                "apply"
                , (void ( ::osg::Drawable::ConstAttributeFunctor::* )( unsigned int,unsigned int,::osg::Vec4ub const * ) )(&::osg::Drawable::ConstAttributeFunctor::apply)
                , (void ( Drawable_wrapper::ConstAttributeFunctor_wrapper::* )( unsigned int,unsigned int,::osg::Vec4ub const * ) )(&Drawable_wrapper::ConstAttributeFunctor_wrapper::default_apply)
                , ( bp::arg("arg0"), bp::arg("arg1"), bp::arg("arg2") ) )    
            .def( 
                "apply"
                , (void ( ::osg::Drawable::ConstAttributeFunctor::* )( unsigned int,unsigned int,double const * ) )(&::osg::Drawable::ConstAttributeFunctor::apply)
                , (void ( Drawable_wrapper::ConstAttributeFunctor_wrapper::* )( unsigned int,unsigned int,double const * ) )(&Drawable_wrapper::ConstAttributeFunctor_wrapper::default_apply)
                , ( bp::arg("arg0"), bp::arg("arg1"), bp::arg("arg2") ) )    
            .def( 
                "apply"
                , (void ( ::osg::Drawable::ConstAttributeFunctor::* )( unsigned int,unsigned int,::osg::Vec2d const * ) )(&::osg::Drawable::ConstAttributeFunctor::apply)
                , (void ( Drawable_wrapper::ConstAttributeFunctor_wrapper::* )( unsigned int,unsigned int,::osg::Vec2d const * ) )(&Drawable_wrapper::ConstAttributeFunctor_wrapper::default_apply)
                , ( bp::arg("arg0"), bp::arg("arg1"), bp::arg("arg2") ) )    
            .def( 
                "apply"
                , (void ( ::osg::Drawable::ConstAttributeFunctor::* )( unsigned int,unsigned int,::osg::Vec3d const * ) )(&::osg::Drawable::ConstAttributeFunctor::apply)
                , (void ( Drawable_wrapper::ConstAttributeFunctor_wrapper::* )( unsigned int,unsigned int,::osg::Vec3d const * ) )(&Drawable_wrapper::ConstAttributeFunctor_wrapper::default_apply)
                , ( bp::arg("arg0"), bp::arg("arg1"), bp::arg("arg2") ) )    
            .def( 
                "apply"
                , (void ( ::osg::Drawable::ConstAttributeFunctor::* )( unsigned int,unsigned int,::osg::Vec4d const * ) )(&::osg::Drawable::ConstAttributeFunctor::apply)
                , (void ( Drawable_wrapper::ConstAttributeFunctor_wrapper::* )( unsigned int,unsigned int,::osg::Vec4d const * ) )(&Drawable_wrapper::ConstAttributeFunctor_wrapper::default_apply)
                , ( bp::arg("arg0"), bp::arg("arg1"), bp::arg("arg2") ) );
        bp::class_< Drawable_wrapper::CullCallback_wrapper, bp::bases< osg::Object >, osg::ref_ptr< Drawable_wrapper::CullCallback_wrapper >, boost::noncopyable >( "CullCallback" )    
            .def( 
                "className"
                , (char const * ( ::osg::Drawable::CullCallback::* )(  ) const)(&::osg::Drawable::CullCallback::className)
                , (char const * ( Drawable_wrapper::CullCallback_wrapper::* )(  ) const)(&Drawable_wrapper::CullCallback_wrapper::default_className) )    
            .def( 
                "clone"
                , (::osg::Object * ( ::osg::Drawable::CullCallback::* )( ::osg::CopyOp const & ) const)(&::osg::Drawable::CullCallback::clone)
                , (::osg::Object * ( Drawable_wrapper::CullCallback_wrapper::* )( ::osg::CopyOp const & ) const)(&Drawable_wrapper::CullCallback_wrapper::default_clone)
                , ( bp::arg("copyop") )
                , bp::return_value_policy< bp::reference_existing_object >() )    
            .def( 
                "cloneType"
                , (::osg::Object * ( ::osg::Drawable::CullCallback::* )(  ) const)(&::osg::Drawable::CullCallback::cloneType)
                , (::osg::Object * ( Drawable_wrapper::CullCallback_wrapper::* )(  ) const)(&Drawable_wrapper::CullCallback_wrapper::default_cloneType)
                , bp::return_value_policy< bp::reference_existing_object >() )    
            .def( 
                "cull"
                , (bool ( ::osg::Drawable::CullCallback::* )( ::osg::NodeVisitor *,::osg::Drawable *,::osg::State * ) const)(&::osg::Drawable::CullCallback::cull)
                , (bool ( Drawable_wrapper::CullCallback_wrapper::* )( ::osg::NodeVisitor *,::osg::Drawable *,::osg::State * ) const)(&Drawable_wrapper::CullCallback_wrapper::default_cull)
                , ( bp::arg("arg0"), bp::arg("arg1"), bp::arg("arg2") ) )    
            .def( 
                "cull"
                , (bool ( ::osg::Drawable::CullCallback::* )( ::osg::NodeVisitor *,::osg::Drawable *,::osg::RenderInfo * ) const)(&::osg::Drawable::CullCallback::cull)
                , (bool ( Drawable_wrapper::CullCallback_wrapper::* )( ::osg::NodeVisitor *,::osg::Drawable *,::osg::RenderInfo * ) const)(&Drawable_wrapper::CullCallback_wrapper::default_cull)
                , ( bp::arg("nv"), bp::arg("drawable"), bp::arg("renderInfo") ) )    
            .def( 
                "isSameKindAs"
                , (bool ( ::osg::Drawable::CullCallback::* )( ::osg::Object const * ) const)(&::osg::Drawable::CullCallback::isSameKindAs)
                , (bool ( Drawable_wrapper::CullCallback_wrapper::* )( ::osg::Object const * ) const)(&Drawable_wrapper::CullCallback_wrapper::default_isSameKindAs)
                , ( bp::arg("obj") ) )    
            .def( 
                "libraryName"
                , (char const * ( ::osg::Drawable::CullCallback::* )(  ) const)(&::osg::Drawable::CullCallback::libraryName)
                , (char const * ( Drawable_wrapper::CullCallback_wrapper::* )(  ) const)(&Drawable_wrapper::CullCallback_wrapper::default_libraryName) );
        bp::class_< Drawable_wrapper::DrawCallback_wrapper, bp::bases< osg::Object >, osg::ref_ptr< Drawable_wrapper::DrawCallback_wrapper >, boost::noncopyable >( "DrawCallback", "\n Callback attached to an Drawable which allows the users to customize the drawing of an exist Drawable object.\n The draw callback is implement as a replacement to the Drawables own drawImplementation() method, if the\n the user intends to decorate the existing draw code then simple call the drawable->drawImplementation() from\n with the callbacks drawImplementation() method. This allows the users to do both pre and post callbacks\n without fuss and can even disable the inner draw if required.\n" )    
            .def( 
                "className"
                , (char const * ( ::osg::Drawable::DrawCallback::* )(  ) const)(&::osg::Drawable::DrawCallback::className)
                , (char const * ( Drawable_wrapper::DrawCallback_wrapper::* )(  ) const)(&Drawable_wrapper::DrawCallback_wrapper::default_className) )    
            .def( 
                "clone"
                , (::osg::Object * ( ::osg::Drawable::DrawCallback::* )( ::osg::CopyOp const & ) const)(&::osg::Drawable::DrawCallback::clone)
                , (::osg::Object * ( Drawable_wrapper::DrawCallback_wrapper::* )( ::osg::CopyOp const & ) const)(&Drawable_wrapper::DrawCallback_wrapper::default_clone)
                , ( bp::arg("copyop") )
                , bp::return_value_policy< bp::reference_existing_object >() )    
            .def( 
                "cloneType"
                , (::osg::Object * ( ::osg::Drawable::DrawCallback::* )(  ) const)(&::osg::Drawable::DrawCallback::cloneType)
                , (::osg::Object * ( Drawable_wrapper::DrawCallback_wrapper::* )(  ) const)(&Drawable_wrapper::DrawCallback_wrapper::default_cloneType)
                , bp::return_value_policy< bp::reference_existing_object >() )    
            .def( 
                "drawImplementation"
                , (void ( ::osg::Drawable::DrawCallback::* )( ::osg::RenderInfo &,::osg::Drawable const * ) const)(&::osg::Drawable::DrawCallback::drawImplementation)
                , (void ( Drawable_wrapper::DrawCallback_wrapper::* )( ::osg::RenderInfo &,::osg::Drawable const * ) const)(&Drawable_wrapper::DrawCallback_wrapper::default_drawImplementation)
                , ( bp::arg("arg0"), bp::arg("arg1") ) )    
            .def( 
                "isSameKindAs"
                , (bool ( ::osg::Drawable::DrawCallback::* )( ::osg::Object const * ) const)(&::osg::Drawable::DrawCallback::isSameKindAs)
                , (bool ( Drawable_wrapper::DrawCallback_wrapper::* )( ::osg::Object const * ) const)(&Drawable_wrapper::DrawCallback_wrapper::default_isSameKindAs)
                , ( bp::arg("obj") ) )    
            .def( 
                "libraryName"
                , (char const * ( ::osg::Drawable::DrawCallback::* )(  ) const)(&::osg::Drawable::DrawCallback::libraryName)
                , (char const * ( Drawable_wrapper::DrawCallback_wrapper::* )(  ) const)(&Drawable_wrapper::DrawCallback_wrapper::default_libraryName) );
        bp::class_< Drawable_wrapper::EventCallback_wrapper, bp::bases< osg::Object >, osg::ref_ptr< Drawable_wrapper::EventCallback_wrapper >, boost::noncopyable >( "EventCallback" )    
            .def( 
                "className"
                , (char const * ( ::osg::Drawable::EventCallback::* )(  ) const)(&::osg::Drawable::EventCallback::className)
                , (char const * ( Drawable_wrapper::EventCallback_wrapper::* )(  ) const)(&Drawable_wrapper::EventCallback_wrapper::default_className) )    
            .def( 
                "clone"
                , (::osg::Object * ( ::osg::Drawable::EventCallback::* )( ::osg::CopyOp const & ) const)(&::osg::Drawable::EventCallback::clone)
                , (::osg::Object * ( Drawable_wrapper::EventCallback_wrapper::* )( ::osg::CopyOp const & ) const)(&Drawable_wrapper::EventCallback_wrapper::default_clone)
                , ( bp::arg("copyop") )
                , bp::return_value_policy< bp::reference_existing_object >() )    
            .def( 
                "cloneType"
                , (::osg::Object * ( ::osg::Drawable::EventCallback::* )(  ) const)(&::osg::Drawable::EventCallback::cloneType)
                , (::osg::Object * ( Drawable_wrapper::EventCallback_wrapper::* )(  ) const)(&Drawable_wrapper::EventCallback_wrapper::default_cloneType)
                , bp::return_value_policy< bp::reference_existing_object >() )    
            .def( 
                "event"
                , (void ( ::osg::Drawable::EventCallback::* )( ::osg::NodeVisitor *,::osg::Drawable * ) )(&::osg::Drawable::EventCallback::event)
                , (void ( Drawable_wrapper::EventCallback_wrapper::* )( ::osg::NodeVisitor *,::osg::Drawable * ) )(&Drawable_wrapper::EventCallback_wrapper::default_event)
                , ( bp::arg("arg0"), bp::arg("arg1") ) )    
            .def( 
                "isSameKindAs"
                , (bool ( ::osg::Drawable::EventCallback::* )( ::osg::Object const * ) const)(&::osg::Drawable::EventCallback::isSameKindAs)
                , (bool ( Drawable_wrapper::EventCallback_wrapper::* )( ::osg::Object const * ) const)(&Drawable_wrapper::EventCallback_wrapper::default_isSameKindAs)
                , ( bp::arg("obj") ) )    
            .def( 
                "libraryName"
                , (char const * ( ::osg::Drawable::EventCallback::* )(  ) const)(&::osg::Drawable::EventCallback::libraryName)
                , (char const * ( Drawable_wrapper::EventCallback_wrapper::* )(  ) const)(&Drawable_wrapper::EventCallback_wrapper::default_libraryName) );
        bp::class_< Drawable_wrapper::UpdateCallback_wrapper, bp::bases< osg::Object >, osg::ref_ptr< Drawable_wrapper::UpdateCallback_wrapper >, boost::noncopyable >( "UpdateCallback" )    
            .def( 
                "className"
                , (char const * ( ::osg::Drawable::UpdateCallback::* )(  ) const)(&::osg::Drawable::UpdateCallback::className)
                , (char const * ( Drawable_wrapper::UpdateCallback_wrapper::* )(  ) const)(&Drawable_wrapper::UpdateCallback_wrapper::default_className) )    
            .def( 
                "clone"
                , (::osg::Object * ( ::osg::Drawable::UpdateCallback::* )( ::osg::CopyOp const & ) const)(&::osg::Drawable::UpdateCallback::clone)
                , (::osg::Object * ( Drawable_wrapper::UpdateCallback_wrapper::* )( ::osg::CopyOp const & ) const)(&Drawable_wrapper::UpdateCallback_wrapper::default_clone)
                , ( bp::arg("copyop") )
                , bp::return_value_policy< bp::reference_existing_object >() )    
            .def( 
                "cloneType"
                , (::osg::Object * ( ::osg::Drawable::UpdateCallback::* )(  ) const)(&::osg::Drawable::UpdateCallback::cloneType)
                , (::osg::Object * ( Drawable_wrapper::UpdateCallback_wrapper::* )(  ) const)(&Drawable_wrapper::UpdateCallback_wrapper::default_cloneType)
                , bp::return_value_policy< bp::reference_existing_object >() )    
            .def( 
                "isSameKindAs"
                , (bool ( ::osg::Drawable::UpdateCallback::* )( ::osg::Object const * ) const)(&::osg::Drawable::UpdateCallback::isSameKindAs)
                , (bool ( Drawable_wrapper::UpdateCallback_wrapper::* )( ::osg::Object const * ) const)(&Drawable_wrapper::UpdateCallback_wrapper::default_isSameKindAs)
                , ( bp::arg("obj") ) )    
            .def( 
                "libraryName"
                , (char const * ( ::osg::Drawable::UpdateCallback::* )(  ) const)(&::osg::Drawable::UpdateCallback::libraryName)
                , (char const * ( Drawable_wrapper::UpdateCallback_wrapper::* )(  ) const)(&Drawable_wrapper::UpdateCallback_wrapper::default_libraryName) )    
            .def( 
                "update"
                , (void ( ::osg::Drawable::UpdateCallback::* )( ::osg::NodeVisitor *,::osg::Drawable * ) )(&::osg::Drawable::UpdateCallback::update)
                , (void ( Drawable_wrapper::UpdateCallback_wrapper::* )( ::osg::NodeVisitor *,::osg::Drawable * ) )(&Drawable_wrapper::UpdateCallback_wrapper::default_update)
                , ( bp::arg("arg0"), bp::arg("arg1") ) );
        { //::osg::Drawable::accept
        
            typedef void ( ::osg::Drawable::*accept_function_type )( ::osg::Drawable::AttributeFunctor & ) ;
            typedef void ( Drawable_wrapper::*default_accept_function_type )( ::osg::Drawable::AttributeFunctor & ) ;
            
            Drawable_exposer.def( 
                "accept"
                , accept_function_type(&::osg::Drawable::accept)
                , default_accept_function_type(&Drawable_wrapper::default_accept)
                , ( bp::arg("arg0") ) );
        
        }
        { //::osg::Drawable::accept
        
            typedef void ( ::osg::Drawable::*accept_function_type )( ::osg::Drawable::ConstAttributeFunctor & ) const;
            typedef void ( Drawable_wrapper::*default_accept_function_type )( ::osg::Drawable::ConstAttributeFunctor & ) const;
            
            Drawable_exposer.def( 
                "accept"
                , accept_function_type(&::osg::Drawable::accept)
                , default_accept_function_type(&Drawable_wrapper::default_accept)
                , ( bp::arg("arg0") ) );
        
        }
        { //::osg::Drawable::accept
        
            typedef void ( ::osg::Drawable::*accept_function_type )( ::osg::PrimitiveFunctor & ) const;
            typedef void ( Drawable_wrapper::*default_accept_function_type )( ::osg::PrimitiveFunctor & ) const;
            
            Drawable_exposer.def( 
                "accept"
                , accept_function_type(&::osg::Drawable::accept)
                , default_accept_function_type(&Drawable_wrapper::default_accept)
                , ( bp::arg("arg0") ) );
        
        }
        { //::osg::Drawable::accept
        
            typedef void ( ::osg::Drawable::*accept_function_type )( ::osg::PrimitiveIndexFunctor & ) const;
            typedef void ( Drawable_wrapper::*default_accept_function_type )( ::osg::PrimitiveIndexFunctor & ) const;
            
            Drawable_exposer.def( 
                "accept"
                , accept_function_type(&::osg::Drawable::accept)
                , default_accept_function_type(&Drawable_wrapper::default_accept)
                , ( bp::arg("arg0") ) );
        
        }
        { //::osg::Drawable::asGeometry
        
            typedef ::osg::Geometry * ( ::osg::Drawable::*asGeometry_function_type )(  ) ;
            typedef ::osg::Geometry * ( Drawable_wrapper::*default_asGeometry_function_type )(  ) ;
            
            Drawable_exposer.def( 
                "asGeometry"
                , asGeometry_function_type(&::osg::Drawable::asGeometry)
                , default_asGeometry_function_type(&Drawable_wrapper::default_asGeometry)
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::Drawable::asGeometry
        
            typedef ::osg::Geometry const * ( ::osg::Drawable::*asGeometry_function_type )(  ) const;
            typedef ::osg::Geometry const * ( Drawable_wrapper::*default_asGeometry_function_type )(  ) const;
            
            Drawable_exposer.def( 
                "asGeometry"
                , asGeometry_function_type(&::osg::Drawable::asGeometry)
                , default_asGeometry_function_type(&Drawable_wrapper::default_asGeometry)
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::Drawable::className
        
            typedef char const * ( ::osg::Drawable::*className_function_type )(  ) const;
            typedef char const * ( Drawable_wrapper::*default_className_function_type )(  ) const;
            
            Drawable_exposer.def( 
                "className"
                , className_function_type(&::osg::Drawable::className)
                , default_className_function_type(&Drawable_wrapper::default_className) );
        
        }
        { //::osg::Drawable::compileGLObjects
        
            typedef void ( ::osg::Drawable::*compileGLObjects_function_type )( ::osg::RenderInfo & ) const;
            typedef void ( Drawable_wrapper::*default_compileGLObjects_function_type )( ::osg::RenderInfo & ) const;
            
            Drawable_exposer.def( 
                "compileGLObjects"
                , compileGLObjects_function_type(&::osg::Drawable::compileGLObjects)
                , default_compileGLObjects_function_type(&Drawable_wrapper::default_compileGLObjects)
                , ( bp::arg("renderInfo") ) );
        
        }
        { //::osg::Drawable::computeBound
        
            typedef ::osg::BoundingBox ( ::osg::Drawable::*computeBound_function_type )(  ) const;
            typedef ::osg::BoundingBox ( Drawable_wrapper::*default_computeBound_function_type )(  ) const;
            
            Drawable_exposer.def( 
                "computeBound"
                , computeBound_function_type(&::osg::Drawable::computeBound)
                , default_computeBound_function_type(&Drawable_wrapper::default_computeBound) );
        
        }
        { //::osg::Drawable::computeDataVariance
        
            typedef void ( ::osg::Drawable::*computeDataVariance_function_type )(  ) ;
            typedef void ( Drawable_wrapper::*default_computeDataVariance_function_type )(  ) ;
            
            Drawable_exposer.def( 
                "computeDataVariance"
                , computeDataVariance_function_type(&::osg::Drawable::computeDataVariance)
                , default_computeDataVariance_function_type(&Drawable_wrapper::default_computeDataVariance) );
        
        }
        { //::osg::Drawable::deleteDisplayList
        
            typedef void ( *deleteDisplayList_function_type )( unsigned int,::GLuint,unsigned int );
            
            Drawable_exposer.def( 
                "deleteDisplayList"
                , deleteDisplayList_function_type( &::osg::Drawable::deleteDisplayList )
                , ( bp::arg("contextID"), bp::arg("globj"), bp::arg("sizeHint")=(unsigned int)(0) )
                , " Use deleteDisplayList instead of glDeleteList to allow\n OpenGL display list to be cached until they can be deleted\n by the OpenGL context in which they were created, specified\n by contextID." );
        
        }
        { //::osg::Drawable::dirtyBound
        
            typedef void ( ::osg::Drawable::*dirtyBound_function_type )(  ) ;
            
            Drawable_exposer.def( 
                "dirtyBound"
                , dirtyBound_function_type( &::osg::Drawable::dirtyBound )
                , " Dirty the bounding box, forcing a computeBound() on the next call\n to getBound(). Should be called in the internal geometry of the Drawable\n is modified." );
        
        }
        { //::osg::Drawable::dirtyDisplayList
        
            typedef void ( ::osg::Drawable::*dirtyDisplayList_function_type )(  ) ;
            typedef void ( Drawable_wrapper::*default_dirtyDisplayList_function_type )(  ) ;
            
            Drawable_exposer.def( 
                "dirtyDisplayList"
                , dirtyDisplayList_function_type(&::osg::Drawable::dirtyDisplayList)
                , default_dirtyDisplayList_function_type(&Drawable_wrapper::default_dirtyDisplayList) );
        
        }
        { //::osg::Drawable::discardAllDeletedDisplayLists
        
            typedef void ( *discardAllDeletedDisplayLists_function_type )( unsigned int );
            
            Drawable_exposer.def( 
                "discardAllDeletedDisplayLists"
                , discardAllDeletedDisplayLists_function_type( &::osg::Drawable::discardAllDeletedDisplayLists )
                , ( bp::arg("contextID") )
                , " Flush all the cached display list which need to be deleted\n in the OpenGL context related to contextID.\n Note, unlike flush no OpenGL calls are made, instead the handles are all removed.\n this call is useful for when an OpenGL context has been destroyed." );
        
        }
        { //::osg::Drawable::draw
        
            typedef void ( ::osg::Drawable::*draw_function_type )( ::osg::RenderInfo & ) const;
            
            Drawable_exposer.def( 
                "draw"
                , draw_function_type( &::osg::Drawable::draw )
                , ( bp::arg("renderInfo") ) );
        
        }
        { //::osg::Drawable::drawImplementation
        
            typedef void ( ::osg::Drawable::*drawImplementation_function_type )( ::osg::RenderInfo & ) const;
            
            Drawable_exposer.def( 
                "drawImplementation"
                , bp::pure_virtual( drawImplementation_function_type(&::osg::Drawable::drawImplementation) )
                , ( bp::arg("renderInfo") )
                , "\n drawImplementation(RenderInfo&) is a pure virtual method for the actual implementation of OpenGL drawing calls, such as vertex arrays and primitives, that\n must be implemented in concrete subclasses of the Drawable base class, examples include osg::Geometry and osg::ShapeDrawable.\n drawImplementation(RenderInfo&) is called from the draw(RenderInfo&) method, with the draw method handling management of OpenGL display lists,\n and drawImplementation(RenderInfo&) handling the actual drawing itself.\n @param renderInfo: The osg::RenderInfo object that encapsulates the current rendering information including the osg::State OpenGL state for the current graphics context.\n" );
        
        }
        { //::osg::Drawable::flushAllDeletedDisplayLists
        
            typedef void ( *flushAllDeletedDisplayLists_function_type )( unsigned int );
            
            Drawable_exposer.def( 
                "flushAllDeletedDisplayLists"
                , flushAllDeletedDisplayLists_function_type( &::osg::Drawable::flushAllDeletedDisplayLists )
                , ( bp::arg("contextID") )
                , " Flush all the cached display list which need to be deleted\n in the OpenGL context related to contextID." );
        
        }
        { //::osg::Drawable::flushDeletedDisplayLists
        
            typedef void ( *flushDeletedDisplayLists_function_type )( unsigned int,double & );
            
            Drawable_exposer.def( 
                "flushDeletedDisplayLists"
                , flushDeletedDisplayLists_function_type( &::osg::Drawable::flushDeletedDisplayLists )
                , ( bp::arg("contextID"), bp::arg("availableTime") )
                , " Flush the cached display list which need to be deleted\n in the OpenGL context related to contextID." );
        
        }
        { //::osg::Drawable::generateDisplayList
        
            typedef ::GLuint ( *generateDisplayList_function_type )( unsigned int,unsigned int );
            
            Drawable_exposer.def( 
                "generateDisplayList"
                , generateDisplayList_function_type( &::osg::Drawable::generateDisplayList )
                , ( bp::arg("contextID"), bp::arg("sizeHint")=(unsigned int)(0) )
                , " Return a OpenGL display list handle a newly generated or reused from display list cache." );
        
        }
        { //::osg::Drawable::getBound
        
            typedef ::osg::BoundingBox const & ( ::osg::Drawable::*getBound_function_type )(  ) const;
            
            Drawable_exposer.def( 
                "getBound"
                , getBound_function_type( &::osg::Drawable::getBound )
                , bp::return_internal_reference< >()
                , " Get BoundingBox of Drawable.\n If the BoundingBox is not up to date then its updated via an internal call to computeBond()." );
        
        }
        { //::osg::Drawable::getComputeBoundingBoxCallback
        
            typedef ::osg::Drawable::ComputeBoundingBoxCallback * ( ::osg::Drawable::*getComputeBoundingBoxCallback_function_type )(  ) ;
            
            Drawable_exposer.def( 
                "getComputeBoundingBoxCallback"
                , getComputeBoundingBoxCallback_function_type( &::osg::Drawable::getComputeBoundingBoxCallback )
                , bp::return_internal_reference< >()
                , " Get the compute bound callback." );
        
        }
        { //::osg::Drawable::getComputeBoundingBoxCallback
        
            typedef ::osg::Drawable::ComputeBoundingBoxCallback const * ( ::osg::Drawable::*getComputeBoundingBoxCallback_function_type )(  ) const;
            
            Drawable_exposer.def( 
                "getComputeBoundingBoxCallback"
                , getComputeBoundingBoxCallback_function_type( &::osg::Drawable::getComputeBoundingBoxCallback )
                , bp::return_internal_reference< >()
                , " Get the const compute bound callback." );
        
        }
        { //::osg::Drawable::getCullCallback
        
            typedef ::osg::Drawable::CullCallback * ( ::osg::Drawable::*getCullCallback_function_type )(  ) ;
            
            Drawable_exposer.def( 
                "getCullCallback"
                , getCullCallback_function_type( &::osg::Drawable::getCullCallback )
                , bp::return_internal_reference< >()
                , " Get the non const CullCallback." );
        
        }
        { //::osg::Drawable::getCullCallback
        
            typedef ::osg::Drawable::CullCallback const * ( ::osg::Drawable::*getCullCallback_function_type )(  ) const;
            
            Drawable_exposer.def( 
                "getCullCallback"
                , getCullCallback_function_type( &::osg::Drawable::getCullCallback )
                , bp::return_internal_reference< >()
                , " Get the const CullCallback." );
        
        }
        { //::osg::Drawable::getDisplayList
        
            typedef ::GLuint & ( ::osg::Drawable::*getDisplayList_function_type )( unsigned int ) const;
            
            Drawable_exposer.def( 
                "getDisplayList"
                , getDisplayList_function_type( &::osg::Drawable::getDisplayList )
                , ( bp::arg("contextID") )
                , bp::return_value_policy< bp::copy_non_const_reference >()
                , " Return OpenGL display list for specified contextID." );
        
        }
        { //::osg::Drawable::getDrawCallback
        
            typedef ::osg::Drawable::DrawCallback * ( ::osg::Drawable::*getDrawCallback_function_type )(  ) ;
            
            Drawable_exposer.def( 
                "getDrawCallback"
                , getDrawCallback_function_type( &::osg::Drawable::getDrawCallback )
                , bp::return_internal_reference< >()
                , " Get the non const DrawCallback." );
        
        }
        { //::osg::Drawable::getDrawCallback
        
            typedef ::osg::Drawable::DrawCallback const * ( ::osg::Drawable::*getDrawCallback_function_type )(  ) const;
            
            Drawable_exposer.def( 
                "getDrawCallback"
                , getDrawCallback_function_type( &::osg::Drawable::getDrawCallback )
                , bp::return_internal_reference< >()
                , " Get the const DrawCallback." );
        
        }
        { //::osg::Drawable::getEventCallback
        
            typedef ::osg::Drawable::EventCallback * ( ::osg::Drawable::*getEventCallback_function_type )(  ) ;
            
            Drawable_exposer.def( 
                "getEventCallback"
                , getEventCallback_function_type( &::osg::Drawable::getEventCallback )
                , bp::return_internal_reference< >()
                , " Get the non const EventCallback." );
        
        }
        { //::osg::Drawable::getEventCallback
        
            typedef ::osg::Drawable::EventCallback const * ( ::osg::Drawable::*getEventCallback_function_type )(  ) const;
            
            Drawable_exposer.def( 
                "getEventCallback"
                , getEventCallback_function_type( &::osg::Drawable::getEventCallback )
                , bp::return_internal_reference< >()
                , " Get the const EventCallback." );
        
        }
        { //::osg::Drawable::getExtensions
        
            typedef ::osg::Drawable::Extensions * ( *getExtensions_function_type )( unsigned int,bool );
            
            Drawable_exposer.def( 
                "getExtensions"
                , getExtensions_function_type( &::osg::Drawable::getExtensions )
                , ( bp::arg("contextID"), bp::arg("createIfNotInitalized") )
                , bp::return_internal_reference< >()
                , " Function to call to get the extension of a specified context.\n If the Extension object for that context has not yet been created\n and the createIfNotInitalized flag been set to false then returns NULL.\n If createIfNotInitalized is true then the Extensions object is\n automatically created.  However, in this case the extension object is\n only created with the graphics context associated with ContextID.." );
        
        }
        { //::osg::Drawable::getGLObjectSizeHint
        
            typedef unsigned int ( ::osg::Drawable::*getGLObjectSizeHint_function_type )(  ) const;
            typedef unsigned int ( Drawable_wrapper::*default_getGLObjectSizeHint_function_type )(  ) const;
            
            Drawable_exposer.def( 
                "getGLObjectSizeHint"
                , getGLObjectSizeHint_function_type(&::osg::Drawable::getGLObjectSizeHint)
                , default_getGLObjectSizeHint_function_type(&Drawable_wrapper::default_getGLObjectSizeHint) );
        
        }
        { //::osg::Drawable::getInitialBound
        
            typedef ::osg::BoundingBox const & ( ::osg::Drawable::*getInitialBound_function_type )(  ) const;
            
            Drawable_exposer.def( 
                "getInitialBound"
                , getInitialBound_function_type( &::osg::Drawable::getInitialBound )
                , bp::return_internal_reference< >()
                , " Set the initial bounding volume to use when computing the overall bounding volume." );
        
        }
        { //::osg::Drawable::getMinimumNumberOfDisplayListsToRetainInCache
        
            typedef unsigned int ( *getMinimumNumberOfDisplayListsToRetainInCache_function_type )(  );
            
            Drawable_exposer.def( 
                "getMinimumNumberOfDisplayListsToRetainInCache"
                , getMinimumNumberOfDisplayListsToRetainInCache_function_type( &::osg::Drawable::getMinimumNumberOfDisplayListsToRetainInCache )
                , " Get the minimum number of display lists to retain in the deleted display list cache." );
        
        }
        { //::osg::Drawable::getNumParents
        
            typedef unsigned int ( ::osg::Drawable::*getNumParents_function_type )(  ) const;
            
            Drawable_exposer.def( 
                "getNumParents"
                , getNumParents_function_type( &::osg::Drawable::getNumParents )
                , " Get the number of parents of node.\n Return: the number of parents of this node." );
        
        }
        { //::osg::Drawable::getOrCreateStateSet
        
            typedef ::osg::StateSet * ( ::osg::Drawable::*getOrCreateStateSet_function_type )(  ) ;
            
            Drawable_exposer.def( 
                "getOrCreateStateSet"
                , getOrCreateStateSet_function_type( &::osg::Drawable::getOrCreateStateSet )
                , bp::return_internal_reference< >()
                , " Get the attached const StateSet,\n if one is not already attached create one,\n attach it to the drawable and return a pointer to it." );
        
        }
        { //::osg::Drawable::getParent
        
            typedef ::osg::Node * ( ::osg::Drawable::*getParent_function_type )( unsigned int ) ;
            
            Drawable_exposer.def( 
                "getParent"
                , getParent_function_type( &::osg::Drawable::getParent )
                , ( bp::arg("i") )
                , bp::return_internal_reference< >()
                , " Get a single parent of Drawable.\n @param i: index of the parent to get.\n Return: the parent i." );
        
        }
        { //::osg::Drawable::getParent
        
            typedef ::osg::Node const * ( ::osg::Drawable::*getParent_function_type )( unsigned int ) const;
            
            Drawable_exposer.def( 
                "getParent"
                , getParent_function_type( &::osg::Drawable::getParent )
                , ( bp::arg("i") )
                , bp::return_internal_reference< >()
                , " Get a single const parent of Drawable.\n @param i: index of the parent to get.\n Return: the parent i." );
        
        }
        { //::osg::Drawable::getParents
        
            typedef ::std::vector< osg::Node* > const & ( ::osg::Drawable::*getParents_function_type )(  ) const;
            
            Drawable_exposer.def( 
                "getParents"
                , getParents_function_type( &::osg::Drawable::getParents )
                , bp::return_internal_reference< >()
                , " Get the parent list of drawable." );
        
        }
        { //::osg::Drawable::getParents
        
            typedef ::std::vector< osg::Node* > ( ::osg::Drawable::*getParents_function_type )(  ) ;
            
            Drawable_exposer.def( 
                "getParents"
                , getParents_function_type( &::osg::Drawable::getParents )
                , " Get the a copy of parent list of node. A copy is returned to\n prevent modification of the parent list." );
        
        }
        { //::osg::Drawable::getShape
        
            typedef ::osg::Shape * ( ::osg::Drawable::*getShape_function_type )(  ) ;
            
            Drawable_exposer.def( 
                "getShape"
                , getShape_function_type( &::osg::Drawable::getShape )
                , bp::return_internal_reference< >()
                , " Get the Shape of the Drawable." );
        
        }
        { //::osg::Drawable::getShape
        
            typedef ::osg::Shape const * ( ::osg::Drawable::*getShape_function_type )(  ) const;
            
            Drawable_exposer.def( 
                "getShape"
                , getShape_function_type( &::osg::Drawable::getShape )
                , bp::return_internal_reference< >()
                , " Get the const Shape of the const Drawable." );
        
        }
        { //::osg::Drawable::getStateSet
        
            typedef ::osg::StateSet * ( ::osg::Drawable::*getStateSet_function_type )(  ) ;
            
            Drawable_exposer.def( 
                "getStateSet"
                , getStateSet_function_type( &::osg::Drawable::getStateSet )
                , bp::return_internal_reference< >()
                , " Get the attached StateSet." );
        
        }
        { //::osg::Drawable::getStateSet
        
            typedef ::osg::StateSet const * ( ::osg::Drawable::*getStateSet_function_type )(  ) const;
            
            Drawable_exposer.def( 
                "getStateSet"
                , getStateSet_function_type( &::osg::Drawable::getStateSet )
                , bp::return_internal_reference< >()
                , " Get the attached const StateSet." );
        
        }
        { //::osg::Drawable::getSupportsDisplayList
        
            typedef bool ( ::osg::Drawable::*getSupportsDisplayList_function_type )(  ) const;
            
            Drawable_exposer.def( 
                "getSupportsDisplayList"
                , getSupportsDisplayList_function_type( &::osg::Drawable::getSupportsDisplayList )
                , " Get whether display lists are supported for this drawable instance." );
        
        }
        { //::osg::Drawable::getUpdateCallback
        
            typedef ::osg::Drawable::UpdateCallback * ( ::osg::Drawable::*getUpdateCallback_function_type )(  ) ;
            
            Drawable_exposer.def( 
                "getUpdateCallback"
                , getUpdateCallback_function_type( &::osg::Drawable::getUpdateCallback )
                , bp::return_internal_reference< >()
                , " Get the non const UpdateCallback." );
        
        }
        { //::osg::Drawable::getUpdateCallback
        
            typedef ::osg::Drawable::UpdateCallback const * ( ::osg::Drawable::*getUpdateCallback_function_type )(  ) const;
            
            Drawable_exposer.def( 
                "getUpdateCallback"
                , getUpdateCallback_function_type( &::osg::Drawable::getUpdateCallback )
                , bp::return_internal_reference< >()
                , " Get the const UpdateCallback." );
        
        }
        { //::osg::Drawable::getUseDisplayList
        
            typedef bool ( ::osg::Drawable::*getUseDisplayList_function_type )(  ) const;
            
            Drawable_exposer.def( 
                "getUseDisplayList"
                , getUseDisplayList_function_type( &::osg::Drawable::getUseDisplayList )
                , " Return whether OpenGL display lists are being used for rendering." );
        
        }
        { //::osg::Drawable::getUseVertexBufferObjects
        
            typedef bool ( ::osg::Drawable::*getUseVertexBufferObjects_function_type )(  ) const;
            
            Drawable_exposer.def( 
                "getUseVertexBufferObjects"
                , getUseVertexBufferObjects_function_type( &::osg::Drawable::getUseVertexBufferObjects )
                , " Return whether OpenGL vertex buffer objects should be used when supported by OpenGL driver." );
        
        }
        { //::osg::Drawable::getWorldMatrices
        
            typedef ::osg::MatrixList ( ::osg::Drawable::*getWorldMatrices_function_type )( ::osg::Node const * ) const;
            
            Drawable_exposer.def( 
                "getWorldMatrices"
                , getWorldMatrices_function_type( &::osg::Drawable::getWorldMatrices )
                , ( bp::arg("haltTraversalAtNode")=bp::object() )
                , " Get the list of matrices that transform this node from local coordinates to world coordinates.\n The optional Node* haltTraversalAtNode allows the user to prevent traversal beyond a specifed node." );
        
        }
        { //::osg::Drawable::isSameKindAs
        
            typedef bool ( ::osg::Drawable::*isSameKindAs_function_type )( ::osg::Object const * ) const;
            typedef bool ( Drawable_wrapper::*default_isSameKindAs_function_type )( ::osg::Object const * ) const;
            
            Drawable_exposer.def( 
                "isSameKindAs"
                , isSameKindAs_function_type(&::osg::Drawable::isSameKindAs)
                , default_isSameKindAs_function_type(&Drawable_wrapper::default_isSameKindAs)
                , ( bp::arg("obj") ) );
        
        }
        { //::osg::Drawable::libraryName
        
            typedef char const * ( ::osg::Drawable::*libraryName_function_type )(  ) const;
            typedef char const * ( Drawable_wrapper::*default_libraryName_function_type )(  ) const;
            
            Drawable_exposer.def( 
                "libraryName"
                , libraryName_function_type(&::osg::Drawable::libraryName)
                , default_libraryName_function_type(&Drawable_wrapper::default_libraryName) );
        
        }
        { //::osg::Drawable::requiresEventTraversal
        
            typedef bool ( ::osg::Drawable::*requiresEventTraversal_function_type )(  ) const;
            
            Drawable_exposer.def( 
                "requiresEventTraversal"
                , requiresEventTraversal_function_type( &::osg::Drawable::requiresEventTraversal )
                , " Return whether this Drawable has event callbacks associated with it, and therefore must be traversed." );
        
        }
        { //::osg::Drawable::requiresUpdateTraversal
        
            typedef bool ( ::osg::Drawable::*requiresUpdateTraversal_function_type )(  ) const;
            
            Drawable_exposer.def( 
                "requiresUpdateTraversal"
                , requiresUpdateTraversal_function_type( &::osg::Drawable::requiresUpdateTraversal )
                , " Return whether this Drawable has update callbacks associated with it, and therefore must be traversed." );
        
        }
        { //::osg::Drawable::resizeGLObjectBuffers
        
            typedef void ( ::osg::Drawable::*resizeGLObjectBuffers_function_type )( unsigned int ) ;
            typedef void ( Drawable_wrapper::*default_resizeGLObjectBuffers_function_type )( unsigned int ) ;
            
            Drawable_exposer.def( 
                "resizeGLObjectBuffers"
                , resizeGLObjectBuffers_function_type(&::osg::Drawable::resizeGLObjectBuffers)
                , default_resizeGLObjectBuffers_function_type(&Drawable_wrapper::default_resizeGLObjectBuffers)
                , ( bp::arg("maxSize") ) );
        
        }
        { //::osg::Drawable::setComputeBoundingBoxCallback
        
            typedef void ( ::osg::Drawable::*setComputeBoundingBoxCallback_function_type )( ::osg::Drawable::ComputeBoundingBoxCallback * ) ;
            
            Drawable_exposer.def( 
                "setComputeBoundingBoxCallback"
                , setComputeBoundingBoxCallback_function_type( &::osg::Drawable::setComputeBoundingBoxCallback )
                , ( bp::arg("callback") )
                , " Set the compute bound callback to override the default computeBound." );
        
        }
        { //::osg::Drawable::setCullCallback
        
            typedef void ( ::osg::Drawable::*setCullCallback_function_type )( ::osg::Drawable::CullCallback * ) ;
            typedef void ( Drawable_wrapper::*default_setCullCallback_function_type )( ::osg::Drawable::CullCallback * ) ;
            
            Drawable_exposer.def( 
                "setCullCallback"
                , setCullCallback_function_type(&::osg::Drawable::setCullCallback)
                , default_setCullCallback_function_type(&Drawable_wrapper::default_setCullCallback)
                , ( bp::arg("cc") ) );
        
        }
        { //::osg::Drawable::setDrawCallback
        
            typedef void ( ::osg::Drawable::*setDrawCallback_function_type )( ::osg::Drawable::DrawCallback * ) ;
            typedef void ( Drawable_wrapper::*default_setDrawCallback_function_type )( ::osg::Drawable::DrawCallback * ) ;
            
            Drawable_exposer.def( 
                "setDrawCallback"
                , setDrawCallback_function_type(&::osg::Drawable::setDrawCallback)
                , default_setDrawCallback_function_type(&Drawable_wrapper::default_setDrawCallback)
                , ( bp::arg("dc") ) );
        
        }
        { //::osg::Drawable::setEventCallback
        
            typedef void ( ::osg::Drawable::*setEventCallback_function_type )( ::osg::Drawable::EventCallback * ) ;
            typedef void ( Drawable_wrapper::*default_setEventCallback_function_type )( ::osg::Drawable::EventCallback * ) ;
            
            Drawable_exposer.def( 
                "setEventCallback"
                , setEventCallback_function_type(&::osg::Drawable::setEventCallback)
                , default_setEventCallback_function_type(&Drawable_wrapper::default_setEventCallback)
                , ( bp::arg("ac") ) );
        
        }
        { //::osg::Drawable::setExtensions
        
            typedef void ( *setExtensions_function_type )( unsigned int,::osg::Drawable::Extensions * );
            
            Drawable_exposer.def( 
                "setExtensions"
                , setExtensions_function_type( &::osg::Drawable::setExtensions )
                , ( bp::arg("contextID"), bp::arg("extensions") )
                , " setExtensions allows users to override the extensions across graphics contexts.\n typically used when you have different extensions supported across graphics pipes\n but need to ensure that they all use the same low common denominator extensions." );
        
        }
        { //::osg::Drawable::setInitialBound
        
            typedef void ( ::osg::Drawable::*setInitialBound_function_type )( ::osg::BoundingBox const & ) ;
            
            Drawable_exposer.def( 
                "setInitialBound"
                , setInitialBound_function_type( &::osg::Drawable::setInitialBound )
                , ( bp::arg("bbox") )
                , " Set the initial bounding volume to use when computing the overall bounding volume." );
        
        }
        { //::osg::Drawable::setMinimumNumberOfDisplayListsToRetainInCache
        
            typedef void ( *setMinimumNumberOfDisplayListsToRetainInCache_function_type )( unsigned int );
            
            Drawable_exposer.def( 
                "setMinimumNumberOfDisplayListsToRetainInCache"
                , setMinimumNumberOfDisplayListsToRetainInCache_function_type( &::osg::Drawable::setMinimumNumberOfDisplayListsToRetainInCache )
                , ( bp::arg("minimum") )
                , " Set the minimum number of display lists to retain in the deleted display list cache." );
        
        }
        { //::osg::Drawable::setShape
        
            typedef void ( ::osg::Drawable::*setShape_function_type )( ::osg::Shape * ) ;
            
            Drawable_exposer.def( 
                "setShape"
                , setShape_function_type( &::osg::Drawable::setShape )
                , ( bp::arg("shape") )
                , " Set the Shape of the  Drawable. The shape can be used to\n  speed up collision detection or as a guide for procedural\n  geometry generation.\n aee osg::Shape." );
        
        }
        { //::osg::Drawable::setStateSet
        
            typedef void ( ::osg::Drawable::*setStateSet_function_type )( ::osg::StateSet * ) ;
            
            Drawable_exposer.def( 
                "setStateSet"
                , setStateSet_function_type( &::osg::Drawable::setStateSet )
                , ( bp::arg("stateset") )
                , " Set the StateSet attached to the Drawable.\n            Previously attached StateSet are automatically unreferenced on\n            assignment of a new drawstate." );
        
        }
        { //::osg::Drawable::setSupportsDisplayList
        
            typedef void ( ::osg::Drawable::*setSupportsDisplayList_function_type )( bool ) ;
            
            Drawable_exposer.def( 
                "setSupportsDisplayList"
                , setSupportsDisplayList_function_type( &::osg::Drawable::setSupportsDisplayList )
                , ( bp::arg("flag") )
                , " Set the drawable so that it can or cannot be used in conjunction with OpenGL\n display lists.  When set to true, calls to Drawable::setUseDisplayList,\n whereas when set to false, no display lists can be created and calls\n to setUseDisplayList are ignored, and a warning is produced.  The latter\n is typically used to guard against the switching on of display lists\n on objects with dynamic internal data such as continuous Level of Detail\n algorithms." );
        
        }
        { //::osg::Drawable::setThreadSafeRefUnref
        
            typedef void ( ::osg::Drawable::*setThreadSafeRefUnref_function_type )( bool ) ;
            typedef void ( Drawable_wrapper::*default_setThreadSafeRefUnref_function_type )( bool ) ;
            
            Drawable_exposer.def( 
                "setThreadSafeRefUnref"
                , setThreadSafeRefUnref_function_type(&::osg::Drawable::setThreadSafeRefUnref)
                , default_setThreadSafeRefUnref_function_type(&Drawable_wrapper::default_setThreadSafeRefUnref)
                , ( bp::arg("threadSafe") ) );
        
        }
        { //::osg::Drawable::setUpdateCallback
        
            typedef void ( ::osg::Drawable::*setUpdateCallback_function_type )( ::osg::Drawable::UpdateCallback * ) ;
            typedef void ( Drawable_wrapper::*default_setUpdateCallback_function_type )( ::osg::Drawable::UpdateCallback * ) ;
            
            Drawable_exposer.def( 
                "setUpdateCallback"
                , setUpdateCallback_function_type(&::osg::Drawable::setUpdateCallback)
                , default_setUpdateCallback_function_type(&Drawable_wrapper::default_setUpdateCallback)
                , ( bp::arg("ac") ) );
        
        }
        { //::osg::Drawable::setUseDisplayList
        
            typedef void ( ::osg::Drawable::*setUseDisplayList_function_type )( bool ) ;
            
            Drawable_exposer.def( 
                "setUseDisplayList"
                , setUseDisplayList_function_type( &::osg::Drawable::setUseDisplayList )
                , ( bp::arg("flag") )
                , " When set to true, force the draw method to use OpenGL Display List for rendering.\n            If false, rendering directly.  If the display list has not been compiled\n            already, the next call to draw will automatically create the display list." );
        
        }
        { //::osg::Drawable::setUseVertexBufferObjects
        
            typedef void ( ::osg::Drawable::*setUseVertexBufferObjects_function_type )( bool ) ;
            typedef void ( Drawable_wrapper::*default_setUseVertexBufferObjects_function_type )( bool ) ;
            
            Drawable_exposer.def( 
                "setUseVertexBufferObjects"
                , setUseVertexBufferObjects_function_type(&::osg::Drawable::setUseVertexBufferObjects)
                , default_setUseVertexBufferObjects_function_type(&Drawable_wrapper::default_setUseVertexBufferObjects)
                , ( bp::arg("flag") ) );
        
        }
        { //::osg::Drawable::supports
        
            typedef bool ( ::osg::Drawable::*supports_function_type )( ::osg::Drawable::AttributeFunctor const & ) const;
            typedef bool ( Drawable_wrapper::*default_supports_function_type )( ::osg::Drawable::AttributeFunctor const & ) const;
            
            Drawable_exposer.def( 
                "supports"
                , supports_function_type(&::osg::Drawable::supports)
                , default_supports_function_type(&Drawable_wrapper::default_supports)
                , ( bp::arg("arg0") ) );
        
        }
        { //::osg::Drawable::supports
        
            typedef bool ( ::osg::Drawable::*supports_function_type )( ::osg::Drawable::ConstAttributeFunctor const & ) const;
            typedef bool ( Drawable_wrapper::*default_supports_function_type )( ::osg::Drawable::ConstAttributeFunctor const & ) const;
            
            Drawable_exposer.def( 
                "supports"
                , supports_function_type(&::osg::Drawable::supports)
                , default_supports_function_type(&Drawable_wrapper::default_supports)
                , ( bp::arg("arg0") ) );
        
        }
        { //::osg::Drawable::supports
        
            typedef bool ( ::osg::Drawable::*supports_function_type )( ::osg::PrimitiveFunctor const & ) const;
            typedef bool ( Drawable_wrapper::*default_supports_function_type )( ::osg::PrimitiveFunctor const & ) const;
            
            Drawable_exposer.def( 
                "supports"
                , supports_function_type(&::osg::Drawable::supports)
                , default_supports_function_type(&Drawable_wrapper::default_supports)
                , ( bp::arg("arg0") ) );
        
        }
        { //::osg::Drawable::supports
        
            typedef bool ( ::osg::Drawable::*supports_function_type )( ::osg::PrimitiveIndexFunctor const & ) const;
            typedef bool ( Drawable_wrapper::*default_supports_function_type )( ::osg::PrimitiveIndexFunctor const & ) const;
            
            Drawable_exposer.def( 
                "supports"
                , supports_function_type(&::osg::Drawable::supports)
                , default_supports_function_type(&Drawable_wrapper::default_supports)
                , ( bp::arg("arg0") ) );
        
        }
        Drawable_exposer.def_readwrite( "s_numberDeletedDrawablesInLastFrame", osg::Drawable::s_numberDeletedDrawablesInLastFrame );
        Drawable_exposer.def_readwrite( "s_numberDrawablesReusedLastInLastFrame", osg::Drawable::s_numberDrawablesReusedLastInLastFrame, " Pure virtual base class for drawable geometry. In OSG, everything that can\n  be rendered is implemented as a class derived from  Drawable. The\n   Drawable class contains no drawing primitives, since these are provided\n  by subclasses such as  osg::Geometry.\n  <p>Notice that a  Drawable is not a  Node, and therefore it cannot be\n  directly added to a scene graph. Instead, <tt>Drawable</tt>s are attached to\n  <tt>Geode</tt>s, which are scene graph nodes.\n  <p>The OpenGL state that must be used when rendering a  Drawable is\n  represented by a  StateSet. Since a  Drawable has a reference\n  ( osg::ref_ptr) to a  StateSet, <tt>StateSet</tt>s can be shared between\n  different <tt>Drawable</tt>s. In fact, sharing <tt>StateSet</tt>s is a good\n  way to improve performance, since this allows OSG to reduce the number of\n  expensive changes in the OpenGL state.\n  <p>Finally, <tt>Drawable</tt>s can also be shared between different\n  <tt>Geode</tt>s, so that the same geometry (loaded to memory just once) can\n  be used in different parts of the scene graph." );
        Drawable_exposer.def_readwrite( "s_numberNewDrawablesInLastFrame", osg::Drawable::s_numberNewDrawablesInLastFrame );
        { //::osg::Object::clone
        
            typedef ::osg::Object * ( ::osg::Object::*clone_function_type )( ::osg::CopyOp const & ) const;
            
            Drawable_exposer.def( 
                "clone"
                , bp::pure_virtual( clone_function_type(&::osg::Object::clone) )
                , ( bp::arg("arg0") )
                , bp::return_value_policy< bp::reference_existing_object >()
                , "\n Clone an object, with Object* return type.\n            Must be defined by derived classes.\n" );
        
        }
        { //::osg::Object::cloneType
        
            typedef ::osg::Object * ( ::osg::Object::*cloneType_function_type )(  ) const;
            
            Drawable_exposer.def( 
                "cloneType"
                , bp::pure_virtual( cloneType_function_type(&::osg::Object::cloneType) )
                , bp::return_value_policy< bp::reference_existing_object >()
                , "\n Clone the type of an object, with Object* return type.\n            Must be defined by derived classes.\n" );
        
        }
        Drawable_exposer.staticmethod( "deleteDisplayList" );
        Drawable_exposer.staticmethod( "discardAllDeletedDisplayLists" );
        Drawable_exposer.staticmethod( "flushAllDeletedDisplayLists" );
        Drawable_exposer.staticmethod( "flushDeletedDisplayLists" );
        Drawable_exposer.staticmethod( "generateDisplayList" );
        Drawable_exposer.staticmethod( "getExtensions" );
        Drawable_exposer.staticmethod( "getMinimumNumberOfDisplayListsToRetainInCache" );
        Drawable_exposer.staticmethod( "setExtensions" );
        Drawable_exposer.staticmethod( "setMinimumNumberOfDisplayListsToRetainInCache" );
    }

}
