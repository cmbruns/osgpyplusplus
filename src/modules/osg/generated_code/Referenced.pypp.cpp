// This file has been generated by Py++.

#include "boost/python.hpp"
#include "wrap_osg.h"
#include "wrap_referenced.h"
#include "Referenced.pypp.hpp"

namespace bp = boost::python;

void register_Referenced_class(){

    { //::osg::Referenced
        typedef bp::class_< osg::Referenced, osg::ref_ptr< ::osg::Referenced >, boost::noncopyable > Referenced_exposer_t;
        Referenced_exposer_t Referenced_exposer = Referenced_exposer_t( "Referenced", "\n Base class for providing reference counted objects.\n", bp::no_init );
        bp::scope Referenced_scope( Referenced_exposer );
        Referenced_exposer.def( bp::init< >("\n Base class for providing reference counted objects.\n") );
        { //::osg::Referenced::addObserver
        
            typedef void ( ::osg::Referenced::*addObserver_function_type )( ::osg::Observer * ) const;
            
            Referenced_exposer.def( 
                "addObserver"
                , addObserver_function_type( &::osg::Referenced::addObserver )
                , ( bp::arg("observer") )
                , "\n Add a Observer that is observing this object, notify the Observer when this object gets deleted.\n" );
        
        }
        { //::osg::Referenced::getDeleteHandler
        
            typedef ::osg::DeleteHandler * ( *getDeleteHandler_function_type )(  );
            
            Referenced_exposer.def( 
                "getDeleteHandler"
                , getDeleteHandler_function_type( &::osg::Referenced::getDeleteHandler )
                , bp::return_internal_reference< >()
                , "\n Get a DeleteHandler.\n" );
        
        }
        { //::osg::Referenced::getGlobalReferencedMutex
        
            typedef ::OpenThreads::Mutex * ( *getGlobalReferencedMutex_function_type )(  );
            
            Referenced_exposer.def( 
                "getGlobalReferencedMutex"
                , getGlobalReferencedMutex_function_type( &::osg::Referenced::getGlobalReferencedMutex )
                , bp::return_value_policy< bp::reference_existing_object >()
                , "\n Get the optional global Referenced mutex, this can be shared between all osg::Referenced.\n" );
        
        }
        { //::osg::Referenced::getObserverSet
        
            typedef ::osg::ObserverSet * ( ::osg::Referenced::*getObserverSet_function_type )(  ) const;
            
            Referenced_exposer.def( 
                "getObserverSet"
                , getObserverSet_function_type( &::osg::Referenced::getObserverSet )
                , bp::return_internal_reference< >()
                , "\n Get the ObserverSet if one is attached, otherwise return NULL.\n" );
        
        }
        { //::osg::Referenced::getOrCreateObserverSet
        
            typedef ::osg::ObserverSet * ( ::osg::Referenced::*getOrCreateObserverSet_function_type )(  ) const;
            
            Referenced_exposer.def( 
                "getOrCreateObserverSet"
                , getOrCreateObserverSet_function_type( &::osg::Referenced::getOrCreateObserverSet )
                , bp::return_internal_reference< >()
                , "\n Get the ObserverSet if one is attached, otherwise create an ObserverSet, attach it, then return this newly created ObserverSet.\n" );
        
        }
        { //::osg::Referenced::getRefMutex
        
            typedef ::OpenThreads::Mutex * ( ::osg::Referenced::*getRefMutex_function_type )(  ) const;
            
            Referenced_exposer.def( 
                "getRefMutex"
                , getRefMutex_function_type( &::osg::Referenced::getRefMutex )
                , bp::return_internal_reference< >()
                , "\n Get the mutex used to ensure thread safety of ref()/unref().\n" );
        
        }
        { //::osg::Referenced::getThreadSafeRefUnref
        
            typedef bool ( ::osg::Referenced::*getThreadSafeRefUnref_function_type )(  ) const;
            
            Referenced_exposer.def( 
                "getThreadSafeRefUnref"
                , getThreadSafeRefUnref_function_type( &::osg::Referenced::getThreadSafeRefUnref )
                , "\n Get whether a mutex is used to ensure ref() and unref() are thread safe.\n" );
        
        }
        { //::osg::Referenced::getThreadSafeReferenceCounting
        
            typedef bool ( *getThreadSafeReferenceCounting_function_type )(  );
            
            Referenced_exposer.def( 
                "getThreadSafeReferenceCounting"
                , getThreadSafeReferenceCounting_function_type( &::osg::Referenced::getThreadSafeReferenceCounting )
                , "\n Get whether reference counting is active.\n" );
        
        }
        { //::osg::Referenced::ref
        
            typedef int ( ::osg::Referenced::*ref_function_type )(  ) const;
            
            Referenced_exposer.def( 
                "ref"
                , ref_function_type( &::osg::Referenced::ref ) );
        
        }
        { //::osg::Referenced::referenceCount
        
            typedef int ( ::osg::Referenced::*referenceCount_function_type )(  ) const;
            
            Referenced_exposer.def( 
                "referenceCount"
                , referenceCount_function_type( &::osg::Referenced::referenceCount )
                , "\n Return the number of pointers currently referencing this object.\n" );
        
        }
        { //::osg::Referenced::removeObserver
        
            typedef void ( ::osg::Referenced::*removeObserver_function_type )( ::osg::Observer * ) const;
            
            Referenced_exposer.def( 
                "removeObserver"
                , removeObserver_function_type( &::osg::Referenced::removeObserver )
                , ( bp::arg("observer") )
                , "\n Remove Observer that is observing this object.\n" );
        
        }
        { //::osg::Referenced::setDeleteHandler
        
            typedef void ( *setDeleteHandler_function_type )( ::osg::DeleteHandler * );
            
            Referenced_exposer.def( 
                "setDeleteHandler"
                , setDeleteHandler_function_type( &::osg::Referenced::setDeleteHandler )
                , ( bp::arg("handler") )
                , "\n Set a DeleteHandler to which deletion of all referenced counted objects\n will be delegated.\n" );
        
        }
        { //::osg::Referenced::setThreadSafeReferenceCounting
        
            typedef void ( *setThreadSafeReferenceCounting_function_type )( bool );
            
            Referenced_exposer.def( 
                "setThreadSafeReferenceCounting"
                , setThreadSafeReferenceCounting_function_type( &::osg::Referenced::setThreadSafeReferenceCounting )
                , ( bp::arg("enableThreadSafeReferenceCounting") )
                , "\n Set whether reference counting should use a mutex for thread safe reference counting.\n" );
        
        }
        { //::osg::Referenced::unref
        
            typedef int ( ::osg::Referenced::*unref_function_type )(  ) const;
            
            Referenced_exposer.def( 
                "unref"
                , unref_function_type( &::osg::Referenced::unref ) );
        
        }
        { //::osg::Referenced::unref_nodelete
        
            typedef int ( ::osg::Referenced::*unref_nodelete_function_type )(  ) const;
            
            Referenced_exposer.def( 
                "unref_nodelete"
                , unref_nodelete_function_type( &::osg::Referenced::unref_nodelete )
                , "\n Decrement the reference count by one, indicating that\n            a pointer to this object is no longer referencing it.  However, do\n            not delete it, even if ref count goes to 0.  Warning, unref_nodelete()\n            should only be called if the user knows exactly who will\n            be responsible for, one should prefer unref() over unref_nodelete()\n            as the latter can lead to memory leaks.\n" );
        
        }
        Referenced_exposer.staticmethod( "getDeleteHandler" );
        Referenced_exposer.staticmethod( "getGlobalReferencedMutex" );
        Referenced_exposer.staticmethod( "getThreadSafeReferenceCounting" );
        Referenced_exposer.staticmethod( "setDeleteHandler" );
        Referenced_exposer.staticmethod( "setThreadSafeReferenceCounting" );
    }

}
