// This file has been generated by Py++.

#include "boost/python.hpp"
#include "wrap_osg.h"
#include "wrap_referenced.h"
#include "Node.pypp.hpp"

namespace bp = boost::python;

struct Node_wrapper : osg::Node, bp::wrapper< osg::Node > {

    Node_wrapper( )
    : osg::Node( )
      , bp::wrapper< osg::Node >(){
        // null constructor
    
    }

    virtual void accept( ::osg::NodeVisitor & nv ) {
        if( bp::override func_accept = this->get_override( "accept" ) )
            func_accept( boost::ref(nv) );
        else{
            this->osg::Node::accept( boost::ref(nv) );
        }
    }
    
    void default_accept( ::osg::NodeVisitor & nv ) {
        osg::Node::accept( boost::ref(nv) );
    }

    virtual ::osg::Camera * asCamera(  ) {
        if( bp::override func_asCamera = this->get_override( "asCamera" ) )
            return func_asCamera(  );
        else{
            return this->osg::Node::asCamera(  );
        }
    }
    
    ::osg::Camera * default_asCamera(  ) {
        return osg::Node::asCamera( );
    }

    virtual ::osg::Camera const * asCamera(  ) const  {
        if( bp::override func_asCamera = this->get_override( "asCamera" ) )
            return func_asCamera(  );
        else{
            return this->osg::Node::asCamera(  );
        }
    }
    
    ::osg::Camera const * default_asCamera(  ) const  {
        return osg::Node::asCamera( );
    }

    virtual ::osg::Geode * asGeode(  ) {
        if( bp::override func_asGeode = this->get_override( "asGeode" ) )
            return func_asGeode(  );
        else{
            return this->osg::Node::asGeode(  );
        }
    }
    
    ::osg::Geode * default_asGeode(  ) {
        return osg::Node::asGeode( );
    }

    virtual ::osg::Geode const * asGeode(  ) const  {
        if( bp::override func_asGeode = this->get_override( "asGeode" ) )
            return func_asGeode(  );
        else{
            return this->osg::Node::asGeode(  );
        }
    }
    
    ::osg::Geode const * default_asGeode(  ) const  {
        return osg::Node::asGeode( );
    }

    virtual ::osg::Group * asGroup(  ) {
        if( bp::override func_asGroup = this->get_override( "asGroup" ) )
            return func_asGroup(  );
        else{
            return this->osg::Node::asGroup(  );
        }
    }
    
    ::osg::Group * default_asGroup(  ) {
        return osg::Node::asGroup( );
    }

    virtual ::osg::Group const * asGroup(  ) const  {
        if( bp::override func_asGroup = this->get_override( "asGroup" ) )
            return func_asGroup(  );
        else{
            return this->osg::Node::asGroup(  );
        }
    }
    
    ::osg::Group const * default_asGroup(  ) const  {
        return osg::Node::asGroup( );
    }

    virtual ::osg::Switch * asSwitch(  ) {
        if( bp::override func_asSwitch = this->get_override( "asSwitch" ) )
            return func_asSwitch(  );
        else{
            return this->osg::Node::asSwitch(  );
        }
    }
    
    ::osg::Switch * default_asSwitch(  ) {
        return osg::Node::asSwitch( );
    }

    virtual ::osg::Switch const * asSwitch(  ) const  {
        if( bp::override func_asSwitch = this->get_override( "asSwitch" ) )
            return func_asSwitch(  );
        else{
            return this->osg::Node::asSwitch(  );
        }
    }
    
    ::osg::Switch const * default_asSwitch(  ) const  {
        return osg::Node::asSwitch( );
    }

    virtual ::osg::Transform * asTransform(  ) {
        if( bp::override func_asTransform = this->get_override( "asTransform" ) )
            return func_asTransform(  );
        else{
            return this->osg::Node::asTransform(  );
        }
    }
    
    ::osg::Transform * default_asTransform(  ) {
        return osg::Node::asTransform( );
    }

    virtual ::osg::Transform const * asTransform(  ) const  {
        if( bp::override func_asTransform = this->get_override( "asTransform" ) )
            return func_asTransform(  );
        else{
            return this->osg::Node::asTransform(  );
        }
    }
    
    ::osg::Transform const * default_asTransform(  ) const  {
        return osg::Node::asTransform( );
    }

    virtual void ascend( ::osg::NodeVisitor & nv ) {
        if( bp::override func_ascend = this->get_override( "ascend" ) )
            func_ascend( boost::ref(nv) );
        else{
            this->osg::Node::ascend( boost::ref(nv) );
        }
    }
    
    void default_ascend( ::osg::NodeVisitor & nv ) {
        osg::Node::ascend( boost::ref(nv) );
    }

    virtual char const * className(  ) const  {
        if( bp::override func_className = this->get_override( "className" ) )
            return func_className(  );
        else{
            return this->osg::Node::className(  );
        }
    }
    
    char const * default_className(  ) const  {
        return osg::Node::className( );
    }

    virtual ::osg::Object * clone( ::osg::CopyOp const & copyop ) const  {
        if( bp::override func_clone = this->get_override( "clone" ) )
            return func_clone( boost::ref(copyop) );
        else{
            return this->osg::Node::clone( boost::ref(copyop) );
        }
    }
    
    ::osg::Object * default_clone( ::osg::CopyOp const & copyop ) const  {
        return osg::Node::clone( boost::ref(copyop) );
    }

    virtual ::osg::Object * cloneType(  ) const  {
        if( bp::override func_cloneType = this->get_override( "cloneType" ) )
            return func_cloneType(  );
        else{
            return this->osg::Node::cloneType(  );
        }
    }
    
    ::osg::Object * default_cloneType(  ) const  {
        return osg::Node::cloneType( );
    }

    virtual ::osg::BoundingSphere computeBound(  ) const  {
        if( bp::override func_computeBound = this->get_override( "computeBound" ) )
            return func_computeBound(  );
        else{
            return this->osg::Node::computeBound(  );
        }
    }
    
    ::osg::BoundingSphere default_computeBound(  ) const  {
        return osg::Node::computeBound( );
    }

    virtual bool isSameKindAs( ::osg::Object const * obj ) const  {
        if( bp::override func_isSameKindAs = this->get_override( "isSameKindAs" ) )
            return func_isSameKindAs( boost::python::ptr(obj) );
        else{
            return this->osg::Node::isSameKindAs( boost::python::ptr(obj) );
        }
    }
    
    bool default_isSameKindAs( ::osg::Object const * obj ) const  {
        return osg::Node::isSameKindAs( boost::python::ptr(obj) );
    }

    virtual char const * libraryName(  ) const  {
        if( bp::override func_libraryName = this->get_override( "libraryName" ) )
            return func_libraryName(  );
        else{
            return this->osg::Node::libraryName(  );
        }
    }
    
    char const * default_libraryName(  ) const  {
        return osg::Node::libraryName( );
    }

    virtual void resizeGLObjectBuffers( unsigned int arg0 ) {
        if( bp::override func_resizeGLObjectBuffers = this->get_override( "resizeGLObjectBuffers" ) )
            func_resizeGLObjectBuffers( arg0 );
        else{
            this->osg::Node::resizeGLObjectBuffers( arg0 );
        }
    }
    
    void default_resizeGLObjectBuffers( unsigned int arg0 ) {
        osg::Node::resizeGLObjectBuffers( arg0 );
    }

    virtual void setThreadSafeRefUnref( bool threadSafe ) {
        if( bp::override func_setThreadSafeRefUnref = this->get_override( "setThreadSafeRefUnref" ) )
            func_setThreadSafeRefUnref( threadSafe );
        else{
            this->osg::Node::setThreadSafeRefUnref( threadSafe );
        }
    }
    
    void default_setThreadSafeRefUnref( bool threadSafe ) {
        osg::Node::setThreadSafeRefUnref( threadSafe );
    }

    virtual void traverse( ::osg::NodeVisitor & arg0 ) {
        if( bp::override func_traverse = this->get_override( "traverse" ) )
            func_traverse( boost::ref(arg0) );
        else{
            this->osg::Node::traverse( boost::ref(arg0) );
        }
    }
    
    void default_traverse( ::osg::NodeVisitor & arg0 ) {
        osg::Node::traverse( boost::ref(arg0) );
    }

};

void register_Node_class(){

    { //::osg::Node
        typedef bp::class_< Node_wrapper, bp::bases< osg::Object >, osg::ref_ptr< ::osg::Node >, boost::noncopyable > Node_exposer_t;
        Node_exposer_t Node_exposer = Node_exposer_t( "Node", "\n Base class for all internal nodes in the scene graph.\n    Provides interface for most common node operations (Composite Pattern).\n", bp::no_init );
        bp::scope Node_scope( Node_exposer );
        Node_exposer.def( bp::init< >("\n Construct a node.\n            Initialize the parent list to empty, node name to  and\n            bounding sphere dirty flag to true.\n") );
        { //::osg::Node::accept
        
            typedef void ( ::osg::Node::*accept_function_type )( ::osg::NodeVisitor & ) ;
            typedef void ( Node_wrapper::*default_accept_function_type )( ::osg::NodeVisitor & ) ;
            
            Node_exposer.def( 
                "accept"
                , accept_function_type(&::osg::Node::accept)
                , default_accept_function_type(&Node_wrapper::default_accept)
                , ( bp::arg("nv") ) );
        
        }
        { //::osg::Node::addCullCallback
        
            typedef void ( ::osg::Node::*addCullCallback_function_type )( ::osg::NodeCallback * ) ;
            
            Node_exposer.def( 
                "addCullCallback"
                , addCullCallback_function_type( &::osg::Node::addCullCallback )
                , ( bp::arg("nc") )
                , " Convenience method that sets the cull callback of the node if it doesnt exist, or nest it into the existing one." );
        
        }
        { //::osg::Node::addDescription
        
            typedef void ( ::osg::Node::*addDescription_function_type )( ::std::string const & ) ;
            
            Node_exposer.def( 
                "addDescription"
                , addDescription_function_type( &::osg::Node::addDescription )
                , ( bp::arg("desc") )
                , " Add a description string to the node." );
        
        }
        { //::osg::Node::addEventCallback
        
            typedef void ( ::osg::Node::*addEventCallback_function_type )( ::osg::NodeCallback * ) ;
            
            Node_exposer.def( 
                "addEventCallback"
                , addEventCallback_function_type( &::osg::Node::addEventCallback )
                , ( bp::arg("nc") )
                , " Convenience method that sets the event callback of the node if it doesnt exist, or nest it into the existing one." );
        
        }
        { //::osg::Node::addUpdateCallback
        
            typedef void ( ::osg::Node::*addUpdateCallback_function_type )( ::osg::NodeCallback * ) ;
            
            Node_exposer.def( 
                "addUpdateCallback"
                , addUpdateCallback_function_type( &::osg::Node::addUpdateCallback )
                , ( bp::arg("nc") )
                , " Convenience method that sets the update callback of the node if it doesnt exist, or nest it into the existing one." );
        
        }
        { //::osg::Node::asCamera
        
            typedef ::osg::Camera * ( ::osg::Node::*asCamera_function_type )(  ) ;
            typedef ::osg::Camera * ( Node_wrapper::*default_asCamera_function_type )(  ) ;
            
            Node_exposer.def( 
                "asCamera"
                , asCamera_function_type(&::osg::Node::asCamera)
                , default_asCamera_function_type(&Node_wrapper::default_asCamera)
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::Node::asCamera
        
            typedef ::osg::Camera const * ( ::osg::Node::*asCamera_function_type )(  ) const;
            typedef ::osg::Camera const * ( Node_wrapper::*default_asCamera_function_type )(  ) const;
            
            Node_exposer.def( 
                "asCamera"
                , asCamera_function_type(&::osg::Node::asCamera)
                , default_asCamera_function_type(&Node_wrapper::default_asCamera)
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::Node::asGeode
        
            typedef ::osg::Geode * ( ::osg::Node::*asGeode_function_type )(  ) ;
            typedef ::osg::Geode * ( Node_wrapper::*default_asGeode_function_type )(  ) ;
            
            Node_exposer.def( 
                "asGeode"
                , asGeode_function_type(&::osg::Node::asGeode)
                , default_asGeode_function_type(&Node_wrapper::default_asGeode)
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::Node::asGeode
        
            typedef ::osg::Geode const * ( ::osg::Node::*asGeode_function_type )(  ) const;
            typedef ::osg::Geode const * ( Node_wrapper::*default_asGeode_function_type )(  ) const;
            
            Node_exposer.def( 
                "asGeode"
                , asGeode_function_type(&::osg::Node::asGeode)
                , default_asGeode_function_type(&Node_wrapper::default_asGeode)
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::Node::asGroup
        
            typedef ::osg::Group * ( ::osg::Node::*asGroup_function_type )(  ) ;
            typedef ::osg::Group * ( Node_wrapper::*default_asGroup_function_type )(  ) ;
            
            Node_exposer.def( 
                "asGroup"
                , asGroup_function_type(&::osg::Node::asGroup)
                , default_asGroup_function_type(&Node_wrapper::default_asGroup)
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::Node::asGroup
        
            typedef ::osg::Group const * ( ::osg::Node::*asGroup_function_type )(  ) const;
            typedef ::osg::Group const * ( Node_wrapper::*default_asGroup_function_type )(  ) const;
            
            Node_exposer.def( 
                "asGroup"
                , asGroup_function_type(&::osg::Node::asGroup)
                , default_asGroup_function_type(&Node_wrapper::default_asGroup)
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::Node::asSwitch
        
            typedef ::osg::Switch * ( ::osg::Node::*asSwitch_function_type )(  ) ;
            typedef ::osg::Switch * ( Node_wrapper::*default_asSwitch_function_type )(  ) ;
            
            Node_exposer.def( 
                "asSwitch"
                , asSwitch_function_type(&::osg::Node::asSwitch)
                , default_asSwitch_function_type(&Node_wrapper::default_asSwitch)
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::Node::asSwitch
        
            typedef ::osg::Switch const * ( ::osg::Node::*asSwitch_function_type )(  ) const;
            typedef ::osg::Switch const * ( Node_wrapper::*default_asSwitch_function_type )(  ) const;
            
            Node_exposer.def( 
                "asSwitch"
                , asSwitch_function_type(&::osg::Node::asSwitch)
                , default_asSwitch_function_type(&Node_wrapper::default_asSwitch)
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::Node::asTransform
        
            typedef ::osg::Transform * ( ::osg::Node::*asTransform_function_type )(  ) ;
            typedef ::osg::Transform * ( Node_wrapper::*default_asTransform_function_type )(  ) ;
            
            Node_exposer.def( 
                "asTransform"
                , asTransform_function_type(&::osg::Node::asTransform)
                , default_asTransform_function_type(&Node_wrapper::default_asTransform)
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::Node::asTransform
        
            typedef ::osg::Transform const * ( ::osg::Node::*asTransform_function_type )(  ) const;
            typedef ::osg::Transform const * ( Node_wrapper::*default_asTransform_function_type )(  ) const;
            
            Node_exposer.def( 
                "asTransform"
                , asTransform_function_type(&::osg::Node::asTransform)
                , default_asTransform_function_type(&Node_wrapper::default_asTransform)
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::Node::ascend
        
            typedef void ( ::osg::Node::*ascend_function_type )( ::osg::NodeVisitor & ) ;
            typedef void ( Node_wrapper::*default_ascend_function_type )( ::osg::NodeVisitor & ) ;
            
            Node_exposer.def( 
                "ascend"
                , ascend_function_type(&::osg::Node::ascend)
                , default_ascend_function_type(&Node_wrapper::default_ascend)
                , ( bp::arg("nv") ) );
        
        }
        { //::osg::Node::className
        
            typedef char const * ( ::osg::Node::*className_function_type )(  ) const;
            typedef char const * ( Node_wrapper::*default_className_function_type )(  ) const;
            
            Node_exposer.def( 
                "className"
                , className_function_type(&::osg::Node::className)
                , default_className_function_type(&Node_wrapper::default_className) );
        
        }
        { //::osg::Node::clone
        
            typedef ::osg::Object * ( ::osg::Node::*clone_function_type )( ::osg::CopyOp const & ) const;
            typedef ::osg::Object * ( Node_wrapper::*default_clone_function_type )( ::osg::CopyOp const & ) const;
            
            Node_exposer.def( 
                "clone"
                , clone_function_type(&::osg::Node::clone)
                , default_clone_function_type(&Node_wrapper::default_clone)
                , ( bp::arg("copyop") )
                , bp::return_value_policy< bp::reference_existing_object >() );
        
        }
        { //::osg::Node::cloneType
        
            typedef ::osg::Object * ( ::osg::Node::*cloneType_function_type )(  ) const;
            typedef ::osg::Object * ( Node_wrapper::*default_cloneType_function_type )(  ) const;
            
            Node_exposer.def( 
                "cloneType"
                , cloneType_function_type(&::osg::Node::cloneType)
                , default_cloneType_function_type(&Node_wrapper::default_cloneType)
                , bp::return_value_policy< bp::reference_existing_object >() );
        
        }
        { //::osg::Node::computeBound
        
            typedef ::osg::BoundingSphere ( ::osg::Node::*computeBound_function_type )(  ) const;
            typedef ::osg::BoundingSphere ( Node_wrapper::*default_computeBound_function_type )(  ) const;
            
            Node_exposer.def( 
                "computeBound"
                , computeBound_function_type(&::osg::Node::computeBound)
                , default_computeBound_function_type(&Node_wrapper::default_computeBound) );
        
        }
        { //::osg::Node::containsOccluderNodes
        
            typedef bool ( ::osg::Node::*containsOccluderNodes_function_type )(  ) const;
            
            Node_exposer.def( 
                "containsOccluderNodes"
                , containsOccluderNodes_function_type( &::osg::Node::containsOccluderNodes )
                , " return true if this node is an OccluderNode or the subgraph below this node are OccluderNodes." );
        
        }
        { //::osg::Node::dirtyBound
        
            typedef void ( ::osg::Node::*dirtyBound_function_type )(  ) ;
            
            Node_exposer.def( 
                "dirtyBound"
                , dirtyBound_function_type( &::osg::Node::dirtyBound )
                , " Mark this nodes bounding sphere dirty.\n            Forcing it to be computed on the next call to getBound()." );
        
        }
        { //::osg::Node::getBound
        
            typedef ::osg::BoundingSphere const & ( ::osg::Node::*getBound_function_type )(  ) const;
            
            Node_exposer.def( 
                "getBound"
                , getBound_function_type( &::osg::Node::getBound )
                , bp::return_internal_reference< >()
                , " Get the bounding sphere of node.\n           Using lazy evaluation computes the bounding sphere if it is dirty." );
        
        }
        { //::osg::Node::getComputeBoundingSphereCallback
        
            typedef ::osg::Node::ComputeBoundingSphereCallback * ( ::osg::Node::*getComputeBoundingSphereCallback_function_type )(  ) ;
            
            Node_exposer.def( 
                "getComputeBoundingSphereCallback"
                , getComputeBoundingSphereCallback_function_type( &::osg::Node::getComputeBoundingSphereCallback )
                , bp::return_internal_reference< >()
                , " Get the compute bound callback." );
        
        }
        { //::osg::Node::getComputeBoundingSphereCallback
        
            typedef ::osg::Node::ComputeBoundingSphereCallback const * ( ::osg::Node::*getComputeBoundingSphereCallback_function_type )(  ) const;
            
            Node_exposer.def( 
                "getComputeBoundingSphereCallback"
                , getComputeBoundingSphereCallback_function_type( &::osg::Node::getComputeBoundingSphereCallback )
                , bp::return_internal_reference< >()
                , " Get the const compute bound callback." );
        
        }
        { //::osg::Node::getCullCallback
        
            typedef ::osg::NodeCallback * ( ::osg::Node::*getCullCallback_function_type )(  ) ;
            
            Node_exposer.def( 
                "getCullCallback"
                , getCullCallback_function_type( &::osg::Node::getCullCallback )
                , bp::return_internal_reference< >()
                , " Get cull node callback, called during cull traversal." );
        
        }
        { //::osg::Node::getCullCallback
        
            typedef ::osg::NodeCallback const * ( ::osg::Node::*getCullCallback_function_type )(  ) const;
            
            Node_exposer.def( 
                "getCullCallback"
                , getCullCallback_function_type( &::osg::Node::getCullCallback )
                , bp::return_internal_reference< >()
                , " Get const cull node callback, called during cull traversal." );
        
        }
        { //::osg::Node::getCullingActive
        
            typedef bool ( ::osg::Node::*getCullingActive_function_type )(  ) const;
            
            Node_exposer.def( 
                "getCullingActive"
                , getCullingActive_function_type( &::osg::Node::getCullingActive )
                , " Get the view frustum/small feature _cullingActive flag for this node. Used as a guide\n to the cull traversal." );
        
        }
        { //::osg::Node::getDescription
        
            typedef ::std::string const & ( ::osg::Node::*getDescription_function_type )( unsigned int ) const;
            
            Node_exposer.def( 
                "getDescription"
                , getDescription_function_type( &::osg::Node::getDescription )
                , ( bp::arg("i") )
                , bp::return_value_policy< bp::copy_const_reference >()
                , " Get a single const description of the const node." );
        
        }
        { //::osg::Node::getDescription
        
            typedef ::std::string & ( ::osg::Node::*getDescription_function_type )( unsigned int ) ;
            
            Node_exposer.def( 
                "getDescription"
                , getDescription_function_type( &::osg::Node::getDescription )
                , ( bp::arg("i") )
                , bp::return_internal_reference< >()
                , " Get a single description of the node." );
        
        }
        { //::osg::Node::getDescriptions
        
            typedef ::std::vector< std::string > & ( ::osg::Node::*getDescriptions_function_type )(  ) ;
            
            Node_exposer.def( 
                "getDescriptions"
                , getDescriptions_function_type( &::osg::Node::getDescriptions )
                , bp::return_internal_reference< >()
                , " Get the description list of the node." );
        
        }
        { //::osg::Node::getDescriptions
        
            typedef ::std::vector< std::string > const & ( ::osg::Node::*getDescriptions_function_type )(  ) const;
            
            Node_exposer.def( 
                "getDescriptions"
                , getDescriptions_function_type( &::osg::Node::getDescriptions )
                , bp::return_internal_reference< >()
                , " Get the const description list of the const node." );
        
        }
        { //::osg::Node::getEventCallback
        
            typedef ::osg::NodeCallback * ( ::osg::Node::*getEventCallback_function_type )(  ) ;
            
            Node_exposer.def( 
                "getEventCallback"
                , getEventCallback_function_type( &::osg::Node::getEventCallback )
                , bp::return_internal_reference< >()
                , " Get event node callback, called during event traversal." );
        
        }
        { //::osg::Node::getEventCallback
        
            typedef ::osg::NodeCallback const * ( ::osg::Node::*getEventCallback_function_type )(  ) const;
            
            Node_exposer.def( 
                "getEventCallback"
                , getEventCallback_function_type( &::osg::Node::getEventCallback )
                , bp::return_internal_reference< >()
                , " Get const event node callback, called during event traversal." );
        
        }
        { //::osg::Node::getInitialBound
        
            typedef ::osg::BoundingSphere const & ( ::osg::Node::*getInitialBound_function_type )(  ) const;
            
            Node_exposer.def( 
                "getInitialBound"
                , getInitialBound_function_type( &::osg::Node::getInitialBound )
                , bp::return_internal_reference< >()
                , " Set the initial bounding volume to use when computing the overall bounding volume." );
        
        }
        { //::osg::Node::getNodeMask
        
            typedef unsigned int ( ::osg::Node::*getNodeMask_function_type )(  ) const;
            
            Node_exposer.def( 
                "getNodeMask"
                , getNodeMask_function_type( &::osg::Node::getNodeMask )
                , " Get the node Mask." );
        
        }
        { //::osg::Node::getNumChildrenRequiringEventTraversal
        
            typedef unsigned int ( ::osg::Node::*getNumChildrenRequiringEventTraversal_function_type )(  ) const;
            
            Node_exposer.def( 
                "getNumChildrenRequiringEventTraversal"
                , getNumChildrenRequiringEventTraversal_function_type( &::osg::Node::getNumChildrenRequiringEventTraversal )
                , " Get the number of Children of this node which require Event traversal,\n since they have an Event Callback attached to them or their children." );
        
        }
        { //::osg::Node::getNumChildrenRequiringUpdateTraversal
        
            typedef unsigned int ( ::osg::Node::*getNumChildrenRequiringUpdateTraversal_function_type )(  ) const;
            
            Node_exposer.def( 
                "getNumChildrenRequiringUpdateTraversal"
                , getNumChildrenRequiringUpdateTraversal_function_type( &::osg::Node::getNumChildrenRequiringUpdateTraversal )
                , " Get the number of Children of this node which require Update traversal,\n since they have an Update Callback attached to them or their children." );
        
        }
        { //::osg::Node::getNumChildrenWithCullingDisabled
        
            typedef unsigned int ( ::osg::Node::*getNumChildrenWithCullingDisabled_function_type )(  ) const;
            
            Node_exposer.def( 
                "getNumChildrenWithCullingDisabled"
                , getNumChildrenWithCullingDisabled_function_type( &::osg::Node::getNumChildrenWithCullingDisabled )
                , " Get the number of Children of this node which have culling disabled." );
        
        }
        { //::osg::Node::getNumChildrenWithOccluderNodes
        
            typedef unsigned int ( ::osg::Node::*getNumChildrenWithOccluderNodes_function_type )(  ) const;
            
            Node_exposer.def( 
                "getNumChildrenWithOccluderNodes"
                , getNumChildrenWithOccluderNodes_function_type( &::osg::Node::getNumChildrenWithOccluderNodes )
                , " Get the number of Children of this node which are or have OccluderNodes." );
        
        }
        { //::osg::Node::getNumDescriptions
        
            typedef unsigned int ( ::osg::Node::*getNumDescriptions_function_type )(  ) const;
            
            Node_exposer.def( 
                "getNumDescriptions"
                , getNumDescriptions_function_type( &::osg::Node::getNumDescriptions )
                , " Get the number of descriptions of the node." );
        
        }
        { //::osg::Node::getNumParents
        
            typedef unsigned int ( ::osg::Node::*getNumParents_function_type )(  ) const;
            
            Node_exposer.def( 
                "getNumParents"
                , getNumParents_function_type( &::osg::Node::getNumParents )
                , " Get the number of parents of node.\n Return: the number of parents of this node." );
        
        }
        { //::osg::Node::getOrCreateStateSet
        
            typedef ::osg::StateSet * ( ::osg::Node::*getOrCreateStateSet_function_type )(  ) ;
            
            Node_exposer.def( 
                "getOrCreateStateSet"
                , getOrCreateStateSet_function_type( &::osg::Node::getOrCreateStateSet )
                , bp::return_internal_reference< >()
                , " return the nodes StateSet, if one does not already exist create it\n set the node and return the newly created StateSet. This ensures\n that a valid StateSet is always returned and can be used directly." );
        
        }
        { //::osg::Node::getParent
        
            typedef ::osg::Group * ( ::osg::Node::*getParent_function_type )( unsigned int ) ;
            
            Node_exposer.def( 
                "getParent"
                , getParent_function_type( &::osg::Node::getParent )
                , ( bp::arg("i") )
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::Node::getParent
        
            typedef ::osg::Group const * ( ::osg::Node::*getParent_function_type )( unsigned int ) const;
            
            Node_exposer.def( 
                "getParent"
                , getParent_function_type( &::osg::Node::getParent )
                , ( bp::arg("i") )
                , bp::return_internal_reference< >()
                , " Get a single const parent of node.\n @param i: index of the parent to get.\n Return: the parent i." );
        
        }
        { //::osg::Node::getParentalNodePaths
        
            typedef ::osg::NodePathList ( ::osg::Node::*getParentalNodePaths_function_type )( ::osg::Node * ) const;
            
            Node_exposer.def( 
                "getParentalNodePaths"
                , getParentalNodePaths_function_type( &::osg::Node::getParentalNodePaths )
                , ( bp::arg("haltTraversalAtNode")=bp::object() )
                , " Get the list of node paths parent paths.\n The optional Node* haltTraversalAtNode allows the user to prevent traversal beyond a specifed node." );
        
        }
        { //::osg::Node::getParents
        
            typedef ::std::vector< osg::Group* > const & ( ::osg::Node::*getParents_function_type )(  ) const;
            
            Node_exposer.def( 
                "getParents"
                , getParents_function_type( &::osg::Node::getParents )
                , bp::return_internal_reference< >()
                , " Get the parent list of node." );
        
        }
        { //::osg::Node::getParents
        
            typedef ::std::vector< osg::Group* > ( ::osg::Node::*getParents_function_type )(  ) ;
            
            Node_exposer.def( 
                "getParents"
                , getParents_function_type( &::osg::Node::getParents )
                , " Get the a copy of parent list of node. A copy is returned to\n prevent modification of the parent list." );
        
        }
        { //::osg::Node::getStateSet
        
            typedef ::osg::StateSet * ( ::osg::Node::*getStateSet_function_type )(  ) ;
            
            Node_exposer.def( 
                "getStateSet"
                , getStateSet_function_type( &::osg::Node::getStateSet )
                , bp::return_internal_reference< >()
                , " Return the nodes StateSet. returns NULL if a stateset is not attached." );
        
        }
        { //::osg::Node::getStateSet
        
            typedef ::osg::StateSet const * ( ::osg::Node::*getStateSet_function_type )(  ) const;
            
            Node_exposer.def( 
                "getStateSet"
                , getStateSet_function_type( &::osg::Node::getStateSet )
                , bp::return_internal_reference< >()
                , " Return the nodes const StateSet. Returns NULL if a stateset is not attached." );
        
        }
        { //::osg::Node::getUpdateCallback
        
            typedef ::osg::NodeCallback * ( ::osg::Node::*getUpdateCallback_function_type )(  ) ;
            
            Node_exposer.def( 
                "getUpdateCallback"
                , getUpdateCallback_function_type( &::osg::Node::getUpdateCallback )
                , bp::return_internal_reference< >()
                , " Get update node callback, called during update traversal." );
        
        }
        { //::osg::Node::getUpdateCallback
        
            typedef ::osg::NodeCallback const * ( ::osg::Node::*getUpdateCallback_function_type )(  ) const;
            
            Node_exposer.def( 
                "getUpdateCallback"
                , getUpdateCallback_function_type( &::osg::Node::getUpdateCallback )
                , bp::return_internal_reference< >()
                , " Get const update node callback, called during update traversal." );
        
        }
        { //::osg::Node::getWorldMatrices
        
            typedef ::osg::MatrixList ( ::osg::Node::*getWorldMatrices_function_type )( ::osg::Node const * ) const;
            
            Node_exposer.def( 
                "getWorldMatrices"
                , getWorldMatrices_function_type( &::osg::Node::getWorldMatrices )
                , ( bp::arg("haltTraversalAtNode")=bp::object() )
                , " Get the list of matrices that transform this node from local coordinates to world coordinates.\n The optional Node* haltTraversalAtNode allows the user to prevent traversal beyond a specifed node." );
        
        }
        { //::osg::Node::isCullingActive
        
            typedef bool ( ::osg::Node::*isCullingActive_function_type )(  ) const;
            
            Node_exposer.def( 
                "isCullingActive"
                , isCullingActive_function_type( &::osg::Node::isCullingActive )
                , " Return true if this node can be culled by view frustum, occlusion or small feature culling during the cull traversal.\n Note, returns true only if no children have culling disabled, and the local _cullingActive flag is true." );
        
        }
        { //::osg::Node::isSameKindAs
        
            typedef bool ( ::osg::Node::*isSameKindAs_function_type )( ::osg::Object const * ) const;
            typedef bool ( Node_wrapper::*default_isSameKindAs_function_type )( ::osg::Object const * ) const;
            
            Node_exposer.def( 
                "isSameKindAs"
                , isSameKindAs_function_type(&::osg::Node::isSameKindAs)
                , default_isSameKindAs_function_type(&Node_wrapper::default_isSameKindAs)
                , ( bp::arg("obj") ) );
        
        }
        { //::osg::Node::libraryName
        
            typedef char const * ( ::osg::Node::*libraryName_function_type )(  ) const;
            typedef char const * ( Node_wrapper::*default_libraryName_function_type )(  ) const;
            
            Node_exposer.def( 
                "libraryName"
                , libraryName_function_type(&::osg::Node::libraryName)
                , default_libraryName_function_type(&Node_wrapper::default_libraryName) );
        
        }
        { //::osg::Node::removeCullCallback
        
            typedef void ( ::osg::Node::*removeCullCallback_function_type )( ::osg::NodeCallback * ) ;
            
            Node_exposer.def( 
                "removeCullCallback"
                , removeCullCallback_function_type( &::osg::Node::removeCullCallback )
                , ( bp::arg("nc") )
                , " Convenience method that removes a given callback from a node, even if that callback is nested. There is no error return in case the given callback is not found." );
        
        }
        { //::osg::Node::removeEventCallback
        
            typedef void ( ::osg::Node::*removeEventCallback_function_type )( ::osg::NodeCallback * ) ;
            
            Node_exposer.def( 
                "removeEventCallback"
                , removeEventCallback_function_type( &::osg::Node::removeEventCallback )
                , ( bp::arg("nc") )
                , " Convenience method that removes a given callback from a node, even if that callback is nested. There is no error return in case the given callback is not found." );
        
        }
        { //::osg::Node::removeUpdateCallback
        
            typedef void ( ::osg::Node::*removeUpdateCallback_function_type )( ::osg::NodeCallback * ) ;
            
            Node_exposer.def( 
                "removeUpdateCallback"
                , removeUpdateCallback_function_type( &::osg::Node::removeUpdateCallback )
                , ( bp::arg("nc") )
                , " Convenience method that removes a given callback from a node, even if that callback is nested. There is no error return in case the given callback is not found." );
        
        }
        { //::osg::Node::resizeGLObjectBuffers
        
            typedef void ( ::osg::Node::*resizeGLObjectBuffers_function_type )( unsigned int ) ;
            typedef void ( Node_wrapper::*default_resizeGLObjectBuffers_function_type )( unsigned int ) ;
            
            Node_exposer.def( 
                "resizeGLObjectBuffers"
                , resizeGLObjectBuffers_function_type(&::osg::Node::resizeGLObjectBuffers)
                , default_resizeGLObjectBuffers_function_type(&Node_wrapper::default_resizeGLObjectBuffers)
                , ( bp::arg("arg0") ) );
        
        }
        { //::osg::Node::setComputeBoundingSphereCallback
        
            typedef void ( ::osg::Node::*setComputeBoundingSphereCallback_function_type )( ::osg::Node::ComputeBoundingSphereCallback * ) ;
            
            Node_exposer.def( 
                "setComputeBoundingSphereCallback"
                , setComputeBoundingSphereCallback_function_type( &::osg::Node::setComputeBoundingSphereCallback )
                , ( bp::arg("callback") )
                , " Set the compute bound callback to override the default computeBound." );
        
        }
        { //::osg::Node::setCullCallback
        
            typedef void ( ::osg::Node::*setCullCallback_function_type )( ::osg::NodeCallback * ) ;
            
            Node_exposer.def( 
                "setCullCallback"
                , setCullCallback_function_type( &::osg::Node::setCullCallback )
                , ( bp::arg("nc") )
                , " Set cull node callback, called during cull traversal." );
        
        }
        { //::osg::Node::setCullingActive
        
            typedef void ( ::osg::Node::*setCullingActive_function_type )( bool ) ;
            
            Node_exposer.def( 
                "setCullingActive"
                , setCullingActive_function_type( &::osg::Node::setCullingActive )
                , ( bp::arg("active") )
                , " Set the view frustum/small feature culling of this node to be active or inactive.\n The default value is true for _cullingActive. Used as a guide\n to the cull traversal." );
        
        }
        { //::osg::Node::setDescriptions
        
            typedef void ( ::osg::Node::*setDescriptions_function_type )( ::std::vector< std::string > const & ) ;
            
            Node_exposer.def( 
                "setDescriptions"
                , setDescriptions_function_type( &::osg::Node::setDescriptions )
                , ( bp::arg("descriptions") )
                , " Set the list of string descriptions." );
        
        }
        { //::osg::Node::setEventCallback
        
            typedef void ( ::osg::Node::*setEventCallback_function_type )( ::osg::NodeCallback * ) ;
            
            Node_exposer.def( 
                "setEventCallback"
                , setEventCallback_function_type( &::osg::Node::setEventCallback )
                , ( bp::arg("nc") )
                , " Set event node callback, called during event traversal." );
        
        }
        { //::osg::Node::setInitialBound
        
            typedef void ( ::osg::Node::*setInitialBound_function_type )( ::osg::BoundingSphere const & ) ;
            
            Node_exposer.def( 
                "setInitialBound"
                , setInitialBound_function_type( &::osg::Node::setInitialBound )
                , ( bp::arg("bsphere") )
                , " Set the initial bounding volume to use when computing the overall bounding volume." );
        
        }
        { //::osg::Node::setNodeMask
        
            typedef void ( ::osg::Node::*setNodeMask_function_type )( unsigned int ) ;
            
            Node_exposer.def( 
                "setNodeMask"
                , setNodeMask_function_type( &::osg::Node::setNodeMask )
                , ( bp::arg("nm") )
                , " Set the node mask." );
        
        }
        { //::osg::Node::setStateSet
        
            typedef void ( ::osg::Node::*setStateSet_function_type )( ::osg::StateSet * ) ;
            
            Node_exposer.def( 
                "setStateSet"
                , setStateSet_function_type( &::osg::Node::setStateSet )
                , ( bp::arg("stateset") )
                , " Set the nodes StateSet." );
        
        }
        { //::osg::Node::setThreadSafeRefUnref
        
            typedef void ( ::osg::Node::*setThreadSafeRefUnref_function_type )( bool ) ;
            typedef void ( Node_wrapper::*default_setThreadSafeRefUnref_function_type )( bool ) ;
            
            Node_exposer.def( 
                "setThreadSafeRefUnref"
                , setThreadSafeRefUnref_function_type(&::osg::Node::setThreadSafeRefUnref)
                , default_setThreadSafeRefUnref_function_type(&Node_wrapper::default_setThreadSafeRefUnref)
                , ( bp::arg("threadSafe") ) );
        
        }
        { //::osg::Node::setUpdateCallback
        
            typedef void ( ::osg::Node::*setUpdateCallback_function_type )( ::osg::NodeCallback * ) ;
            
            Node_exposer.def( 
                "setUpdateCallback"
                , setUpdateCallback_function_type( &::osg::Node::setUpdateCallback )
                , ( bp::arg("nc") )
                , " Set update node callback, called during update traversal." );
        
        }
        { //::osg::Node::traverse
        
            typedef void ( ::osg::Node::*traverse_function_type )( ::osg::NodeVisitor & ) ;
            typedef void ( Node_wrapper::*default_traverse_function_type )( ::osg::NodeVisitor & ) ;
            
            Node_exposer.def( 
                "traverse"
                , traverse_function_type(&::osg::Node::traverse)
                , default_traverse_function_type(&Node_wrapper::default_traverse)
                , ( bp::arg("arg0") ) );
        
        }
        { //property "stateSet"[fget=::osg::Node::getOrCreateStateSet, fset=::osg::Node::setStateSet]
        
            typedef ::osg::StateSet * ( ::osg::Node::*fget )(  ) ;
            typedef void ( ::osg::Node::*fset )( ::osg::StateSet * ) ;
            
            Node_exposer.add_property( 
                "stateSet"
                , bp::make_function( 
                      fget( &::osg::Node::getOrCreateStateSet )
                    , bp::return_internal_reference< >() ) 
                , fset( &::osg::Node::setStateSet ) );
        
        }
    }

}
