// This file has been generated by Py++.

#include "boost/python.hpp"
#include "__array_1.pypp.hpp"
#include "wrap_osg.h"
#include "wrap_referenced.h"
#include "State.pypp.hpp"

namespace bp = boost::python;

struct State_wrapper : osg::State, bp::wrapper< osg::State > {

    struct DynamicObjectRenderingCompletedCallback_wrapper : osg::State::DynamicObjectRenderingCompletedCallback, bp::wrapper< osg::State::DynamicObjectRenderingCompletedCallback > {
    
        DynamicObjectRenderingCompletedCallback_wrapper()
        : osg::State::DynamicObjectRenderingCompletedCallback()
          , bp::wrapper< osg::State::DynamicObjectRenderingCompletedCallback >(){
            // null constructor
            
        }
    
        virtual void completed( ::osg::State * arg0 ){
            bp::override func_completed = this->get_override( "completed" );
            func_completed( boost::python::ptr(arg0) );
        }
    
    };

    State_wrapper( )
    : osg::State( )
      , bp::wrapper< osg::State >(){
        // null constructor
    
    }

    virtual void frameCompleted(  ) {
        if( bp::override func_frameCompleted = this->get_override( "frameCompleted" ) )
            func_frameCompleted(  );
        else{
            this->osg::State::frameCompleted(  );
        }
    }
    
    void default_frameCompleted(  ) {
        osg::State::frameCompleted( );
    }

    virtual void objectDeleted( void * object ) {
        if( bp::override func_objectDeleted = this->get_override( "objectDeleted" ) )
            func_objectDeleted( object );
        else{
            this->osg::State::objectDeleted( object );
        }
    }
    
    void default_objectDeleted( void * object ) {
        osg::State::objectDeleted( object );
    }

    static pyplusplus::containers::static_sized::array_1_t< ::std::vector<unsigned int, std::allocator<unsigned int> >, 4>
    pyplusplus__quadIndicesGLuint_wrapper( ::osg::State & inst ){
        return pyplusplus::containers::static_sized::array_1_t< ::std::vector<unsigned int, std::allocator<unsigned int> >, 4>( inst._quadIndicesGLuint );
    }

    static pyplusplus::containers::static_sized::array_1_t< ::std::vector<unsigned short, std::allocator<unsigned short> >, 4>
    pyplusplus__quadIndicesGLushort_wrapper( ::osg::State & inst ){
        return pyplusplus::containers::static_sized::array_1_t< ::std::vector<unsigned short, std::allocator<unsigned short> >, 4>( inst._quadIndicesGLushort );
    }

};

void register_State_class(){

    { //::osg::State
        typedef bp::class_< State_wrapper, bp::bases< osg::Referenced, osg::Observer >, osg::ref_ptr< ::osg::State >, boost::noncopyable > State_exposer_t;
        State_exposer_t State_exposer = State_exposer_t( "State", "\n Encapsulates the current applied OpenGL modes, attributes and vertex arrays settings,\n implements lazy state updating and provides accessors for querying the current state.\n The venerable Red Book says that OpenGL is a state machine, and this class\n represents the OpenGL state in OSG. Furthermore,  State also has other\n important features:\n - It works as a stack of states (see  pushStateSet() and\n    popStateSet()). Manipulating this stack of OpenGL states manually is\n   seldom needed, since OSG does this in the most common situations.\n - It implements lazy state updating. This means that, if one requests a\n   state change and that particular state is already in the requested state,\n   no OpenGL call will be made. This ensures that the OpenGL pipeline is not\n   stalled by unnecessary state changes.\n - It allows to query the current OpenGL state without calls to  glGet*(),\n   which typically stall the graphics pipeline (see, for instance,\n    captureCurrentState() and  getModelViewMatrix()).\n", bp::no_init );
        bp::scope State_scope( State_exposer );
        bp::enum_< osg::State::CheckForGLErrors>("CheckForGLErrors")
            .value("NEVER_CHECK_GL_ERRORS", osg::State::NEVER_CHECK_GL_ERRORS)
            .value("ONCE_PER_FRAME", osg::State::ONCE_PER_FRAME)
            .value("ONCE_PER_ATTRIBUTE", osg::State::ONCE_PER_ATTRIBUTE)
            .export_values()
            ;
        bp::class_< State_wrapper::DynamicObjectRenderingCompletedCallback_wrapper, bp::bases< osg::Referenced >, osg::ref_ptr< State_wrapper::DynamicObjectRenderingCompletedCallback_wrapper >, boost::noncopyable >( "DynamicObjectRenderingCompletedCallback", bp::no_init )    
            .def( 
                "completed"
                , bp::pure_virtual( (void ( ::osg::State::DynamicObjectRenderingCompletedCallback::* )( ::osg::State * ) )(&::osg::State::DynamicObjectRenderingCompletedCallback::completed) )
                , ( bp::arg("arg0") ) );
        State_exposer.def( bp::init< >("\n Encapsulates the current applied OpenGL modes, attributes and vertex arrays settings,\n implements lazy state updating and provides accessors for querying the current state.\n The venerable Red Book says that OpenGL is a state machine, and this class\n represents the OpenGL state in OSG. Furthermore,  State also has other\n important features:\n - It works as a stack of states (see  pushStateSet() and\n    popStateSet()). Manipulating this stack of OpenGL states manually is\n   seldom needed, since OSG does this in the most common situations.\n - It implements lazy state updating. This means that, if one requests a\n   state change and that particular state is already in the requested state,\n   no OpenGL call will be made. This ensures that the OpenGL pipeline is not\n   stalled by unnecessary state changes.\n - It allows to query the current OpenGL state without calls to  glGet*(),\n   which typically stall the graphics pipeline (see, for instance,\n    captureCurrentState() and  getModelViewMatrix()).\n") );
        { //::osg::State::Color
        
            typedef void ( ::osg::State::*Color_function_type )( float,float,float,float ) ;
            
            State_exposer.def( 
                "Color"
                , Color_function_type( &::osg::State::Color )
                , ( bp::arg("r"), bp::arg("g"), bp::arg("b"), bp::arg("a")=1.0e+0f ) );
        
        }
        { //::osg::State::MultiTexCoord
        
            typedef void ( ::osg::State::*MultiTexCoord_function_type )( unsigned int,float,float,float,float ) ;
            
            State_exposer.def( 
                "MultiTexCoord"
                , MultiTexCoord_function_type( &::osg::State::MultiTexCoord )
                , ( bp::arg("unit"), bp::arg("x"), bp::arg("y")=0.0f, bp::arg("z")=0.0f, bp::arg("w")=1.0e+0f ) );
        
        }
        { //::osg::State::Normal
        
            typedef void ( ::osg::State::*Normal_function_type )( float,float,float ) ;
            
            State_exposer.def( 
                "Normal"
                , Normal_function_type( &::osg::State::Normal )
                , ( bp::arg("x"), bp::arg("y"), bp::arg("z") ) );
        
        }
        { //::osg::State::TexCoord
        
            typedef void ( ::osg::State::*TexCoord_function_type )( float,float,float,float ) ;
            
            State_exposer.def( 
                "TexCoord"
                , TexCoord_function_type( &::osg::State::TexCoord )
                , ( bp::arg("x"), bp::arg("y")=0.0f, bp::arg("z")=0.0f, bp::arg("w")=1.0e+0f ) );
        
        }
        { //::osg::State::VerteAttrib
        
            typedef void ( ::osg::State::*VerteAttrib_function_type )( unsigned int,float,float,float,float ) ;
            
            State_exposer.def( 
                "VerteAttrib"
                , VerteAttrib_function_type( &::osg::State::VerteAttrib )
                , ( bp::arg("location"), bp::arg("x"), bp::arg("y")=0.0f, bp::arg("z")=0.0f, bp::arg("w")=0.0f ) );
        
        }
        { //::osg::State::Vertex
        
            typedef void ( ::osg::State::*Vertex_function_type )( float,float,float,float ) ;
            
            State_exposer.def( 
                "Vertex"
                , Vertex_function_type( &::osg::State::Vertex )
                , ( bp::arg("x"), bp::arg("y"), bp::arg("z"), bp::arg("w")=1.0e+0f ) );
        
        }
        { //::osg::State::apply
        
            typedef void ( ::osg::State::*apply_function_type )( ::osg::StateSet const * ) ;
            
            State_exposer.def( 
                "apply"
                , apply_function_type( &::osg::State::apply )
                , ( bp::arg("dstate") )
                , " Apply stateset." );
        
        }
        { //::osg::State::apply
        
            typedef void ( ::osg::State::*apply_function_type )(  ) ;
            
            State_exposer.def( 
                "apply"
                , apply_function_type( &::osg::State::apply )
                , " Updates the OpenGL state so that it matches the  StateSet at the\n top of the stack of <tt>StateSet</tt>s maintained internally by a\n  State." );
        
        }
        { //::osg::State::applyAttribute
        
            typedef bool ( ::osg::State::*applyAttribute_function_type )( ::osg::StateAttribute const * ) ;
            
            State_exposer.def( 
                "applyAttribute"
                , applyAttribute_function_type( &::osg::State::applyAttribute )
                , ( bp::arg("attribute") )
                , " Apply an attribute if required." );
        
        }
        { //::osg::State::applyDisablingOfVertexAttributes
        
            typedef void ( ::osg::State::*applyDisablingOfVertexAttributes_function_type )(  ) ;
            
            State_exposer.def( 
                "applyDisablingOfVertexAttributes"
                , applyDisablingOfVertexAttributes_function_type( &::osg::State::applyDisablingOfVertexAttributes )
                , " Disable all the vertex attributes that have been marked as to be disabled." );
        
        }
        { //::osg::State::applyMode
        
            typedef bool ( ::osg::State::*applyMode_function_type )( ::GLenum,bool ) ;
            
            State_exposer.def( 
                "applyMode"
                , applyMode_function_type( &::osg::State::applyMode )
                , ( bp::arg("mode"), bp::arg("enabled") )
                , " Apply an OpenGL mode if required. This is a wrapper around\n  glEnable() and  glDisable(), that just actually calls these\n functions if the  enabled flag is different than the current\n state.\n Return:  true if the state was actually changed.  false\n         otherwise. Notice that a  false return does not indicate\n         an error, it just means that the mode was already set to the\n         same value as the  enabled parameter." );
        
        }
        { //::osg::State::applyModelViewAndProjectionUniformsIfRequired
        
            typedef void ( ::osg::State::*applyModelViewAndProjectionUniformsIfRequired_function_type )(  ) ;
            
            State_exposer.def( 
                "applyModelViewAndProjectionUniformsIfRequired"
                , applyModelViewAndProjectionUniformsIfRequired_function_type( &::osg::State::applyModelViewAndProjectionUniformsIfRequired ) );
        
        }
        { //::osg::State::applyModelViewMatrix
        
            typedef void ( ::osg::State::*applyModelViewMatrix_function_type )( ::osg::RefMatrix const * ) ;
            
            State_exposer.def( 
                "applyModelViewMatrix"
                , applyModelViewMatrix_function_type( &::osg::State::applyModelViewMatrix )
                , ( bp::arg("matrix") ) );
        
        }
        { //::osg::State::applyModelViewMatrix
        
            typedef void ( ::osg::State::*applyModelViewMatrix_function_type )( ::osg::Matrix const & ) ;
            
            State_exposer.def( 
                "applyModelViewMatrix"
                , applyModelViewMatrix_function_type( &::osg::State::applyModelViewMatrix )
                , ( bp::arg("arg0") ) );
        
        }
        { //::osg::State::applyProjectionMatrix
        
            typedef void ( ::osg::State::*applyProjectionMatrix_function_type )( ::osg::RefMatrix const * ) ;
            
            State_exposer.def( 
                "applyProjectionMatrix"
                , applyProjectionMatrix_function_type( &::osg::State::applyProjectionMatrix )
                , ( bp::arg("matrix") ) );
        
        }
        { //::osg::State::applyShaderComposition
        
            typedef void ( ::osg::State::*applyShaderComposition_function_type )(  ) ;
            
            State_exposer.def( 
                "applyShaderComposition"
                , applyShaderComposition_function_type( &::osg::State::applyShaderComposition )
                , " Apply any shader composed state." );
        
        }
        { //::osg::State::applyShaderCompositionUniform
        
            typedef void ( ::osg::State::*applyShaderCompositionUniform_function_type )( ::osg::Uniform const *,unsigned int ) ;
            
            State_exposer.def( 
                "applyShaderCompositionUniform"
                , applyShaderCompositionUniform_function_type( &::osg::State::applyShaderCompositionUniform )
                , ( bp::arg("uniform"), bp::arg("value")=(unsigned int)(ON) )
                , " Convinience method for StateAttribute:::apply(State&) methods to pass on their uniforms to osg::State so it can apply them at the appropriate point." );
        
        }
        { //::osg::State::applyTextureAttribute
        
            typedef bool ( ::osg::State::*applyTextureAttribute_function_type )( unsigned int,::osg::StateAttribute const * ) ;
            
            State_exposer.def( 
                "applyTextureAttribute"
                , applyTextureAttribute_function_type( &::osg::State::applyTextureAttribute )
                , ( bp::arg("unit"), bp::arg("attribute") ) );
        
        }
        { //::osg::State::applyTextureMode
        
            typedef bool ( ::osg::State::*applyTextureMode_function_type )( unsigned int,::GLenum,bool ) ;
            
            State_exposer.def( 
                "applyTextureMode"
                , applyTextureMode_function_type( &::osg::State::applyTextureMode )
                , ( bp::arg("unit"), bp::arg("mode"), bp::arg("enabled") ) );
        
        }
        { //::osg::State::bindElementBufferObject
        
            typedef void ( ::osg::State::*bindElementBufferObject_function_type )( ::osg::GLBufferObject * ) ;
            
            State_exposer.def( 
                "bindElementBufferObject"
                , bindElementBufferObject_function_type( &::osg::State::bindElementBufferObject )
                , ( bp::arg("ebo") ) );
        
        }
        { //::osg::State::bindPixelBufferObject
        
            typedef void ( ::osg::State::*bindPixelBufferObject_function_type )( ::osg::GLBufferObject * ) ;
            
            State_exposer.def( 
                "bindPixelBufferObject"
                , bindPixelBufferObject_function_type( &::osg::State::bindPixelBufferObject )
                , ( bp::arg("pbo") ) );
        
        }
        { //::osg::State::bindVertexBufferObject
        
            typedef void ( ::osg::State::*bindVertexBufferObject_function_type )( ::osg::GLBufferObject * ) ;
            
            State_exposer.def( 
                "bindVertexBufferObject"
                , bindVertexBufferObject_function_type( &::osg::State::bindVertexBufferObject )
                , ( bp::arg("vbo") ) );
        
        }
        { //::osg::State::captureCurrentState
        
            typedef void ( ::osg::State::*captureCurrentState_function_type )( ::osg::StateSet & ) const;
            
            State_exposer.def( 
                "captureCurrentState"
                , captureCurrentState_function_type( &::osg::State::captureCurrentState )
                , ( bp::arg("stateset") )
                , " Copy the modes and attributes which capture the current state." );
        
        }
        { //::osg::State::checkGLErrors
        
            typedef bool ( ::osg::State::*checkGLErrors_function_type )( char const * ) const;
            
            State_exposer.def( 
                "checkGLErrors"
                , checkGLErrors_function_type( &::osg::State::checkGLErrors )
                , ( bp::arg("str") ) );
        
        }
        { //::osg::State::checkGLErrors
        
            typedef bool ( ::osg::State::*checkGLErrors_function_type )( ::GLenum ) const;
            
            State_exposer.def( 
                "checkGLErrors"
                , checkGLErrors_function_type( &::osg::State::checkGLErrors )
                , ( bp::arg("mode") ) );
        
        }
        { //::osg::State::checkGLErrors
        
            typedef bool ( ::osg::State::*checkGLErrors_function_type )( ::osg::StateAttribute const * ) const;
            
            State_exposer.def( 
                "checkGLErrors"
                , checkGLErrors_function_type( &::osg::State::checkGLErrors )
                , ( bp::arg("attribute") ) );
        
        }
        { //::osg::State::convertVertexShaderSourceToOsgBuiltIns
        
            typedef bool ( ::osg::State::*convertVertexShaderSourceToOsgBuiltIns_function_type )( ::std::string & ) const;
            
            State_exposer.def( 
                "convertVertexShaderSourceToOsgBuiltIns"
                , convertVertexShaderSourceToOsgBuiltIns_function_type( &::osg::State::convertVertexShaderSourceToOsgBuiltIns )
                , ( bp::arg("source") ) );
        
        }
        { //::osg::State::decrementDynamicObjectCount
        
            typedef void ( ::osg::State::*decrementDynamicObjectCount_function_type )(  ) ;
            
            State_exposer.def( 
                "decrementDynamicObjectCount"
                , decrementDynamicObjectCount_function_type( &::osg::State::decrementDynamicObjectCount )
                , " Decrement the number of dynamic objects left to render this frame, and once the count goes to zero call the\n DynamicObjectRenderingCompletedCallback to inform of completion." );
        
        }
        { //::osg::State::dirtyAllAttributes
        
            typedef void ( ::osg::State::*dirtyAllAttributes_function_type )(  ) ;
            
            State_exposer.def( 
                "dirtyAllAttributes"
                , dirtyAllAttributes_function_type( &::osg::State::dirtyAllAttributes )
                , " Dirty the modes attributes previously applied in osg::State." );
        
        }
        { //::osg::State::dirtyAllModes
        
            typedef void ( ::osg::State::*dirtyAllModes_function_type )(  ) ;
            
            State_exposer.def( 
                "dirtyAllModes"
                , dirtyAllModes_function_type( &::osg::State::dirtyAllModes )
                , " Dirty the modes previously applied in osg::State." );
        
        }
        { //::osg::State::dirtyAllVertexArrays
        
            typedef void ( ::osg::State::*dirtyAllVertexArrays_function_type )(  ) ;
            
            State_exposer.def( 
                "dirtyAllVertexArrays"
                , dirtyAllVertexArrays_function_type( &::osg::State::dirtyAllVertexArrays )
                , " dirty the vertex, normal, color, tex coords, secondary color, fog coord and index arrays." );
        
        }
        { //::osg::State::dirtyColorPointer
        
            typedef void ( ::osg::State::*dirtyColorPointer_function_type )(  ) ;
            
            State_exposer.def( 
                "dirtyColorPointer"
                , dirtyColorPointer_function_type( &::osg::State::dirtyColorPointer ) );
        
        }
        { //::osg::State::dirtyFogCoordPointer
        
            typedef void ( ::osg::State::*dirtyFogCoordPointer_function_type )(  ) ;
            
            State_exposer.def( 
                "dirtyFogCoordPointer"
                , dirtyFogCoordPointer_function_type( &::osg::State::dirtyFogCoordPointer ) );
        
        }
        { //::osg::State::dirtyNormalPointer
        
            typedef void ( ::osg::State::*dirtyNormalPointer_function_type )(  ) ;
            
            State_exposer.def( 
                "dirtyNormalPointer"
                , dirtyNormalPointer_function_type( &::osg::State::dirtyNormalPointer ) );
        
        }
        { //::osg::State::dirtySecondaryColorPointer
        
            typedef void ( ::osg::State::*dirtySecondaryColorPointer_function_type )(  ) ;
            
            State_exposer.def( 
                "dirtySecondaryColorPointer"
                , dirtySecondaryColorPointer_function_type( &::osg::State::dirtySecondaryColorPointer ) );
        
        }
        { //::osg::State::dirtyTexCoordPointer
        
            typedef void ( ::osg::State::*dirtyTexCoordPointer_function_type )( unsigned int ) ;
            
            State_exposer.def( 
                "dirtyTexCoordPointer"
                , dirtyTexCoordPointer_function_type( &::osg::State::dirtyTexCoordPointer )
                , ( bp::arg("unit") ) );
        
        }
        { //::osg::State::dirtyTexCoordPointersAboveAndIncluding
        
            typedef void ( ::osg::State::*dirtyTexCoordPointersAboveAndIncluding_function_type )( unsigned int ) ;
            
            State_exposer.def( 
                "dirtyTexCoordPointersAboveAndIncluding"
                , dirtyTexCoordPointersAboveAndIncluding_function_type( &::osg::State::dirtyTexCoordPointersAboveAndIncluding )
                , ( bp::arg("unit") ) );
        
        }
        { //::osg::State::dirtyVertexAttribPointer
        
            typedef void ( ::osg::State::*dirtyVertexAttribPointer_function_type )( unsigned int ) ;
            
            State_exposer.def( 
                "dirtyVertexAttribPointer"
                , dirtyVertexAttribPointer_function_type( &::osg::State::dirtyVertexAttribPointer )
                , ( bp::arg("index") ) );
        
        }
        { //::osg::State::dirtyVertexAttribPointersAboveAndIncluding
        
            typedef void ( ::osg::State::*dirtyVertexAttribPointersAboveAndIncluding_function_type )( unsigned int ) ;
            
            State_exposer.def( 
                "dirtyVertexAttribPointersAboveAndIncluding"
                , dirtyVertexAttribPointersAboveAndIncluding_function_type( &::osg::State::dirtyVertexAttribPointersAboveAndIncluding )
                , ( bp::arg("index") ) );
        
        }
        { //::osg::State::dirtyVertexPointer
        
            typedef void ( ::osg::State::*dirtyVertexPointer_function_type )(  ) ;
            
            State_exposer.def( 
                "dirtyVertexPointer"
                , dirtyVertexPointer_function_type( &::osg::State::dirtyVertexPointer ) );
        
        }
        { //::osg::State::disableAllVertexArrays
        
            typedef void ( ::osg::State::*disableAllVertexArrays_function_type )(  ) ;
            
            State_exposer.def( 
                "disableAllVertexArrays"
                , disableAllVertexArrays_function_type( &::osg::State::disableAllVertexArrays )
                , " disable the vertex, normal, color, tex coords, secondary color, fog coord and index arrays." );
        
        }
        { //::osg::State::disableColorPointer
        
            typedef void ( ::osg::State::*disableColorPointer_function_type )(  ) ;
            
            State_exposer.def( 
                "disableColorPointer"
                , disableColorPointer_function_type( &::osg::State::disableColorPointer )
                , " wrapper around glDisableClientState(GL_COLOR_ARRAY);\n note, only updates values that change." );
        
        }
        { //::osg::State::disableFogCoordPointer
        
            typedef void ( ::osg::State::*disableFogCoordPointer_function_type )(  ) ;
            
            State_exposer.def( 
                "disableFogCoordPointer"
                , disableFogCoordPointer_function_type( &::osg::State::disableFogCoordPointer )
                , " wrapper around glDisableClientState(GL_FOG_COORDINATE_ARRAY);\n note, only updates values that change." );
        
        }
        { //::osg::State::disableNormalPointer
        
            typedef void ( ::osg::State::*disableNormalPointer_function_type )(  ) ;
            
            State_exposer.def( 
                "disableNormalPointer"
                , disableNormalPointer_function_type( &::osg::State::disableNormalPointer )
                , " wrapper around glDisableClientState(GL_NORMAL_ARRAY);\n note, only updates values that change." );
        
        }
        { //::osg::State::disableSecondaryColorPointer
        
            typedef void ( ::osg::State::*disableSecondaryColorPointer_function_type )(  ) ;
            
            State_exposer.def( 
                "disableSecondaryColorPointer"
                , disableSecondaryColorPointer_function_type( &::osg::State::disableSecondaryColorPointer )
                , " wrapper around glDisableClientState(GL_SECONDARY_COLOR_ARRAY);\n note, only updates values that change." );
        
        }
        { //::osg::State::disableTexCoordPointer
        
            typedef void ( ::osg::State::*disableTexCoordPointer_function_type )( unsigned int ) ;
            
            State_exposer.def( 
                "disableTexCoordPointer"
                , disableTexCoordPointer_function_type( &::osg::State::disableTexCoordPointer )
                , ( bp::arg("unit") )
                , " wrapper around glDisableClientState(GL_TEXTURE_COORD_ARRAY);\n note, only updates values that change." );
        
        }
        { //::osg::State::disableTexCoordPointersAboveAndIncluding
        
            typedef void ( ::osg::State::*disableTexCoordPointersAboveAndIncluding_function_type )( unsigned int ) ;
            
            State_exposer.def( 
                "disableTexCoordPointersAboveAndIncluding"
                , disableTexCoordPointersAboveAndIncluding_function_type( &::osg::State::disableTexCoordPointersAboveAndIncluding )
                , ( bp::arg("unit") ) );
        
        }
        { //::osg::State::disableVertexAttribPointer
        
            typedef void ( ::osg::State::*disableVertexAttribPointer_function_type )( unsigned int ) ;
            
            State_exposer.def( 
                "disableVertexAttribPointer"
                , disableVertexAttribPointer_function_type( &::osg::State::disableVertexAttribPointer )
                , ( bp::arg("index") )
                , " wrapper around DisableVertexAttribArrayARB(index);\n note, only updates values that change." );
        
        }
        { //::osg::State::disableVertexAttribPointersAboveAndIncluding
        
            typedef void ( ::osg::State::*disableVertexAttribPointersAboveAndIncluding_function_type )( unsigned int ) ;
            
            State_exposer.def( 
                "disableVertexAttribPointersAboveAndIncluding"
                , disableVertexAttribPointersAboveAndIncluding_function_type( &::osg::State::disableVertexAttribPointersAboveAndIncluding )
                , ( bp::arg("index") ) );
        
        }
        { //::osg::State::disableVertexPointer
        
            typedef void ( ::osg::State::*disableVertexPointer_function_type )(  ) ;
            
            State_exposer.def( 
                "disableVertexPointer"
                , disableVertexPointer_function_type( &::osg::State::disableVertexPointer )
                , " wrapper around glDisableClientState(GL_VERTEX_ARRAY).\n note, only updates values that change." );
        
        }
        { //::osg::State::drawQuads
        
            typedef void ( ::osg::State::*drawQuads_function_type )( ::GLint,::GLsizei,::GLsizei ) ;
            
            State_exposer.def( 
                "drawQuads"
                , drawQuads_function_type( &::osg::State::drawQuads )
                , ( bp::arg("first"), bp::arg("count"), bp::arg("primCount")=(::GLsizei)(0) ) );
        
        }
        { //::osg::State::frameCompleted
        
            typedef void ( ::osg::State::*frameCompleted_function_type )(  ) ;
            typedef void ( State_wrapper::*default_frameCompleted_function_type )(  ) ;
            
            State_exposer.def( 
                "frameCompleted"
                , frameCompleted_function_type(&::osg::State::frameCompleted)
                , default_frameCompleted_function_type(&State_wrapper::default_frameCompleted) );
        
        }
        { //::osg::State::getAbortRendering
        
            typedef bool ( ::osg::State::*getAbortRendering_function_type )(  ) const;
            
            State_exposer.def( 
                "getAbortRendering"
                , getAbortRendering_function_type( &::osg::State::getAbortRendering )
                , " Get flag for early termination of the draw traversal,\n if true steps should be taken to complete rendering early." );
        
        }
        { //::osg::State::getActiveTextureUnit
        
            typedef unsigned int ( ::osg::State::*getActiveTextureUnit_function_type )(  ) const;
            
            State_exposer.def( 
                "getActiveTextureUnit"
                , getActiveTextureUnit_function_type( &::osg::State::getActiveTextureUnit )
                , " Get the current texture unit." );
        
        }
        { //::osg::State::getArrayDispatchers
        
            typedef ::osg::ArrayDispatchers & ( ::osg::State::*getArrayDispatchers_function_type )(  ) ;
            
            State_exposer.def( 
                "getArrayDispatchers"
                , getArrayDispatchers_function_type( &::osg::State::getArrayDispatchers )
                , bp::return_internal_reference< >()
                , " Get the helper class for dispatching osg::Arrays as OpenGL attribute data." );
        
        }
        { //::osg::State::getAttribLocation
        
            typedef ::GLint ( ::osg::State::*getAttribLocation_function_type )( ::std::string const & ) const;
            
            State_exposer.def( 
                "getAttribLocation"
                , getAttribLocation_function_type( &::osg::State::getAttribLocation )
                , ( bp::arg("name") ) );
        
        }
        { //::osg::State::getAttributeBindingList
        
            typedef ::std::map< std::string, unsigned int > const & ( ::osg::State::*getAttributeBindingList_function_type )(  ) ;
            
            State_exposer.def( 
                "getAttributeBindingList"
                , getAttributeBindingList_function_type( &::osg::State::getAttributeBindingList )
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::State::getAttributeVec
        
            typedef ::std::vector< std::pair<osg::StateAttribute const*, unsigned int> > & ( ::osg::State::*getAttributeVec_function_type )( ::osg::StateAttribute const * ) ;
            
            State_exposer.def( 
                "getAttributeVec"
                , getAttributeVec_function_type( &::osg::State::getAttributeVec )
                , ( bp::arg("attribute") )
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::State::getCheckForGLErrors
        
            typedef ::osg::State::CheckForGLErrors ( ::osg::State::*getCheckForGLErrors_function_type )(  ) const;
            
            State_exposer.def( 
                "getCheckForGLErrors"
                , getCheckForGLErrors_function_type( &::osg::State::getCheckForGLErrors )
                , " Get whether and how often OpenGL errors should be checked for." );
        
        }
        { //::osg::State::getClientActiveTextureUnit
        
            typedef unsigned int ( ::osg::State::*getClientActiveTextureUnit_function_type )(  ) const;
            
            State_exposer.def( 
                "getClientActiveTextureUnit"
                , getClientActiveTextureUnit_function_type( &::osg::State::getClientActiveTextureUnit )
                , " Get the current tex coord array texture unit." );
        
        }
        { //::osg::State::getColorAlias
        
            typedef ::osg::VertexAttribAlias const & ( ::osg::State::*getColorAlias_function_type )(  ) ;
            
            State_exposer.def( 
                "getColorAlias"
                , getColorAlias_function_type( &::osg::State::getColorAlias )
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::State::getContextID
        
            typedef unsigned int ( ::osg::State::*getContextID_function_type )(  ) const;
            
            State_exposer.def( 
                "getContextID"
                , getContextID_function_type( &::osg::State::getContextID )
                , " Get the current OpenGL context unique ID." );
        
        }
        { //::osg::State::getCurrentElementBufferObject
        
            typedef ::osg::GLBufferObject const * ( ::osg::State::*getCurrentElementBufferObject_function_type )(  ) ;
            
            State_exposer.def( 
                "getCurrentElementBufferObject"
                , getCurrentElementBufferObject_function_type( &::osg::State::getCurrentElementBufferObject )
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::State::getCurrentPixelBufferObject
        
            typedef ::osg::GLBufferObject const * ( ::osg::State::*getCurrentPixelBufferObject_function_type )(  ) ;
            
            State_exposer.def( 
                "getCurrentPixelBufferObject"
                , getCurrentPixelBufferObject_function_type( &::osg::State::getCurrentPixelBufferObject )
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::State::getCurrentShaderCompositionUniformList
        
            typedef ::std::map< std::string, std::pair<osg::ref_ptr<osg::Uniform>, unsigned int> > & ( ::osg::State::*getCurrentShaderCompositionUniformList_function_type )(  ) ;
            
            State_exposer.def( 
                "getCurrentShaderCompositionUniformList"
                , getCurrentShaderCompositionUniformList_function_type( &::osg::State::getCurrentShaderCompositionUniformList )
                , bp::return_internal_reference< >()
                , " Get the unform list in which to inject any uniforms that StateAttribute::apply(State&) methods provide." );
        
        }
        { //::osg::State::getCurrentVertexBufferObject
        
            typedef ::osg::GLBufferObject const * ( ::osg::State::*getCurrentVertexBufferObject_function_type )(  ) ;
            
            State_exposer.def( 
                "getCurrentVertexBufferObject"
                , getCurrentVertexBufferObject_function_type( &::osg::State::getCurrentVertexBufferObject )
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::State::getCurrentViewport
        
            typedef ::osg::Viewport const * ( ::osg::State::*getCurrentViewport_function_type )(  ) const;
            
            State_exposer.def( 
                "getCurrentViewport"
                , getCurrentViewport_function_type( &::osg::State::getCurrentViewport )
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::State::getDisplaySettings
        
            typedef ::osg::DisplaySettings const * ( ::osg::State::*getDisplaySettings_function_type )(  ) const;
            
            State_exposer.def( 
                "getDisplaySettings"
                , getDisplaySettings_function_type( &::osg::State::getDisplaySettings )
                , bp::return_internal_reference< >()
                , " Get the DisplaySettings" );
        
        }
        { //::osg::State::getDynamicObjectCount
        
            typedef unsigned int ( ::osg::State::*getDynamicObjectCount_function_type )(  ) const;
            
            State_exposer.def( 
                "getDynamicObjectCount"
                , getDynamicObjectCount_function_type( &::osg::State::getDynamicObjectCount )
                , " Get the number of dynamic objects that will be rendered in this graphics context this frame." );
        
        }
        { //::osg::State::getDynamicObjectRenderingCompletedCallback
        
            typedef ::osg::State::DynamicObjectRenderingCompletedCallback * ( ::osg::State::*getDynamicObjectRenderingCompletedCallback_function_type )(  ) ;
            
            State_exposer.def( 
                "getDynamicObjectRenderingCompletedCallback"
                , getDynamicObjectRenderingCompletedCallback_function_type( &::osg::State::getDynamicObjectRenderingCompletedCallback )
                , bp::return_internal_reference< >()
                , " Get the callback to be called when the dynamic object count hits 0." );
        
        }
        { //::osg::State::getFogCoordAlias
        
            typedef ::osg::VertexAttribAlias const & ( ::osg::State::*getFogCoordAlias_function_type )(  ) ;
            
            State_exposer.def( 
                "getFogCoordAlias"
                , getFogCoordAlias_function_type( &::osg::State::getFogCoordAlias )
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::State::getFrameStamp
        
            typedef ::osg::FrameStamp * ( ::osg::State::*getFrameStamp_function_type )(  ) ;
            
            State_exposer.def( 
                "getFrameStamp"
                , getFrameStamp_function_type( &::osg::State::getFrameStamp )
                , bp::return_internal_reference< >()
                , " Get the frame stamp for the current frame." );
        
        }
        { //::osg::State::getFrameStamp
        
            typedef ::osg::FrameStamp const * ( ::osg::State::*getFrameStamp_function_type )(  ) const;
            
            State_exposer.def( 
                "getFrameStamp"
                , getFrameStamp_function_type( &::osg::State::getFrameStamp )
                , bp::return_internal_reference< >()
                , " Get the const frame stamp for the current frame." );
        
        }
        { //::osg::State::getGLBeginEndAdapter
        
            typedef ::osg::GLBeginEndAdapter & ( ::osg::State::*getGLBeginEndAdapter_function_type )(  ) ;
            
            State_exposer.def( 
                "getGLBeginEndAdapter"
                , getGLBeginEndAdapter_function_type( &::osg::State::getGLBeginEndAdapter )
                , bp::return_internal_reference< >()
                , " Get the GL adapter object used to map OpenGL 1.0 glBegin/glEnd usage to vertex arrays." );
        
        }
        { //::osg::State::getGlobalDefaultAttribute
        
            typedef ::osg::StateAttribute const * ( ::osg::State::*getGlobalDefaultAttribute_function_type )( ::osg::StateAttribute::Type,unsigned int ) ;
            
            State_exposer.def( 
                "getGlobalDefaultAttribute"
                , getGlobalDefaultAttribute_function_type( &::osg::State::getGlobalDefaultAttribute )
                , ( bp::arg("type"), bp::arg("member")=(unsigned int)(0) )
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::State::getGlobalDefaultModeValue
        
            typedef bool ( ::osg::State::*getGlobalDefaultModeValue_function_type )( ::GLenum ) ;
            
            State_exposer.def( 
                "getGlobalDefaultModeValue"
                , getGlobalDefaultModeValue_function_type( &::osg::State::getGlobalDefaultModeValue )
                , ( bp::arg("mode") ) );
        
        }
        { //::osg::State::getGlobalDefaultTextureAttribute
        
            typedef ::osg::StateAttribute const * ( ::osg::State::*getGlobalDefaultTextureAttribute_function_type )( unsigned int,::osg::StateAttribute::Type,unsigned int ) ;
            
            State_exposer.def( 
                "getGlobalDefaultTextureAttribute"
                , getGlobalDefaultTextureAttribute_function_type( &::osg::State::getGlobalDefaultTextureAttribute )
                , ( bp::arg("unit"), bp::arg("type"), bp::arg("member")=(unsigned int)(0) )
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::State::getGlobalDefaultTextureModeValue
        
            typedef bool ( ::osg::State::*getGlobalDefaultTextureModeValue_function_type )( unsigned int,::GLenum ) ;
            
            State_exposer.def( 
                "getGlobalDefaultTextureModeValue"
                , getGlobalDefaultTextureModeValue_function_type( &::osg::State::getGlobalDefaultTextureModeValue )
                , ( bp::arg("unit"), bp::arg("mode") ) );
        
        }
        { //::osg::State::getGpuTick
        
            typedef ::osg::Timer_t ( ::osg::State::*getGpuTick_function_type )(  ) const;
            
            State_exposer.def( 
                "getGpuTick"
                , getGpuTick_function_type( &::osg::State::getGpuTick ) );
        
        }
        { //::osg::State::getGpuTime
        
            typedef double ( ::osg::State::*getGpuTime_function_type )(  ) const;
            
            State_exposer.def( 
                "getGpuTime"
                , getGpuTime_function_type( &::osg::State::getGpuTime ) );
        
        }
        { //::osg::State::getGpuTimestamp
        
            typedef ::GLuint64EXT ( ::osg::State::*getGpuTimestamp_function_type )(  ) const;
            
            State_exposer.def( 
                "getGpuTimestamp"
                , getGpuTimestamp_function_type( &::osg::State::getGpuTimestamp ) );
        
        }
        { //::osg::State::getGraphicsContext
        
            typedef ::osg::GraphicsContext * ( ::osg::State::*getGraphicsContext_function_type )(  ) ;
            
            State_exposer.def( 
                "getGraphicsContext"
                , getGraphicsContext_function_type( &::osg::State::getGraphicsContext )
                , bp::return_internal_reference< >()
                , " Get the graphics context associated with that owns this State object." );
        
        }
        { //::osg::State::getGraphicsContext
        
            typedef ::osg::GraphicsContext const * ( ::osg::State::*getGraphicsContext_function_type )(  ) const;
            
            State_exposer.def( 
                "getGraphicsContext"
                , getGraphicsContext_function_type( &::osg::State::getGraphicsContext )
                , bp::return_internal_reference< >()
                , " Get the const graphics context associated with that owns this State object." );
        
        }
        { //::osg::State::getGraphicsCostEstimator
        
            typedef ::osg::GraphicsCostEstimator * ( ::osg::State::*getGraphicsCostEstimator_function_type )(  ) ;
            
            State_exposer.def( 
                "getGraphicsCostEstimator"
                , getGraphicsCostEstimator_function_type( &::osg::State::getGraphicsCostEstimator )
                , bp::return_internal_reference< >()
                , " Get the helper class that provides applications with estimate on how much different graphics operations will cost." );
        
        }
        { //::osg::State::getGraphicsCostEstimator
        
            typedef ::osg::GraphicsCostEstimator const * ( ::osg::State::*getGraphicsCostEstimator_function_type )(  ) const;
            
            State_exposer.def( 
                "getGraphicsCostEstimator"
                , getGraphicsCostEstimator_function_type( &::osg::State::getGraphicsCostEstimator )
                , bp::return_internal_reference< >()
                , " Get the cont helper class that provides applications with estimate on how much different graphics operations will cost." );
        
        }
        { //::osg::State::getInitialInverseViewMatrix
        
            typedef ::osg::Matrix const & ( ::osg::State::*getInitialInverseViewMatrix_function_type )(  ) const;
            
            State_exposer.def( 
                "getInitialInverseViewMatrix"
                , getInitialInverseViewMatrix_function_type( &::osg::State::getInitialInverseViewMatrix )
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::State::getInitialViewMatrix
        
            typedef ::osg::Matrix const & ( ::osg::State::*getInitialViewMatrix_function_type )(  ) const;
            
            State_exposer.def( 
                "getInitialViewMatrix"
                , getInitialViewMatrix_function_type( &::osg::State::getInitialViewMatrix )
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::State::getLastAppliedAttribute
        
            typedef ::osg::StateAttribute const * ( ::osg::State::*getLastAppliedAttribute_function_type )( ::osg::StateAttribute::Type,unsigned int ) const;
            
            State_exposer.def( 
                "getLastAppliedAttribute"
                , getLastAppliedAttribute_function_type( &::osg::State::getLastAppliedAttribute )
                , ( bp::arg("type"), bp::arg("member")=(unsigned int)(0) )
                , bp::return_internal_reference< >()
                , " Get the current specified attribute, return NULL if one has not yet been applied." );
        
        }
        { //::osg::State::getLastAppliedMode
        
            typedef bool ( ::osg::State::*getLastAppliedMode_function_type )( ::GLenum ) const;
            
            State_exposer.def( 
                "getLastAppliedMode"
                , getLastAppliedMode_function_type( &::osg::State::getLastAppliedMode )
                , ( bp::arg("mode") )
                , " Get whether the current specified mode is enabled (true) or disabled (false)." );
        
        }
        { //::osg::State::getLastAppliedProgramObject
        
            typedef ::osg::Program::PerContextProgram const * ( ::osg::State::*getLastAppliedProgramObject_function_type )(  ) const;
            
            State_exposer.def( 
                "getLastAppliedProgramObject"
                , getLastAppliedProgramObject_function_type( &::osg::State::getLastAppliedProgramObject )
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::State::getLastAppliedTextureAttribute
        
            typedef ::osg::StateAttribute const * ( ::osg::State::*getLastAppliedTextureAttribute_function_type )( unsigned int,::osg::StateAttribute::Type,unsigned int ) const;
            
            State_exposer.def( 
                "getLastAppliedTextureAttribute"
                , getLastAppliedTextureAttribute_function_type( &::osg::State::getLastAppliedTextureAttribute )
                , ( bp::arg("unit"), bp::arg("type"), bp::arg("member")=(unsigned int)(0) )
                , bp::return_internal_reference< >()
                , " Get the current specified texture attribute, return NULL if one has not yet been applied." );
        
        }
        { //::osg::State::getLastAppliedTextureMode
        
            typedef bool ( ::osg::State::*getLastAppliedTextureMode_function_type )( unsigned int,::GLenum ) const;
            
            State_exposer.def( 
                "getLastAppliedTextureMode"
                , getLastAppliedTextureMode_function_type( &::osg::State::getLastAppliedTextureMode )
                , ( bp::arg("unit"), bp::arg("mode") )
                , " Get whether the current specified texture mode is enabled (true) or disabled (false)." );
        
        }
        { //::osg::State::getMaxBufferObjectPoolSize
        
            typedef unsigned int ( ::osg::State::*getMaxBufferObjectPoolSize_function_type )(  ) const;
            
            State_exposer.def( 
                "getMaxBufferObjectPoolSize"
                , getMaxBufferObjectPoolSize_function_type( &::osg::State::getMaxBufferObjectPoolSize ) );
        
        }
        { //::osg::State::getMaxTexturePoolSize
        
            typedef unsigned int ( ::osg::State::*getMaxTexturePoolSize_function_type )(  ) const;
            
            State_exposer.def( 
                "getMaxTexturePoolSize"
                , getMaxTexturePoolSize_function_type( &::osg::State::getMaxTexturePoolSize ) );
        
        }
        { //::osg::State::getModeValidity
        
            typedef bool ( ::osg::State::*getModeValidity_function_type )( ::GLenum ) ;
            
            State_exposer.def( 
                "getModeValidity"
                , getModeValidity_function_type( &::osg::State::getModeValidity )
                , ( bp::arg("mode") )
                , " Get whether a particular OpenGL mode is valid in the current graphics context.\n Use to disable OpenGL modes that are not supported by current graphics drivers/context." );
        
        }
        { //::osg::State::getModelViewMatrix
        
            typedef ::osg::Matrix const & ( ::osg::State::*getModelViewMatrix_function_type )(  ) const;
            
            State_exposer.def( 
                "getModelViewMatrix"
                , getModelViewMatrix_function_type( &::osg::State::getModelViewMatrix )
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::State::getModelViewMatrixUniform
        
            typedef ::osg::Uniform * ( ::osg::State::*getModelViewMatrixUniform_function_type )(  ) ;
            
            State_exposer.def( 
                "getModelViewMatrixUniform"
                , getModelViewMatrixUniform_function_type( &::osg::State::getModelViewMatrixUniform )
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::State::getModelViewProjectionMatrixUniform
        
            typedef ::osg::Uniform * ( ::osg::State::*getModelViewProjectionMatrixUniform_function_type )(  ) ;
            
            State_exposer.def( 
                "getModelViewProjectionMatrixUniform"
                , getModelViewProjectionMatrixUniform_function_type( &::osg::State::getModelViewProjectionMatrixUniform )
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::State::getNormalAlias
        
            typedef ::osg::VertexAttribAlias const & ( ::osg::State::*getNormalAlias_function_type )(  ) ;
            
            State_exposer.def( 
                "getNormalAlias"
                , getNormalAlias_function_type( &::osg::State::getNormalAlias )
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::State::getNormalMatrixUniform
        
            typedef ::osg::Uniform * ( ::osg::State::*getNormalMatrixUniform_function_type )(  ) ;
            
            State_exposer.def( 
                "getNormalMatrixUniform"
                , getNormalMatrixUniform_function_type( &::osg::State::getNormalMatrixUniform )
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::State::getProjectionMatrix
        
            typedef ::osg::Matrix const & ( ::osg::State::*getProjectionMatrix_function_type )(  ) const;
            
            State_exposer.def( 
                "getProjectionMatrix"
                , getProjectionMatrix_function_type( &::osg::State::getProjectionMatrix )
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::State::getProjectionMatrixUniform
        
            typedef ::osg::Uniform * ( ::osg::State::*getProjectionMatrixUniform_function_type )(  ) ;
            
            State_exposer.def( 
                "getProjectionMatrixUniform"
                , getProjectionMatrixUniform_function_type( &::osg::State::getProjectionMatrixUniform )
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::State::getSecondaryColorAlias
        
            typedef ::osg::VertexAttribAlias const & ( ::osg::State::*getSecondaryColorAlias_function_type )(  ) ;
            
            State_exposer.def( 
                "getSecondaryColorAlias"
                , getSecondaryColorAlias_function_type( &::osg::State::getSecondaryColorAlias )
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::State::getShaderComposer
        
            typedef ::osg::ShaderComposer * ( ::osg::State::*getShaderComposer_function_type )(  ) ;
            
            State_exposer.def( 
                "getShaderComposer"
                , getShaderComposer_function_type( &::osg::State::getShaderComposer )
                , bp::return_internal_reference< >()
                , " Get the ShaderComposor object." );
        
        }
        { //::osg::State::getShaderComposer
        
            typedef ::osg::ShaderComposer const * ( ::osg::State::*getShaderComposer_function_type )(  ) const;
            
            State_exposer.def( 
                "getShaderComposer"
                , getShaderComposer_function_type( &::osg::State::getShaderComposer )
                , bp::return_internal_reference< >()
                , " Get the const ShaderComposor object." );
        
        }
        { //::osg::State::getShaderCompositionEnabled
        
            typedef bool ( ::osg::State::*getShaderCompositionEnabled_function_type )(  ) const;
            
            State_exposer.def( 
                "getShaderCompositionEnabled"
                , getShaderCompositionEnabled_function_type( &::osg::State::getShaderCompositionEnabled ) );
        
        }
        { //::osg::State::getStartTick
        
            typedef ::osg::Timer_t ( ::osg::State::*getStartTick_function_type )(  ) const;
            
            State_exposer.def( 
                "getStartTick"
                , getStartTick_function_type( &::osg::State::getStartTick )
                , " Support for synchronizing the system time and the timestamp\n counter available with ARB_timer_query. Note that State\n doesnt update these values itself." );
        
        }
        { //::osg::State::getStateSetStack
        
            typedef ::std::vector< osg::StateSet const* > & ( ::osg::State::*getStateSetStack_function_type )(  ) ;
            
            State_exposer.def( 
                "getStateSetStack"
                , getStateSetStack_function_type( &::osg::State::getStateSetStack )
                , bp::return_internal_reference< >()
                , " Get the StateSet stack." );
        
        }
        { //::osg::State::getStateSetStackSize
        
            typedef unsigned int ( ::osg::State::*getStateSetStackSize_function_type )(  ) ;
            
            State_exposer.def( 
                "getStateSetStackSize"
                , getStateSetStackSize_function_type( &::osg::State::getStateSetStackSize )
                , " Get the number of StateSets on the StateSet stack." );
        
        }
        { //::osg::State::getTimestampBits
        
            typedef int ( ::osg::State::*getTimestampBits_function_type )(  ) const;
            
            State_exposer.def( 
                "getTimestampBits"
                , getTimestampBits_function_type( &::osg::State::getTimestampBits ) );
        
        }
        { //::osg::State::getUniformLocation
        
            typedef ::GLint ( ::osg::State::*getUniformLocation_function_type )( unsigned int ) const;
            
            State_exposer.def( 
                "getUniformLocation"
                , getUniformLocation_function_type( &::osg::State::getUniformLocation )
                , ( bp::arg("uniformNameID") ) );
        
        }
        { //::osg::State::getUniformLocation
        
            typedef ::GLint ( ::osg::State::*getUniformLocation_function_type )( ::std::string const & ) const;
            
            State_exposer.def( 
                "getUniformLocation"
                , getUniformLocation_function_type( &::osg::State::getUniformLocation )
                , ( bp::arg("uniformName") )
                , " Alternative version of getUniformLocation( unsigned int uniformNameID )\n retrofited into OSG for backward compatibility with osgCal,\n after uniform ids were refactored from std::strings to GLints in OSG version 2.9.10.\n\n Drawbacks: This method is not particularly fast. It has to access mutexed static\n map of uniform ids. So dont overuse it or your app performance will suffer." );
        
        }
        { //::osg::State::getUseModelViewAndProjectionUniforms
        
            typedef bool ( ::osg::State::*getUseModelViewAndProjectionUniforms_function_type )(  ) const;
            
            State_exposer.def( 
                "getUseModelViewAndProjectionUniforms"
                , getUseModelViewAndProjectionUniforms_function_type( &::osg::State::getUseModelViewAndProjectionUniforms ) );
        
        }
        { //::osg::State::getUseVertexAttributeAliasing
        
            typedef bool ( ::osg::State::*getUseVertexAttributeAliasing_function_type )(  ) const;
            
            State_exposer.def( 
                "getUseVertexAttributeAliasing"
                , getUseVertexAttributeAliasing_function_type( &::osg::State::getUseVertexAttributeAliasing ) );
        
        }
        { //::osg::State::getVertexAlias
        
            typedef ::osg::VertexAttribAlias const & ( ::osg::State::*getVertexAlias_function_type )(  ) ;
            
            State_exposer.def( 
                "getVertexAlias"
                , getVertexAlias_function_type( &::osg::State::getVertexAlias )
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::State::getViewFrustum
        
            typedef ::osg::Polytope ( ::osg::State::*getViewFrustum_function_type )(  ) const;
            
            State_exposer.def( 
                "getViewFrustum"
                , getViewFrustum_function_type( &::osg::State::getViewFrustum ) );
        
        }
        { //::osg::State::glDrawArraysInstanced
        
            typedef void ( ::osg::State::*glDrawArraysInstanced_function_type )( ::GLenum,::GLint,::GLsizei,::GLsizei ) ;
            
            State_exposer.def( 
                "glDrawArraysInstanced"
                , glDrawArraysInstanced_function_type( &::osg::State::glDrawArraysInstanced )
                , ( bp::arg("mode"), bp::arg("first"), bp::arg("count"), bp::arg("primcount") ) );
        
        }
        { //::osg::State::glDrawElementsInstanced
        
            typedef void ( ::osg::State::*glDrawElementsInstanced_function_type )( ::GLenum,::GLsizei,::GLenum,::GLvoid const *,::GLsizei ) ;
            
            State_exposer.def( 
                "glDrawElementsInstanced"
                , glDrawElementsInstanced_function_type( &::osg::State::glDrawElementsInstanced )
                , ( bp::arg("mode"), bp::arg("count"), bp::arg("type"), bp::arg("indices"), bp::arg("primcount") ) );
        
        }
        { //::osg::State::haveAppliedAttribute
        
            typedef void ( ::osg::State::*haveAppliedAttribute_function_type )( ::osg::StateAttribute const * ) ;
            
            State_exposer.def( 
                "haveAppliedAttribute"
                , haveAppliedAttribute_function_type( &::osg::State::haveAppliedAttribute )
                , ( bp::arg("attribute") )
                , " Attribute has been applied externally, update state to reflect this setting." );
        
        }
        { //::osg::State::haveAppliedAttribute
        
            typedef void ( ::osg::State::*haveAppliedAttribute_function_type )( ::osg::StateAttribute::Type,unsigned int ) ;
            
            State_exposer.def( 
                "haveAppliedAttribute"
                , haveAppliedAttribute_function_type( &::osg::State::haveAppliedAttribute )
                , ( bp::arg("type"), bp::arg("member")=(unsigned int)(0) )
                , " Attribute has been applied externally,\n and therefore this attribute type has been dirtied\n and will need to be re-applied on next osg::State.apply(..).\n note, if you have an osg::StateAttribute which you have applied externally\n then use the have_applied(attribute) method as this will cause the osg::State to\n track the current state more accurately and enable lazy state updating such\n that only changed state will be applied." );
        
        }
        { //::osg::State::haveAppliedMode
        
            typedef void ( ::osg::State::*haveAppliedMode_function_type )( ::GLenum,unsigned int ) ;
            
            State_exposer.def( 
                "haveAppliedMode"
                , haveAppliedMode_function_type( &::osg::State::haveAppliedMode )
                , ( bp::arg("mode"), bp::arg("value") )
                , " Mode has been set externally, update state to reflect this setting." );
        
        }
        { //::osg::State::haveAppliedMode
        
            typedef void ( ::osg::State::*haveAppliedMode_function_type )( ::GLenum ) ;
            
            State_exposer.def( 
                "haveAppliedMode"
                , haveAppliedMode_function_type( &::osg::State::haveAppliedMode )
                , ( bp::arg("mode") )
                , " Mode has been set externally, therefore dirty the associated mode in osg::State\n so it is applied on next call to osg::State::apply(..)" );
        
        }
        { //::osg::State::haveAppliedTextureAttribute
        
            typedef void ( ::osg::State::*haveAppliedTextureAttribute_function_type )( unsigned int,::osg::StateAttribute const * ) ;
            
            State_exposer.def( 
                "haveAppliedTextureAttribute"
                , haveAppliedTextureAttribute_function_type( &::osg::State::haveAppliedTextureAttribute )
                , ( bp::arg("unit"), bp::arg("attribute") )
                , " texture Attribute has been applied externally, update state to reflect this setting." );
        
        }
        { //::osg::State::haveAppliedTextureAttribute
        
            typedef void ( ::osg::State::*haveAppliedTextureAttribute_function_type )( unsigned int,::osg::StateAttribute::Type,unsigned int ) ;
            
            State_exposer.def( 
                "haveAppliedTextureAttribute"
                , haveAppliedTextureAttribute_function_type( &::osg::State::haveAppliedTextureAttribute )
                , ( bp::arg("unit"), bp::arg("type"), bp::arg("member")=(unsigned int)(0) )
                , " texture Attribute has been applied externally,\n and therefore this attribute type has been dirtied\n and will need to be re-applied on next osg::State.apply(..).\n note, if you have an osg::StateAttribute which you have applied externally\n then use the have_applied(attribute) method as this will the osg::State to\n track the current state more accurately and enable lazy state updating such\n that only changed state will be applied." );
        
        }
        { //::osg::State::haveAppliedTextureMode
        
            typedef void ( ::osg::State::*haveAppliedTextureMode_function_type )( unsigned int,::GLenum,unsigned int ) ;
            
            State_exposer.def( 
                "haveAppliedTextureMode"
                , haveAppliedTextureMode_function_type( &::osg::State::haveAppliedTextureMode )
                , ( bp::arg("unit"), bp::arg("mode"), bp::arg("value") )
                , " texture Mode has been set externally, update state to reflect this setting." );
        
        }
        { //::osg::State::haveAppliedTextureMode
        
            typedef void ( ::osg::State::*haveAppliedTextureMode_function_type )( unsigned int,::GLenum ) ;
            
            State_exposer.def( 
                "haveAppliedTextureMode"
                , haveAppliedTextureMode_function_type( &::osg::State::haveAppliedTextureMode )
                , ( bp::arg("unit"), bp::arg("mode") )
                , " texture Mode has been set externally, therefore dirty the associated mode in osg::State\n so it is applied on next call to osg::State::apply(..)" );
        
        }
        { //::osg::State::initializeExtensionProcs
        
            typedef void ( ::osg::State::*initializeExtensionProcs_function_type )(  ) ;
            
            State_exposer.def( 
                "initializeExtensionProcs"
                , initializeExtensionProcs_function_type( &::osg::State::initializeExtensionProcs )
                , " Initialize extension used by osg:::State." );
        
        }
        { //::osg::State::insertStateSet
        
            typedef void ( ::osg::State::*insertStateSet_function_type )( unsigned int,::osg::StateSet const * ) ;
            
            State_exposer.def( 
                "insertStateSet"
                , insertStateSet_function_type( &::osg::State::insertStateSet )
                , ( bp::arg("pos"), bp::arg("dstate") )
                , " Insert stateset onto state stack." );
        
        }
        { //::osg::State::isFogCoordSupported
        
            typedef bool ( ::osg::State::*isFogCoordSupported_function_type )(  ) const;
            
            State_exposer.def( 
                "isFogCoordSupported"
                , isFogCoordSupported_function_type( &::osg::State::isFogCoordSupported ) );
        
        }
        { //::osg::State::isSecondaryColorSupported
        
            typedef bool ( ::osg::State::*isSecondaryColorSupported_function_type )(  ) const;
            
            State_exposer.def( 
                "isSecondaryColorSupported"
                , isSecondaryColorSupported_function_type( &::osg::State::isSecondaryColorSupported ) );
        
        }
        { //::osg::State::isVertexBufferObjectSupported
        
            typedef bool ( ::osg::State::*isVertexBufferObjectSupported_function_type )(  ) const;
            
            State_exposer.def( 
                "isVertexBufferObjectSupported"
                , isVertexBufferObjectSupported_function_type( &::osg::State::isVertexBufferObjectSupported ) );
        
        }
        { //::osg::State::lazyDisablingOfVertexAttributes
        
            typedef void ( ::osg::State::*lazyDisablingOfVertexAttributes_function_type )(  ) ;
            
            State_exposer.def( 
                "lazyDisablingOfVertexAttributes"
                , lazyDisablingOfVertexAttributes_function_type( &::osg::State::lazyDisablingOfVertexAttributes )
                , " Mark all the vertex attributes as being disabled but leave the disabling till a later call to applyDisablingOfVertexAttributes." );
        
        }
        { //::osg::State::objectDeleted
        
            typedef void ( ::osg::State::*objectDeleted_function_type )( void * ) ;
            typedef void ( State_wrapper::*default_objectDeleted_function_type )( void * ) ;
            
            State_exposer.def( 
                "objectDeleted"
                , objectDeleted_function_type(&::osg::State::objectDeleted)
                , default_objectDeleted_function_type(&State_wrapper::default_objectDeleted)
                , ( bp::arg("object") ) );
        
        }
        { //::osg::State::popAllStateSets
        
            typedef void ( ::osg::State::*popAllStateSets_function_type )(  ) ;
            
            State_exposer.def( 
                "popAllStateSets"
                , popAllStateSets_function_type( &::osg::State::popAllStateSets )
                , " pop all statesets off state stack, ensuring it is empty ready for the next frame.\n Note, to return OpenGL to default state, one should do any state.popAllStatSets(); state.apply()." );
        
        }
        { //::osg::State::popStateSet
        
            typedef void ( ::osg::State::*popStateSet_function_type )(  ) ;
            
            State_exposer.def( 
                "popStateSet"
                , popStateSet_function_type( &::osg::State::popStateSet )
                , " Pop stateset off state stack." );
        
        }
        { //::osg::State::popStateSetStackToSize
        
            typedef void ( ::osg::State::*popStateSetStackToSize_function_type )( unsigned int ) ;
            
            State_exposer.def( 
                "popStateSetStackToSize"
                , popStateSetStackToSize_function_type( &::osg::State::popStateSetStackToSize )
                , ( bp::arg("size") )
                , " Pop StateSets for the StateSet stack till its size equals the specified size." );
        
        }
        { //::osg::State::print
        
            typedef void ( ::osg::State::*print_function_type )( ::std::ostream & ) const;
            
            State_exposer.def( 
                "print"
                , print_function_type( &::osg::State::print )
                , ( bp::arg("fout") )
                , " print out the internal details of osg::State - useful for debugging." );
        
        }
        { //::osg::State::pushStateSet
        
            typedef void ( ::osg::State::*pushStateSet_function_type )( ::osg::StateSet const * ) ;
            
            State_exposer.def( 
                "pushStateSet"
                , pushStateSet_function_type( &::osg::State::pushStateSet )
                , ( bp::arg("dstate") )
                , " Push stateset onto state stack." );
        
        }
        { //::osg::State::removeStateSet
        
            typedef void ( ::osg::State::*removeStateSet_function_type )( unsigned int ) ;
            
            State_exposer.def( 
                "removeStateSet"
                , removeStateSet_function_type( &::osg::State::removeStateSet )
                , ( bp::arg("pos") )
                , " Pop stateset off state stack." );
        
        }
        { //::osg::State::reset
        
            typedef void ( ::osg::State::*reset_function_type )(  ) ;
            
            State_exposer.def( 
                "reset"
                , reset_function_type( &::osg::State::reset )
                , " reset the state object to an empty stack." );
        
        }
        { //::osg::State::resetVertexAttributeAlias
        
            typedef void ( ::osg::State::*resetVertexAttributeAlias_function_type )( bool ) ;
            
            State_exposer.def( 
                "resetVertexAttributeAlias"
                , resetVertexAttributeAlias_function_type( &::osg::State::resetVertexAttributeAlias )
                , ( bp::arg("compactAliasing")=(bool)(true) )
                , " Reset the vertex attribute aliasing to osgs default. This method needs to be called before render anything unless you really know what youre doing !" );
        
        }
        { //::osg::State::setAbortRenderingPtr
        
            typedef void ( ::osg::State::*setAbortRenderingPtr_function_type )( bool * ) ;
            
            State_exposer.def( 
                "setAbortRenderingPtr"
                , setAbortRenderingPtr_function_type( &::osg::State::setAbortRenderingPtr )
                , ( bp::arg("abortPtr") )
                , " Set flag for early termination of the draw traversal." );
        
        }
        { //::osg::State::setActiveTextureUnit
        
            typedef bool ( ::osg::State::*setActiveTextureUnit_function_type )( unsigned int ) ;
            
            State_exposer.def( 
                "setActiveTextureUnit"
                , setActiveTextureUnit_function_type( &::osg::State::setActiveTextureUnit )
                , ( bp::arg("unit") ) );
        
        }
        { //::osg::State::setAttributeBindingList
        
            typedef void ( ::osg::State::*setAttributeBindingList_function_type )( ::std::map< std::string, unsigned int > const & ) ;
            
            State_exposer.def( 
                "setAttributeBindingList"
                , setAttributeBindingList_function_type( &::osg::State::setAttributeBindingList )
                , ( bp::arg("attribBindingList") )
                , " Set the vertex attribute binding list. This method needs to be called before render anything unless you really know what youre doing !" );
        
        }
        { //::osg::State::setCheckForGLErrors
        
            typedef void ( ::osg::State::*setCheckForGLErrors_function_type )( ::osg::State::CheckForGLErrors ) ;
            
            State_exposer.def( 
                "setCheckForGLErrors"
                , setCheckForGLErrors_function_type( &::osg::State::setCheckForGLErrors )
                , ( bp::arg("check") )
                , " Set whether and how often OpenGL errors should be checked for." );
        
        }
        { //::osg::State::setClientActiveTextureUnit
        
            typedef bool ( ::osg::State::*setClientActiveTextureUnit_function_type )( unsigned int ) ;
            
            State_exposer.def( 
                "setClientActiveTextureUnit"
                , setClientActiveTextureUnit_function_type( &::osg::State::setClientActiveTextureUnit )
                , ( bp::arg("unit") )
                , " Set the current tex coord array texture unit, return true if selected,\n false if selection failed such as when multi texturing is not supported.\n note, only updates values that change." );
        
        }
        { //::osg::State::setColorAlias
        
            typedef void ( ::osg::State::*setColorAlias_function_type )( ::osg::VertexAttribAlias const & ) ;
            
            State_exposer.def( 
                "setColorAlias"
                , setColorAlias_function_type( &::osg::State::setColorAlias )
                , ( bp::arg("alias") )
                , " Set the vertex attribute aliasing for color. This method needs to be called before render anything unless you really know what youre doing !" );
        
        }
        { //::osg::State::setColorPointer
        
            typedef void ( ::osg::State::*setColorPointer_function_type )( ::osg::Array const * ) ;
            
            State_exposer.def( 
                "setColorPointer"
                , setColorPointer_function_type( &::osg::State::setColorPointer )
                , ( bp::arg("array") )
                , " Set the color pointer using an osg::Array, and manage any VBO that are required." );
        
        }
        { //::osg::State::setColorPointer
        
            typedef void ( ::osg::State::*setColorPointer_function_type )( ::GLint,::GLenum,::GLsizei,::GLvoid const *,::GLboolean ) ;
            
            State_exposer.def( 
                "setColorPointer"
                , setColorPointer_function_type( &::osg::State::setColorPointer )
                , ( bp::arg("size"), bp::arg("type"), bp::arg("stride"), bp::arg("ptr"), bp::arg("normalized")=(::GLboolean)(1) )
                , " wrapper around glEnableClientState(GL_COLOR_ARRAY);glColorPointer(..);\n note, only updates values that change." );
        
        }
        { //::osg::State::setContextID
        
            typedef void ( ::osg::State::*setContextID_function_type )( unsigned int ) ;
            
            State_exposer.def( 
                "setContextID"
                , setContextID_function_type( &::osg::State::setContextID )
                , ( bp::arg("contextID") )
                , " Set the current OpenGL context uniqueID.\n  The ContextID is used by classes like osg::StateAttributes and osg::Drawables to\n  help manage seperate OpenGL objects, such as display lists, vertex buffer objects\n  and texture object for each graphics context. The ContextID simply acts as an index\n  into arrays that these classes maintain for the purpose of storing GL object handles.\n\n  Note, osgViewer::GraphicsWindow will automatically set up the ContextID for you,\n  so you will rearely need to set this yourself.\n\n  The exception is when creating your own graphics context, where you should set\n  the ContextID uniquely for each graphics context.\n\n  Typical settings for ContextID are 0,1,2,3... up to the maximum\n  number of graphics contexts you have set up. By default contextID is 0." );
        
        }
        { //::osg::State::setCurrentElementBufferObject
        
            typedef void ( ::osg::State::*setCurrentElementBufferObject_function_type )( ::osg::GLBufferObject * ) ;
            
            State_exposer.def( 
                "setCurrentElementBufferObject"
                , setCurrentElementBufferObject_function_type( &::osg::State::setCurrentElementBufferObject )
                , ( bp::arg("ebo") ) );
        
        }
        { //::osg::State::setCurrentPixelBufferObject
        
            typedef void ( ::osg::State::*setCurrentPixelBufferObject_function_type )( ::osg::GLBufferObject * ) ;
            
            State_exposer.def( 
                "setCurrentPixelBufferObject"
                , setCurrentPixelBufferObject_function_type( &::osg::State::setCurrentPixelBufferObject )
                , ( bp::arg("pbo") ) );
        
        }
        { //::osg::State::setCurrentVertexBufferObject
        
            typedef void ( ::osg::State::*setCurrentVertexBufferObject_function_type )( ::osg::GLBufferObject * ) ;
            
            State_exposer.def( 
                "setCurrentVertexBufferObject"
                , setCurrentVertexBufferObject_function_type( &::osg::State::setCurrentVertexBufferObject )
                , ( bp::arg("vbo") ) );
        
        }
        { //::osg::State::setDisplaySettings
        
            typedef void ( ::osg::State::*setDisplaySettings_function_type )( ::osg::DisplaySettings * ) ;
            
            State_exposer.def( 
                "setDisplaySettings"
                , setDisplaySettings_function_type( &::osg::State::setDisplaySettings )
                , ( bp::arg("vs") )
                , " Set the DisplaySettings. Note, nothing is applied, the visual settings are just\n used in the State object to pass the current visual settings to Drawables\n during rendering." );
        
        }
        { //::osg::State::setDynamicObjectCount
        
            typedef void ( ::osg::State::*setDynamicObjectCount_function_type )( unsigned int,bool ) ;
            
            State_exposer.def( 
                "setDynamicObjectCount"
                , setDynamicObjectCount_function_type( &::osg::State::setDynamicObjectCount )
                , ( bp::arg("count"), bp::arg("callCallbackOnZero")=(bool)(false) )
                , " Set the number of dynamic objects that will be rendered in this graphics context this frame." );
        
        }
        { //::osg::State::setDynamicObjectRenderingCompletedCallback
        
            typedef void ( ::osg::State::*setDynamicObjectRenderingCompletedCallback_function_type )( ::osg::State::DynamicObjectRenderingCompletedCallback * ) ;
            
            State_exposer.def( 
                "setDynamicObjectRenderingCompletedCallback"
                , setDynamicObjectRenderingCompletedCallback_function_type( &::osg::State::setDynamicObjectRenderingCompletedCallback )
                , ( bp::arg("cb") )
                , " Set the callback to be called when the dynamic object count hits 0." );
        
        }
        { //::osg::State::setFogCoordAlias
        
            typedef void ( ::osg::State::*setFogCoordAlias_function_type )( ::osg::VertexAttribAlias const & ) ;
            
            State_exposer.def( 
                "setFogCoordAlias"
                , setFogCoordAlias_function_type( &::osg::State::setFogCoordAlias )
                , ( bp::arg("alias") )
                , " Set the vertex attribute aliasing for fog coord. This method needs to be called before render anything unless you really know what youre doing !" );
        
        }
        { //::osg::State::setFogCoordPointer
        
            typedef void ( ::osg::State::*setFogCoordPointer_function_type )( ::osg::Array const * ) ;
            
            State_exposer.def( 
                "setFogCoordPointer"
                , setFogCoordPointer_function_type( &::osg::State::setFogCoordPointer )
                , ( bp::arg("array") )
                , " Set the fog coord pointer using an osg::Array, and manage any VBO that are required." );
        
        }
        { //::osg::State::setFogCoordPointer
        
            typedef void ( ::osg::State::*setFogCoordPointer_function_type )( ::GLenum,::GLsizei,::GLvoid const *,::GLboolean ) ;
            
            State_exposer.def( 
                "setFogCoordPointer"
                , setFogCoordPointer_function_type( &::osg::State::setFogCoordPointer )
                , ( bp::arg("type"), bp::arg("stride"), bp::arg("ptr"), bp::arg("normalized")=(::GLboolean)(0) )
                , " wrapper around glEnableClientState(GL_FOG_COORDINATE_ARRAY);glFogCoordPointer(..);\n note, only updates values that change." );
        
        }
        { //::osg::State::setFrameStamp
        
            typedef void ( ::osg::State::*setFrameStamp_function_type )( ::osg::FrameStamp * ) ;
            
            State_exposer.def( 
                "setFrameStamp"
                , setFrameStamp_function_type( &::osg::State::setFrameStamp )
                , ( bp::arg("fs") )
                , " Set the frame stamp for the current frame." );
        
        }
        { //::osg::State::setGlobalDefaultAttribute
        
            typedef void ( ::osg::State::*setGlobalDefaultAttribute_function_type )( ::osg::StateAttribute const * ) ;
            
            State_exposer.def( 
                "setGlobalDefaultAttribute"
                , setGlobalDefaultAttribute_function_type( &::osg::State::setGlobalDefaultAttribute )
                , ( bp::arg("attribute") ) );
        
        }
        { //::osg::State::setGlobalDefaultModeValue
        
            typedef void ( ::osg::State::*setGlobalDefaultModeValue_function_type )( ::GLenum,bool ) ;
            
            State_exposer.def( 
                "setGlobalDefaultModeValue"
                , setGlobalDefaultModeValue_function_type( &::osg::State::setGlobalDefaultModeValue )
                , ( bp::arg("mode"), bp::arg("enabled") ) );
        
        }
        { //::osg::State::setGlobalDefaultTextureAttribute
        
            typedef void ( ::osg::State::*setGlobalDefaultTextureAttribute_function_type )( unsigned int,::osg::StateAttribute const * ) ;
            
            State_exposer.def( 
                "setGlobalDefaultTextureAttribute"
                , setGlobalDefaultTextureAttribute_function_type( &::osg::State::setGlobalDefaultTextureAttribute )
                , ( bp::arg("unit"), bp::arg("attribute") ) );
        
        }
        { //::osg::State::setGlobalDefaultTextureModeValue
        
            typedef void ( ::osg::State::*setGlobalDefaultTextureModeValue_function_type )( unsigned int,::GLenum,bool ) ;
            
            State_exposer.def( 
                "setGlobalDefaultTextureModeValue"
                , setGlobalDefaultTextureModeValue_function_type( &::osg::State::setGlobalDefaultTextureModeValue )
                , ( bp::arg("unit"), bp::arg("mode"), bp::arg("enabled") ) );
        
        }
        { //::osg::State::setGpuTimestamp
        
            typedef void ( ::osg::State::*setGpuTimestamp_function_type )( ::osg::Timer_t,::GLuint64EXT ) ;
            
            State_exposer.def( 
                "setGpuTimestamp"
                , setGpuTimestamp_function_type( &::osg::State::setGpuTimestamp )
                , ( bp::arg("tick"), bp::arg("timestamp") ) );
        
        }
        { //::osg::State::setGraphicsContext
        
            typedef void ( ::osg::State::*setGraphicsContext_function_type )( ::osg::GraphicsContext * ) ;
            
            State_exposer.def( 
                "setGraphicsContext"
                , setGraphicsContext_function_type( &::osg::State::setGraphicsContext )
                , ( bp::arg("context") )
                , " Set the graphics context associated with that owns this State object." );
        
        }
        { //::osg::State::setGraphicsCostEstimator
        
            typedef void ( ::osg::State::*setGraphicsCostEstimator_function_type )( ::osg::GraphicsCostEstimator * ) ;
            
            State_exposer.def( 
                "setGraphicsCostEstimator"
                , setGraphicsCostEstimator_function_type( &::osg::State::setGraphicsCostEstimator )
                , ( bp::arg("gce") )
                , " Set the helper class that provides applications with estimate on how much different graphics operations will cost." );
        
        }
        { //::osg::State::setInitialViewMatrix
        
            typedef void ( ::osg::State::*setInitialViewMatrix_function_type )( ::osg::RefMatrix const * ) ;
            
            State_exposer.def( 
                "setInitialViewMatrix"
                , setInitialViewMatrix_function_type( &::osg::State::setInitialViewMatrix )
                , ( bp::arg("matrix") ) );
        
        }
        { //::osg::State::setInterleavedArrays
        
            typedef void ( ::osg::State::*setInterleavedArrays_function_type )( ::GLenum,::GLsizei,::GLvoid const * ) ;
            
            State_exposer.def( 
                "setInterleavedArrays"
                , setInterleavedArrays_function_type( &::osg::State::setInterleavedArrays )
                , ( bp::arg("format"), bp::arg("stride"), bp::arg("pointer") )
                , " Wrapper around glInterleavedArrays(..).\n also resets the internal array points and modes within osg::State to keep the other\n vertex array operations consistent." );
        
        }
        { //::osg::State::setLastAppliedProgramObject
        
            typedef void ( ::osg::State::*setLastAppliedProgramObject_function_type )( ::osg::Program::PerContextProgram const * ) ;
            
            State_exposer.def( 
                "setLastAppliedProgramObject"
                , setLastAppliedProgramObject_function_type( &::osg::State::setLastAppliedProgramObject )
                , ( bp::arg("program") ) );
        
        }
        { //::osg::State::setMaxBufferObjectPoolSize
        
            typedef void ( ::osg::State::*setMaxBufferObjectPoolSize_function_type )( unsigned int ) ;
            
            State_exposer.def( 
                "setMaxBufferObjectPoolSize"
                , setMaxBufferObjectPoolSize_function_type( &::osg::State::setMaxBufferObjectPoolSize )
                , ( bp::arg("size") ) );
        
        }
        { //::osg::State::setMaxTexturePoolSize
        
            typedef void ( ::osg::State::*setMaxTexturePoolSize_function_type )( unsigned int ) ;
            
            State_exposer.def( 
                "setMaxTexturePoolSize"
                , setMaxTexturePoolSize_function_type( &::osg::State::setMaxTexturePoolSize )
                , ( bp::arg("size") ) );
        
        }
        { //::osg::State::setModeValidity
        
            typedef void ( ::osg::State::*setModeValidity_function_type )( ::GLenum,bool ) ;
            
            State_exposer.def( 
                "setModeValidity"
                , setModeValidity_function_type( &::osg::State::setModeValidity )
                , ( bp::arg("mode"), bp::arg("valid") )
                , " Set whether a particular OpenGL mode is valid in the current graphics context.\n Use to disable OpenGL modes that are not supported by current graphics drivers/context." );
        
        }
        { //::osg::State::setNormalAlias
        
            typedef void ( ::osg::State::*setNormalAlias_function_type )( ::osg::VertexAttribAlias const & ) ;
            
            State_exposer.def( 
                "setNormalAlias"
                , setNormalAlias_function_type( &::osg::State::setNormalAlias )
                , ( bp::arg("alias") )
                , " Set the vertex attribute aliasing for normal. This method needs to be called before render anything unless you really know what youre doing !" );
        
        }
        { //::osg::State::setNormalPointer
        
            typedef void ( ::osg::State::*setNormalPointer_function_type )( ::osg::Array const * ) ;
            
            State_exposer.def( 
                "setNormalPointer"
                , setNormalPointer_function_type( &::osg::State::setNormalPointer )
                , ( bp::arg("array") )
                , " Set the normal pointer using an osg::Array, and manage any VBO that are required." );
        
        }
        { //::osg::State::setNormalPointer
        
            typedef void ( ::osg::State::*setNormalPointer_function_type )( ::GLenum,::GLsizei,::GLvoid const *,::GLboolean ) ;
            
            State_exposer.def( 
                "setNormalPointer"
                , setNormalPointer_function_type( &::osg::State::setNormalPointer )
                , ( bp::arg("type"), bp::arg("stride"), bp::arg("ptr"), bp::arg("normalized")=(::GLboolean)(0) )
                , " wrapper around glEnableClientState(GL_NORMAL_ARRAY);glNormalPointer(..);\n note, only updates values that change." );
        
        }
        { //::osg::State::setSecondaryColorAlias
        
            typedef void ( ::osg::State::*setSecondaryColorAlias_function_type )( ::osg::VertexAttribAlias const & ) ;
            
            State_exposer.def( 
                "setSecondaryColorAlias"
                , setSecondaryColorAlias_function_type( &::osg::State::setSecondaryColorAlias )
                , ( bp::arg("alias") )
                , " Set the vertex attribute aliasing for secondary color. This method needs to be called before render anything unless you really know what youre doing !" );
        
        }
        { //::osg::State::setSecondaryColorPointer
        
            typedef void ( ::osg::State::*setSecondaryColorPointer_function_type )( ::osg::Array const * ) ;
            
            State_exposer.def( 
                "setSecondaryColorPointer"
                , setSecondaryColorPointer_function_type( &::osg::State::setSecondaryColorPointer )
                , ( bp::arg("array") )
                , " Set the secondary color pointer using an osg::Array, and manage any VBO that are required." );
        
        }
        { //::osg::State::setSecondaryColorPointer
        
            typedef void ( ::osg::State::*setSecondaryColorPointer_function_type )( ::GLint,::GLenum,::GLsizei,::GLvoid const *,::GLboolean ) ;
            
            State_exposer.def( 
                "setSecondaryColorPointer"
                , setSecondaryColorPointer_function_type( &::osg::State::setSecondaryColorPointer )
                , ( bp::arg("size"), bp::arg("type"), bp::arg("stride"), bp::arg("ptr"), bp::arg("normalized")=(::GLboolean)(1) )
                , " wrapper around glEnableClientState(GL_SECONDARY_COLOR_ARRAY);glSecondayColorPointer(..);\n note, only updates values that change." );
        
        }
        { //::osg::State::setShaderComposer
        
            typedef void ( ::osg::State::*setShaderComposer_function_type )( ::osg::ShaderComposer * ) ;
            
            State_exposer.def( 
                "setShaderComposer"
                , setShaderComposer_function_type( &::osg::State::setShaderComposer )
                , ( bp::arg("sc") )
                , " Set the ShaderComposor object that implements shader composition." );
        
        }
        { //::osg::State::setShaderCompositionEnabled
        
            typedef void ( ::osg::State::*setShaderCompositionEnabled_function_type )( bool ) ;
            
            State_exposer.def( 
                "setShaderCompositionEnabled"
                , setShaderCompositionEnabled_function_type( &::osg::State::setShaderCompositionEnabled )
                , ( bp::arg("flag") ) );
        
        }
        { //::osg::State::setStartTick
        
            typedef void ( ::osg::State::*setStartTick_function_type )( ::osg::Timer_t ) ;
            
            State_exposer.def( 
                "setStartTick"
                , setStartTick_function_type( &::osg::State::setStartTick )
                , ( bp::arg("tick") ) );
        
        }
        { //::osg::State::setTexCoordPointer
        
            typedef void ( ::osg::State::*setTexCoordPointer_function_type )( unsigned int,::osg::Array const * ) ;
            
            State_exposer.def( 
                "setTexCoordPointer"
                , setTexCoordPointer_function_type( &::osg::State::setTexCoordPointer )
                , ( bp::arg("unit"), bp::arg("array") )
                , " Set the tex coord pointer using an osg::Array, and manage any VBO that are required." );
        
        }
        { //::osg::State::setTexCoordPointer
        
            typedef void ( ::osg::State::*setTexCoordPointer_function_type )( unsigned int,::GLint,::GLenum,::GLsizei,::GLvoid const *,::GLboolean ) ;
            
            State_exposer.def( 
                "setTexCoordPointer"
                , setTexCoordPointer_function_type( &::osg::State::setTexCoordPointer )
                , ( bp::arg("unit"), bp::arg("size"), bp::arg("type"), bp::arg("stride"), bp::arg("ptr"), bp::arg("normalized")=(::GLboolean)(0) )
                , " wrapper around glEnableClientState(GL_TEXTURE_COORD_ARRAY);glTexCoordPointer(..);\n note, only updates values that change." );
        
        }
        { //::osg::State::setTimestampBits
        
            typedef void ( ::osg::State::*setTimestampBits_function_type )( int ) ;
            
            State_exposer.def( 
                "setTimestampBits"
                , setTimestampBits_function_type( &::osg::State::setTimestampBits )
                , ( bp::arg("bits") ) );
        
        }
        { //::osg::State::setUseModelViewAndProjectionUniforms
        
            typedef void ( ::osg::State::*setUseModelViewAndProjectionUniforms_function_type )( bool ) ;
            
            State_exposer.def( 
                "setUseModelViewAndProjectionUniforms"
                , setUseModelViewAndProjectionUniforms_function_type( &::osg::State::setUseModelViewAndProjectionUniforms )
                , ( bp::arg("flag") ) );
        
        }
        { //::osg::State::setUseVertexAttributeAliasing
        
            typedef void ( ::osg::State::*setUseVertexAttributeAliasing_function_type )( bool ) ;
            
            State_exposer.def( 
                "setUseVertexAttributeAliasing"
                , setUseVertexAttributeAliasing_function_type( &::osg::State::setUseVertexAttributeAliasing )
                , ( bp::arg("flag") ) );
        
        }
        { //::osg::State::setVertexAlias
        
            typedef void ( ::osg::State::*setVertexAlias_function_type )( ::osg::VertexAttribAlias const & ) ;
            
            State_exposer.def( 
                "setVertexAlias"
                , setVertexAlias_function_type( &::osg::State::setVertexAlias )
                , ( bp::arg("alias") )
                , " Set the vertex attribute aliasing for vertex. This method needs to be called before render anything unless you really know what youre doing !" );
        
        }
        { //::osg::State::setVertexAttribIPointer
        
            typedef void ( ::osg::State::*setVertexAttribIPointer_function_type )( unsigned int,::osg::Array const * ) ;
            
            State_exposer.def( 
                "setVertexAttribIPointer"
                , setVertexAttribIPointer_function_type( &::osg::State::setVertexAttribIPointer )
                , ( bp::arg("unit"), bp::arg("array") )
                , " Set the vertex attrib pointer using an osg::Array, and manage any VBO that are required." );
        
        }
        { //::osg::State::setVertexAttribIPointer
        
            typedef void ( ::osg::State::*setVertexAttribIPointer_function_type )( unsigned int,::GLint,::GLenum,::GLsizei,::GLvoid const * ) ;
            
            State_exposer.def( 
                "setVertexAttribIPointer"
                , setVertexAttribIPointer_function_type( &::osg::State::setVertexAttribIPointer )
                , ( bp::arg("index"), bp::arg("size"), bp::arg("type"), bp::arg("stride"), bp::arg("ptr") )
                , " wrapper around glEnableVertexAttribArrayARB(index);glVertexAttribIPointer(..);\n note, only updates values that change." );
        
        }
        { //::osg::State::setVertexAttribLPointer
        
            typedef void ( ::osg::State::*setVertexAttribLPointer_function_type )( unsigned int,::osg::Array const * ) ;
            
            State_exposer.def( 
                "setVertexAttribLPointer"
                , setVertexAttribLPointer_function_type( &::osg::State::setVertexAttribLPointer )
                , ( bp::arg("unit"), bp::arg("array") )
                , " Set the vertex attrib pointer using an osg::Array, and manage any VBO that are required." );
        
        }
        { //::osg::State::setVertexAttribLPointer
        
            typedef void ( ::osg::State::*setVertexAttribLPointer_function_type )( unsigned int,::GLint,::GLenum,::GLsizei,::GLvoid const * ) ;
            
            State_exposer.def( 
                "setVertexAttribLPointer"
                , setVertexAttribLPointer_function_type( &::osg::State::setVertexAttribLPointer )
                , ( bp::arg("index"), bp::arg("size"), bp::arg("type"), bp::arg("stride"), bp::arg("ptr") )
                , " wrapper around glEnableVertexAttribArrayARB(index);glVertexAttribLPointer(..);\n note, only updates values that change." );
        
        }
        { //::osg::State::setVertexAttribPointer
        
            typedef void ( ::osg::State::*setVertexAttribPointer_function_type )( unsigned int,::osg::Array const * ) ;
            
            State_exposer.def( 
                "setVertexAttribPointer"
                , setVertexAttribPointer_function_type( &::osg::State::setVertexAttribPointer )
                , ( bp::arg("unit"), bp::arg("array") )
                , " Set the vertex attrib pointer using an osg::Array, and manage any VBO that are required." );
        
        }
        { //::osg::State::setVertexAttribPointer
        
            typedef void ( ::osg::State::*setVertexAttribPointer_function_type )( unsigned int,::GLint,::GLenum,::GLboolean,::GLsizei,::GLvoid const * ) ;
            
            State_exposer.def( 
                "setVertexAttribPointer"
                , setVertexAttribPointer_function_type( &::osg::State::setVertexAttribPointer )
                , ( bp::arg("index"), bp::arg("size"), bp::arg("type"), bp::arg("normalized"), bp::arg("stride"), bp::arg("ptr") )
                , " wrapper around glEnableVertexAttribArrayARB(index);glVertexAttribPointerARB(..);\n note, only updates values that change." );
        
        }
        { //::osg::State::setVertexPointer
        
            typedef void ( ::osg::State::*setVertexPointer_function_type )( ::osg::Array const * ) ;
            
            State_exposer.def( 
                "setVertexPointer"
                , setVertexPointer_function_type( &::osg::State::setVertexPointer )
                , ( bp::arg("array") )
                , " Set the vertex pointer using an osg::Array, and manage any VBO that are required." );
        
        }
        { //::osg::State::setVertexPointer
        
            typedef void ( ::osg::State::*setVertexPointer_function_type )( ::GLint,::GLenum,::GLsizei,::GLvoid const *,::GLboolean ) ;
            
            State_exposer.def( 
                "setVertexPointer"
                , setVertexPointer_function_type( &::osg::State::setVertexPointer )
                , ( bp::arg("size"), bp::arg("type"), bp::arg("stride"), bp::arg("ptr"), bp::arg("normalized")=(::GLboolean)(0) )
                , " wrapper around glEnableClientState(GL_VERTEX_ARRAY);glVertexPointer(..);\n note, only updates values that change." );
        
        }
        { //::osg::State::unbindElementBufferObject
        
            typedef void ( ::osg::State::*unbindElementBufferObject_function_type )(  ) ;
            
            State_exposer.def( 
                "unbindElementBufferObject"
                , unbindElementBufferObject_function_type( &::osg::State::unbindElementBufferObject ) );
        
        }
        { //::osg::State::unbindPixelBufferObject
        
            typedef void ( ::osg::State::*unbindPixelBufferObject_function_type )(  ) ;
            
            State_exposer.def( 
                "unbindPixelBufferObject"
                , unbindPixelBufferObject_function_type( &::osg::State::unbindPixelBufferObject ) );
        
        }
        { //::osg::State::unbindVertexBufferObject
        
            typedef void ( ::osg::State::*unbindVertexBufferObject_function_type )(  ) ;
            
            State_exposer.def( 
                "unbindVertexBufferObject"
                , unbindVertexBufferObject_function_type( &::osg::State::unbindVertexBufferObject ) );
        
        }
        { //::osg::State::updateModelViewAndProjectionMatrixUniforms
        
            typedef void ( ::osg::State::*updateModelViewAndProjectionMatrixUniforms_function_type )(  ) ;
            
            State_exposer.def( 
                "updateModelViewAndProjectionMatrixUniforms"
                , updateModelViewAndProjectionMatrixUniforms_function_type( &::osg::State::updateModelViewAndProjectionMatrixUniforms ) );
        
        }
        pyplusplus::containers::static_sized::register_array_1< ::std::vector<unsigned int, std::allocator<unsigned int> >, 4, bp::return_internal_reference< > >( "__array_1__scope_std_scope_vector_less_unsigned_int_comma__std_scope_allocator_less_unsigned_int_greater___greater__4" );
        { //osg::State::_quadIndicesGLuint [variable], type=std::vector<unsigned int, std::allocator<unsigned int> >[4]
        
            typedef pyplusplus::containers::static_sized::array_1_t< ::std::vector<unsigned int, std::allocator<unsigned int> >, 4> ( *array_wrapper_creator )( ::osg::State & );
            
            State_exposer.add_property( "_quadIndicesGLuint"
                , bp::make_function( array_wrapper_creator(&State_wrapper::pyplusplus__quadIndicesGLuint_wrapper)
                                    , bp::with_custodian_and_ward_postcall< 0, 1 >() ) );
        }
        pyplusplus::containers::static_sized::register_array_1< ::std::vector<unsigned short, std::allocator<unsigned short> >, 4, bp::return_internal_reference< > >( "__array_1__scope_std_scope_vector_less_unsigned_short_comma__std_scope_allocator_less_unsigned_short_greater___greater__4" );
        { //osg::State::_quadIndicesGLushort [variable], type=std::vector<unsigned short, std::allocator<unsigned short> >[4]
        
            typedef pyplusplus::containers::static_sized::array_1_t< ::std::vector<unsigned short, std::allocator<unsigned short> >, 4> ( *array_wrapper_creator )( ::osg::State & );
            
            State_exposer.add_property( "_quadIndicesGLushort"
                , bp::make_function( array_wrapper_creator(&State_wrapper::pyplusplus__quadIndicesGLushort_wrapper)
                                    , bp::with_custodian_and_ward_postcall< 0, 1 >() ) );
        }
    }

}
